//
//  888    888 8888888 8888888b.  8888888888        d8888  .d8888b.  8888888888 888b     d888
//  888    888   888   888  "Y88b 888              d88888 d88P  Y88b 888        8888b   d8888
//  888    888   888   888    888 888             d88P888 888    888 888        88888b.d88888
//  8888888888   888   888    888 8888888        d88P 888 888        8888888    888Y88888P888
//  888    888   888   888    888 888           d88P  888 888  88888 888        888 Y888P 888
//  888    888   888   888    888 888          d88P   888 888    888 888        888  Y8P  888
//  888    888   888   888  .d88P 888         d8888888888 Y88b  d88P 888        888   "   888
//  888    888 8888888 8888888P"  8888888888 d88P     888  "Y8888P88 8888888888 888       888
// ▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄
// ▄    ____ ______ ____                                      ▄                              ▄
// █   /    /      \    \   HIDEAGEM STEGANOGRAPHY PLATFORM   █                  .     .     █
// █  /___ /________\ ___\                                    █   .-.   .-.      '.___.'     █
// █  \    \        /    /  ASTRAL SOFTWARE FROM THE FUTURE   █  (_  \ /  _)     .'   `.     █
// █    \   \      /   /                                      █       |         :       :    █
// █      \  \    /  /      COPYRIGHT 2024 WWW.CYBERGEM.NET   █       |         :       :    █
// █        \ \  / /                                          █       |          `.___.'     █
// █           \/           LET'S DO COMPUTER STUFF ALL DAY   █                              █
// █                                                          █                              █
// █ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀ █    ._____.         .--.      █
// █ MMMMMSSSSSSSSSSSSSSSSSSSSSSSSSSddMMMMMSSSSSSMSSSSSSSSSS; █      | |          /   _`.    █
// █ MMMMSSSSSSSSSSSSSSSSSMSSSSS; ;SSdMMMMSSSSSSMMSSSSSSSSSS, █      | |         (_) ( )     █
// █ MMSSSSSSSMSSSSSMSSSSMMMSS."-.-":MMMMMSSSSMMMMSSMSSSMMSS  █     _|_|_       '.    /      █
// █ MSSSSSSSMSSSSMMMSSMMMPTMM;"-/\":MMM^"     MMMSSMMMSSMM   █    '     '        `--'       █
// █ SSSSSSSMMSSMMMMMMMMMP-.MMM :  ;.;P       dMMMMMMMMMP'    █                              █
// █ SSMSSSMMMSMMMMMMMMMP   :M;`:  ;.'+"""t+dMMMMMMMMMMP      █                _             █
// █ MMMSSMMMMMMMMPTMMMM"""":P `.\// '    ""^^MMMMMMMP'       █      .--.     ' `:--.--.     █
// █ MMMMMMPTMMMMP="TMMMsg,      \/   db`c"  dMMMMMP"         █     (    )       |  |  |_    █
// █ MMMMMM  TMMM   d$$$b ^          /T$; ;-/TMMMP'  Let's    █    (_)  /        |  |  | )   █
// █ MMMMM; .^`M; d$P^T$$b          :  $$ ::MMMMP  hide some  █        (_,       |  |  |/    █
// █ MMMMMM   .-+d$$   $$$;         ;. $$ ;;MMMP,    Gems !   █                       (J     █
// █ MMMMMMb   _d$$$   $$$$         :$$$; :MMMMMMp.           █                              █
// █ MMMMMM"  " T$$$._.$$$;          T$P.'MMMSSSSSSb          █                _             █
// █ MMM`TMb   -")T$$$$$$P'       `._ ""  :MMSSSMMP'          █       __      ' `:--.--.     █
// █ MMM / \    '  "T$$P"           /     :MMMMMMP'           █  ___.'  '.___    |  |  |     █
// █ MMSb`. ;                      "      :MMMMMM'            █  ____________    |  |  |     █
// █ MMSSb_lSSSb.             .___.       MMMMMP ,d88b.d88b,  █                  |  |  | .., █
// █ MMMMSSSSSSSSb.                     .MMMMMM. 88888888888  █                        `--': █
// █ MMMMMMMMMMMSSSb                  .dMMMMMMMP `Y8888888Y'  █                              █
// █ MMMMMMMMMMMMMSS;               .dMMMMMMMMMM'  `Y888Y'    █         ...             _    █
// █ MMMMGEMMAMMMMb`;"-.          .dMMMMMMMMMMP'     `Y'      █         .':     \      /_)   █
// █ MMMMMMMMMMMMMMb:   `'--.___.dMMMMMMMMMPP'                █       .'         \    /`.    █
// █ MMMMMMMMMMMMMMMb;           dMMMMMMMMPPR                 █   `..'            \  /   ;   █
// █ ▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄ █   .'`.             \/ __.'   █
// █                                                          █                              █
// █          ░░░░░░░░          ▒▒▒▒▒▒▒▒          ░░░░░░░░    █                              █
// █       ▓▓▓░░ ████████    ███▒▒ ▓▓▓▓▓▓▓▓    ▓▓▓░░ ████████ █                 `-.    .-'   █
// █    ▒▒▒▓▓ ░░ ██ ▒▒▒▒▒▒░░░██ ▒▒ ▓▓ ░░░░░░▒▒▒▓▓ ░░ ██+§¥µ██ █ .-"-._.-"-._.-     :  :      █
// █ ███▒▒ ▓▓ ░░░██ ▒▒ ▓▓▓░░ ██ ▒▒▒▓▓ ░░ ███▒▒ ▓▓ ░░░██$@¢¶██ █ .-"-._.-"-._.-   --:--:--    █
// █ ██ ▒▒ ▓▓▓▓▓▓███▒▒ ▓▓ ░░ ██████▓▓▓░░ ██ ▒▒ ▓▓▓▓▓▓████████ █                    :  :      █
// █ ██ ▒▒▒▒▒▒▒▒    ▒▒▒▓▓ ░░░░░░░░    ░░░██ ▒▒▒▒▒▒▒▒          █                 .-'    `-.   █
// █ ████████          ▓▓▓▓▓▓▓▓          ████████    CYBERGEM █                              █
// ▀                                                          ▀                              ▀
// ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀

#include "CYCLE_KEY.h"

#include <cstring>

//
//    CYCLE KEY
//

namespace HIDEAGEM_CORE {


CycleKey::~CycleKey()
{
	vanish();
}


const uint8_t* CycleKey::salt() const
{
	return _salt;
}


size_t CycleKey::salt_size() const
{
	return SALT_SIZE;
}


uint8_t* CycleKey::salt_write()
{
	mem_init();

	return _salt;
}


void CycleKey::init(const std::string& password)
{
	if (b_locked)
	{
		throw _EXCEPTION("Tried to initialize CycleKey that is locked.");
	}

	mem_init();
	gen_key( password );
}


// Regenerates the Cycle Key using the next 640 bits
// of output from the RNG as the password and salt.
void CycleKey::regenerate()
{
	if ( !b_mem_init )
	{
		throw _EXCEPTION("CycleKey memory must be initialized before generating key.");
	}

	GhostVector<uint8_t> rand_password( KEY_SIZE );
	GhostVector<uint8_t> rand_salt( SALT_SIZE );

	for ( int i = 0; i < KEY_SIZE; ++i )
	{
		rand_password[i] = rand<uint8_t>();
	}

	for ( int i = 0; i < SALT_SIZE; ++i )
	{
		rand_salt[i] = rand<uint8_t>();
	}
	
	vanish(); // WITHOUT A TRACE !!!

	mem_init(); // Re-init memory

	// Set random 128-bit salt
	std::memcpy( _salt, rand_salt.data(), SALT_SIZE );

	gen_key( rand_password ); // ( the sword turns upon itself )
}


size_t CycleKey::key_size() const
{
	return KEY_SLICE_SIZE;
}


const uint8_t* CycleKey::key()  const
{
	// It will be revealed with fire ...
	return _fire_key;
}


// Cycles the key after copying if b_cycle is true
GhostVector<uint8_t> CycleKey::copy_key(const bool b_cycle)
{
	if ( ! b_mem_init )
	{
		throw _EXCEPTION("Cycle Key :: Tried to copy key before memory was initialized.");
	}

	GhostVector<uint8_t> key_copy( KEY_SLICE_SIZE );

	for (int i = 0; i < KEY_SLICE_SIZE; ++i)
	{
		key_copy[i] = _fire_key[i];
	}

	if ( b_cycle )
	{
		cycle(); // Generates new Fire Key
	}

	return key_copy;
}


// Returns a copy of current RNG
// Cycles the key after copying the RNG if b_cycle is true
DragonRNG CycleKey::copy_RNG(const bool b_cycle)
{
	if ( b_cycle )
	{
		DragonRNG copy_rng = fire_rng;

		cycle(); // Initializes new RNG

		return copy_rng;
	}

	return fire_rng;
}


// If auto_cycle > 0 then the Fire Key will automatically cycle
// each time auto_cycle num bytes are consumed.
void CycleKey::auto_cycle(const uint64_t _auto_cycle_bytes)
{
	auto_cycle_bytes = _auto_cycle_bytes;
}


// Cycles to next Fire Key slice, consuming all Key Food, and re-seeds Fire RNG
void CycleKey::cycle()
{
	// Gusting to the south, turning to the north,
	// turning, turning, goes the wind,
	// and the wind returns in its cycles.

	cycle_index += 1;

	if ( cycle_index >= NUM_KEY_SLICES )
	{
		cycle_index = 0;
		fire_rng.shuffle( key_slice_order );
	}

	fire_key_index = key_slice_order[ cycle_index ];

	update_keys(); // Init new Fire Key

	// Re-seed Fire RNG with new Fire Key
	fire_rng = DragonRNG( _fire_key, KEY_SLICE_SIZE );
}


void CycleKey::reset_cycle()
{
	cycle_index      = 0;
	fire_key_index   = 0;
	auto_cycle_bytes = 0;

	food_pile.vanish();
	sodium_memzero(_key_food, KEY_SLICE_SIZE);

	// Bootstrap RNG with first raw key slice
	fire_rng = DragonRNG( _key, KEY_SLICE_SIZE );

	// Re-init Fire Key slice order
	for (uint64_t i = 0; i < NUM_KEY_SLICES; ++i)
	{
		key_slice_order[i] = static_cast<KeySliceIndex>(i);
	}

	fire_rng.shuffle( key_slice_order ); // Randomize key slice order

	update_keys(); // Init keys
}


bool CycleKey::is_valid() const
{
	return b_locked && b_mem_init && _key != nullptr && _salt != nullptr;
}


void CycleKey::vanish()
{
	cycle_index      = 0;
	fire_key_index   = 0;
	auto_cycle_bytes = 0;

	fire_rng.vanish();
	food_pile.vanish();

	if (!b_mem_init)
	{
		return;
	}
	else if (sodium_init() < 0)
	{
		return;
	}

	if (b_locked)
	{
		sodium_mprotect_readwrite(_key);
		sodium_mprotect_readwrite(_salt);

		sodium_munlock(_key, KEY_SIZE);
		sodium_munlock(_salt, SALT_SIZE);
		sodium_munlock(_fire_key, KEY_SLICE_SIZE);
		sodium_munlock(_key_food, KEY_SLICE_SIZE);
	}

	sodium_free(_key);
	sodium_free(_salt);
	sodium_free(_fire_key);
	sodium_free(_key_food);

	_key      = nullptr;
	_salt     = nullptr;
	_fire_key = nullptr;
	_key_food = nullptr;

	sodium_memzero(key_slice_order.data(), key_slice_order.size());

	b_locked   = false;
	b_mem_init = false;
}


// Update Key Food array and regenerate Fire Key
void CycleKey::update_keys()
{
	update_key_food();
	update_fire_key();
}


// Hash Food Pile into Key Food Array
void CycleKey::update_key_food()
{
	// Append curent Key Food to end of Food Pile
	// in order to incorporate previous state into hash
	food_pile.resize( food_pile.size() + KEY_SLICE_SIZE );

	std::memcpy(
		food_pile.data() + food_pile.size() - KEY_SLICE_SIZE,
		_key_food,
		KEY_SLICE_SIZE
	);

	// BLAKE2b hash food_pile into _key_food
	if (crypto_generichash(
		_key_food,
		KEY_SLICE_SIZE,
		reinterpret_cast<const unsigned char*>( food_pile.data() ),
		food_pile.size(),
		nullptr, 0) != 0 )
	{
		throw _EXCEPTION("Generic hashing failed while updating Cycle Key food array.");
	}

	food_pile.clear(); // Food Pile is now gone !
}


void CycleKey::update_fire_key()
{
	const uint8_t* fire_cycle = &_key[ KEY_SLICE_SIZE * fire_key_index ];

	// Copy current key slice into Fire Key
	std::memcpy( _fire_key, fire_cycle, KEY_SLICE_SIZE );

	// XOR Fire Key with Key Food
	for ( int i = 0; i < KEY_SLICE_SIZE; ++i )
	{
		_fire_key[i] ^= _key_food[i]; // Feed the fire
	}
}


void CycleKey::mem_init()
{
	if (b_mem_init)
	{
		return;
	}
	else if (sodium_init() < 0)
	{
		throw _EXCEPTION("Cannot initialize CycleKey memory: libsodium could not be initialized.");
	}

	// All bytes get initialized to 0xdb (219) by sodium_malloc
	_key      = (uint8_t*)sodium_malloc(KEY_SIZE);
	_salt     = (uint8_t*)sodium_malloc(SALT_SIZE);
	_fire_key = (uint8_t*)sodium_malloc(KEY_SLICE_SIZE);
	_key_food = (uint8_t*)sodium_malloc(KEY_SLICE_SIZE);

	// Zero bytes
	sodium_memzero(_key, KEY_SIZE);
	sodium_memzero(_salt, SALT_SIZE);
	sodium_memzero(_fire_key, KEY_SLICE_SIZE);
	sodium_memzero(_key_food, KEY_SLICE_SIZE);

	b_mem_init = true;
}


void CycleKey::lock()
{
	if (!b_mem_init)
	{
		throw _EXCEPTION("Tried to lock CycleKey before initializing memory.");
	}
	else if (b_locked)
	{
		return; // Already locked
	}

	// Prevent from being swapped to disk
	sodium_mlock(_key, KEY_SIZE);
	sodium_mlock(_salt, SALT_SIZE);
	sodium_mlock(_fire_key, KEY_SLICE_SIZE);
	sodium_mlock(_key_food, KEY_SLICE_SIZE);

	// Lock read-only
	sodium_mprotect_readonly(_key);
	sodium_mprotect_readonly(_salt);

	// NOTE: Fire Key and Key Food can be mutated

	b_locked = true;
}


void CycleKey::gen_key(const std::string& password)
{
	gen_key( password.data(), password.size() );
}


void CycleKey::gen_key(const GhostVector<uint8_t>& password)
{
	gen_key( reinterpret_cast<const char*>( password.data() ), password.size() );
}


void CycleKey::gen_key(const char* password, size_t password_size)
{
	if (!b_mem_init)
	{
		throw _EXCEPTION("CycleKey memory must be initialized before generating key.");
	}
	else if (sodium_init() < 0)
	{
		throw _EXCEPTION("libsodium could not be initialized.");
	}

	if ( crypto_pwhash(
		static_cast<unsigned char* const>(_key),
		KEY_SIZE,
		static_cast<const char* const>(password),
		password_size,
		static_cast<const unsigned char*>(_salt),
		KEY_OPSLIMIT,
		KEY_MEMLIMIT,
		KEY_ALGO ) != 0 )
	{
		throw _EXCEPTION("Password hashing failed. Cannot generate Cycle Key.");
	}

	///
	//    DONE

	lock(); // Lock data read-only and prevent swapping to disk

	reset_cycle(); // Init keys and RNG
}

}; // namespace HIDEAGEM_CORE

