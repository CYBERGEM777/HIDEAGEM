//
//  888    888 8888888 8888888b.  8888888888        d8888  .d8888b.  8888888888 888b     d888
//  888    888   888   888  "Y88b 888              d88888 d88P  Y88b 888        8888b   d8888
//  888    888   888   888    888 888             d88P888 888    888 888        88888b.d88888
//  8888888888   888   888    888 8888888        d88P 888 888        8888888    888Y88888P888
//  888    888   888   888    888 888           d88P  888 888  88888 888        888 Y888P 888
//  888    888   888   888    888 888          d88P   888 888    888 888        888  Y8P  888
//  888    888   888   888  .d88P 888         d8888888888 Y88b  d88P 888        888   "   888
//  888    888 8888888 8888888P"  8888888888 d88P     888  "Y8888P88 8888888888 888       888
// ▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄
// ▄    ____ ______ ____                                      ▄                              ▄
// █   /    /      \    \   HIDEAGEM STEGANOGRAPHY PLATFORM   █                  .     .     █
// █  /___ /________\ ___\                                    █   .-.   .-.      '.___.'     █
// █  \    \        /    /  ASTRAL SOFTWARE FROM THE FUTURE   █  (_  \ /  _)     .'   `.     █
// █    \   \      /   /                                      █       |         :       :    █
// █      \  \    /  /      COPYRIGHT 2024 WWW.CYBERGEM.NET   █       |         :       :    █
// █        \ \  / /                                          █       |          `.___.'     █
// █           \/           LET'S DO COMPUTER STUFF ALL DAY   █                              █
// █                                                          █                              █
// █ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀ █    ._____.         .--.      █
// █ MMMMMSSSSSSSSSSSSSSSSSSSSSSSSSSddMMMMMSSSSSSMSSSSSSSSSS; █      | |          /   _`.    █
// █ MMMMSSSSSSSSSSSSSSSSSMSSSSS; ;SSdMMMMSSSSSSMMSSSSSSSSSS, █      | |         (_) ( )     █
// █ MMSSSSSSSMSSSSSMSSSSMMMSS."-.-":MMMMMSSSSMMMMSSMSSSMMSS  █     _|_|_       '.    /      █
// █ MSSSSSSSMSSSSMMMSSMMMPTMM;"-/\":MMM^"     MMMSSMMMSSMM   █    '     '        `--'       █
// █ SSSSSSSMMSSMMMMMMMMMP-.MMM :  ;.;P       dMMMMMMMMMP'    █                              █
// █ SSMSSSMMMSMMMMMMMMMP   :M;`:  ;.'+"""t+dMMMMMMMMMMP      █                _             █
// █ MMMSSMMMMMMMMPTMMMM"""":P `.\// '    ""^^MMMMMMMP'       █      .--.     ' `:--.--.     █
// █ MMMMMMPTMMMMP="TMMMsg,      \/   db`c"  dMMMMMP"         █     (    )       |  |  |_    █
// █ MMMMMM  TMMM   d$$$b ^          /T$; ;-/TMMMP'  Let's    █    (_)  /        |  |  | )   █
// █ MMMMM; .^`M; d$P^T$$b          :  $$ ::MMMMP  hide some  █        (_,       |  |  |/    █
// █ MMMMMM   .-+d$$   $$$;         ;. $$ ;;MMMP,    Gems !   █                       (J     █
// █ MMMMMMb   _d$$$   $$$$         :$$$; :MMMMMMp.           █                              █
// █ MMMMMM"  " T$$$._.$$$;          T$P.'MMMSSSSSSb          █                _             █
// █ MMM`TMb   -")T$$$$$$P'       `._ ""  :MMSSSMMP'          █       __      ' `:--.--.     █
// █ MMM / \    '  "T$$P"           /     :MMMMMMP'           █  ___.'  '.___    |  |  |     █
// █ MMSb`. ;                      "      :MMMMMM'            █  ____________    |  |  |     █
// █ MMSSb_lSSSb.             .___.       MMMMMP ,d88b.d88b,  █                  |  |  | .., █
// █ MMMMSSSSSSSSb.                     .MMMMMM. 88888888888  █                        `--': █
// █ MMMMMMMMMMMSSSb                  .dMMMMMMMP `Y8888888Y'  █                              █
// █ MMMMMMMMMMMMMSS;               .dMMMMMMMMMM'  `Y888Y'    █         ...             _    █
// █ MMMMGEMMAMMMMb`;"-.          .dMMMMMMMMMMP'     `Y'      █         .':     \      /_)   █
// █ MMMMMMMMMMMMMMb:   `'--.___.dMMMMMMMMMPP'                █       .'         \    /`.    █
// █ MMMMMMMMMMMMMMMb;           dMMMMMMMMPPR                 █   `..'            \  /   ;   █
// █ ▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄ █   .'`.             \/ __.'   █
// █                                                          █                              █
// █          ░░░░░░░░          ▒▒▒▒▒▒▒▒          ░░░░░░░░    █                              █
// █       ▓▓▓░░ ████████    ███▒▒ ▓▓▓▓▓▓▓▓    ▓▓▓░░ ████████ █                 `-.    .-'   █
// █    ▒▒▒▓▓ ░░ ██ ▒▒▒▒▒▒░░░██ ▒▒ ▓▓ ░░░░░░▒▒▒▓▓ ░░ ██+§¥µ██ █ .-"-._.-"-._.-     :  :      █
// █ ███▒▒ ▓▓ ░░░██ ▒▒ ▓▓▓░░ ██ ▒▒▒▓▓ ░░ ███▒▒ ▓▓ ░░░██$@¢¶██ █ .-"-._.-"-._.-   --:--:--    █
// █ ██ ▒▒ ▓▓▓▓▓▓███▒▒ ▓▓ ░░ ██████▓▓▓░░ ██ ▒▒ ▓▓▓▓▓▓████████ █                    :  :      █
// █ ██ ▒▒▒▒▒▒▒▒    ▒▒▒▓▓ ░░░░░░░░    ░░░██ ▒▒▒▒▒▒▒▒          █                 .-'    `-.   █
// █ ████████          ▓▓▓▓▓▓▓▓          ████████    CYBERGEM █                              █
// ▀                                                          ▀                              ▀
// ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀

#include "GEM_FILE.h"
#include "TERMINAL_UTILS.h"

#include <cstring>
#include <fstream>
#include <filesystem>

//
//    GEM FILE
//

namespace HIDEAGEM_CORE {


GemFile::GemFile(const uint64_t& _size)
{
	init_data(_size);
}


GemFile::GemFile(const uint8_t* copy_data, const uint64_t& copy_size, const char* copy_name, bool b_pack)
{
	init_data(copy_size);
	std::memcpy(_data, copy_data, copy_size); // Copy  data
	_name = copy_name;

	if (b_pack)
	{
		pack();
	}
}


GemFile::GemFile(const std::string& file_path, bool b_pack)
{
	read_binary_file( file_path );

	if (b_pack)
	{
		pack();
	}
}


void GemFile::init_data(const uint64_t& _size)
{
	if (is_valid()) // Do not modify valid file
	{
		printf("ERROR: Tried to init data of already valid Gem File.\n\n");

		return;
	}
	else if (sodium_init() < 0)
	{
		throw _EXCEPTION("ERROR: GemFile::init_data() :: libsodium could not be initialized.\n\n");
	}
	else if (_size == 0)
	{
		throw _EXCEPTION("ERROR: GemFile::init_data() :: Init size is zero.");
	}

	_data = (uint8_t*)sodium_malloc(_size); // Secure malloc
	if (_data != nullptr)
	{
		data_size = _size;
		b_data_init = true;
	}
}


void GemFile::resize(const size_t& new_size)
{
	if (!b_data_init)
	{
		init_data(new_size); // Initialize

		return;
	}
	else if (new_size < 1)
	{
		printf("ERROR: Tried to resize Gem File to size 0.\n\n");

		return;
	}
	else if (new_size == data_size)
	{
		return;
	}
	else if (sodium_init() < 0)
	{
		throw _EXCEPTION("ERROR: GemFile::resize() :: libsodium could not be initialized.\n\n");
	}

	uint8_t* new_data = (uint8_t*)sodium_malloc(new_size); // Secure malloc

	// Copy existing data
	memcpy(new_data, _data, std::min(data_size, new_size));

	// Locked data
	if (b_locked)
	{
		sodium_mprotect_readwrite(_data);   // Read-write
		sodium_mprotect_readonly(new_data); // Read-only
	}

	// Erase old data
	sodium_free(_data); // Secure erase

	_data = new_data;
	data_size = new_size;
}


// Locks data read-only
bool GemFile::lock()
{
	if (b_locked)
	{
		printf("WARNING: Tried to lock already valid Gem File.\n\n");
	}
	else if (!b_data_init)
	{
		printf("ERROR: Tried to lock Gem File before data initialized.\n\n");
	}
	else if (data_size == 0)
	{
		printf("ERROR: Tried to lock Gem File with 0 size.\n\n");
	}
	else
	{
		sodium_mprotect_readonly(_data); // Read-only
		b_locked = true;

		return true;
	}

	return false;
}


bool GemFile::pack()
{
    if (!b_data_init)
    {
        throw _EXCEPTION("ERROR: GemFile::pack() :: Tried to pack Gem data before initializing data.");
    }
    else if (sodium_init() < 0)
    {
        throw _EXCEPTION("ERROR: GemFile::pack() :: libsodium could not be initialized.");
    }
    else if (pack_state == PackState::PACKED)
    {
        return true; // Already packed
    }
    else if (_name.size() > MAX_NAME_LEN)
    {
        PRINT_WARNING("WARNING: GemFile::pack() :: File name exceeds 255 characters and will be truncated to first 255 chars.");
    }

    // TODO preserve file extension when truncating
    const uint8_t name_size =
        _name.size() > MAX_NAME_LEN ? 255 : static_cast<uint8_t>(_name.size());

    const uint64_t blob_size = size() + name_size + sizeof(name_size);

    uint8_t* blob     = (uint8_t*)sodium_malloc( blob_size );
    uint8_t* blob_idx = blob;

    std::memcpy( blob_idx, &name_size, sizeof(name_size) ); // Name size byte
    blob_idx += sizeof(name_size);

    if ( name_size > 0 )
    {
        std::memcpy( blob_idx, _name.data(), name_size ); // Name string
        blob_idx += name_size;
    }

    std::memcpy( blob_idx, _data, size() ); // Data

    if ( b_locked ) // Locked ?
    {
        sodium_mprotect_readonly( blob ); // Read-only
    }

    free_data( _data ); // Free old data

    _data = blob;
    data_size = blob_size;

    pack_state = PackState::PACKED;

    return true;
}


bool GemFile::unpack(const bool b_force)
{
    if (!b_data_init)
    {
        throw _EXCEPTION("ERROR: GemFile::unpack() :: Tried to unpack Gem data before initializing data.");
    }
    else if (sodium_init() < 0)
    {
        throw _EXCEPTION("ERROR: GemFile::unpack() :: libsodium could not be initialized.");
    }

    const bool b_packed = pack_state == PackState::PACKED;

    if ( !b_packed && !b_force )
    {
        return true; // (Possibly) already unpacked
    }

    uint8_t* blob_idx = _data;

    // Unpack file name
    const uint8_t name_size = _data[0];
    blob_idx += sizeof(name_size);

    if ( name_size > 0 )
    {
        _name = std::string( reinterpret_cast<char*>(blob_idx), name_size );
        blob_idx += name_size;
    }

    data_size = data_size - sizeof(name_size) - name_size;

    if ( data_size == 0 ) // Error ?
    {
        throw _EXCEPTION("ERROR: GemFile::Unpack() :: Uncompressed data size is zero.");
    }

    uint8_t* final_data = (uint8_t*)sodium_malloc( data_size );
    std::memcpy( final_data, blob_idx, data_size ); // Copy data

    free_data( _data ); // Free packed data

    _data = final_data;
    pack_state = PackState::UNPACKED;

    if ( b_locked ) // Locked ?
    {
        sodium_mprotect_readonly( _data ); // Read-only
    }

    return true;
}


void GemFile::vanish()
{
	if (sodium_init() < 0)
	{
		_name.clear();

		return;
	}

	free_data(_data);

	sodium_memzero(reinterpret_cast<void*>(&data_size), sizeof(data_size));
	sodium_memzero(reinterpret_cast<void*>(_name.data()), _name.size());

	_name.clear(); // TODO secure erase name
}


void GemFile::read_binary_file(const std::string& file_path)
{
	// Normalize file path
	const std::filesystem::path __file_path(file_path);
	const std::string _file_path = __file_path.lexically_normal().string();

	// Try to open file
	std::ifstream file(_file_path, std::ios::binary | std::ios::ate);

	if ( !file.is_open() )
	{
		return;
	}

	/// 
	//    FILE SIZE AND DATA

	data_size = file.tellg();
	if (data_size == 0)
	{
		return;
	}

	init_data(data_size); // Init memory

	if (!b_data_init)
	{
		return;
	}

	file.seekg(0, std::ios::beg);
	file.read(reinterpret_cast<char*>(_data), data_size);
	file.close();

	sodium_mprotect_readonly(_data); // Read-only
	b_locked = true;

	///
	//   FILE NAME

	_name = std::filesystem::path( _file_path ).filename().string();
}


void GemFile::free_data(uint8_t*& fdata)
{
	if (fdata == nullptr) return;

	sodium_mprotect_readwrite(fdata); // Read-write
	sodium_free(fdata);               // Secure erase
	fdata = nullptr;
}

}; // namespace HIDEAGEM_CORE

