//
//  888    888 8888888 8888888b.  8888888888        d8888  .d8888b.  8888888888 888b     d888
//  888    888   888   888  "Y88b 888              d88888 d88P  Y88b 888        8888b   d8888
//  888    888   888   888    888 888             d88P888 888    888 888        88888b.d88888
//  8888888888   888   888    888 8888888        d88P 888 888        8888888    888Y88888P888
//  888    888   888   888    888 888           d88P  888 888  88888 888        888 Y888P 888
//  888    888   888   888    888 888          d88P   888 888    888 888        888  Y8P  888
//  888    888   888   888  .d88P 888         d8888888888 Y88b  d88P 888        888   "   888
//  888    888 8888888 8888888P"  8888888888 d88P     888  "Y8888P88 8888888888 888       888
// ▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄
// ▄    ____ ______ ____                                      ▄                              ▄
// █   /    /      \    \   HIDEAGEM STEGANOGRAPHY PLATFORM   █                  .     .     █
// █  /___ /________\ ___\                                    █   .-.   .-.      '.___.'     █
// █  \    \        /    /  ASTRAL SOFTWARE FROM THE FUTURE   █  (_  \ /  _)     .'   `.     █
// █    \   \      /   /                                      █       |         :       :    █
// █      \  \    /  /      COPYRIGHT 2024 WWW.CYBERGEM.NET   █       |         :       :    █
// █        \ \  / /                                          █       |          `.___.'     █
// █           \/           LET'S DO COMPUTER STUFF ALL DAY   █                              █
// █                                                          █                              █
// █ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀ █    ._____.         .--.      █
// █ MMMMMSSSSSSSSSSSSSSSSSSSSSSSSSSddMMMMMSSSSSSMSSSSSSSSSS; █      | |          /   _`.    █
// █ MMMMSSSSSSSSSSSSSSSSSMSSSSS; ;SSdMMMMSSSSSSMMSSSSSSSSSS, █      | |         (_) ( )     █
// █ MMSSSSSSSMSSSSSMSSSSMMMSS."-.-":MMMMMSSSSMMMMSSMSSSMMSS  █     _|_|_       '.    /      █
// █ MSSSSSSSMSSSSMMMSSMMMPTMM;"-/\":MMM^"     MMMSSMMMSSMM   █    '     '        `--'       █
// █ SSSSSSSMMSSMMMMMMMMMP-.MMM :  ;.;P       dMMMMMMMMMP'    █                              █
// █ SSMSSSMMMSMMMMMMMMMP   :M;`:  ;.'+"""t+dMMMMMMMMMMP      █                _             █
// █ MMMSSMMMMMMMMPTMMMM"""":P `.\// '    ""^^MMMMMMMP'       █      .--.     ' `:--.--.     █
// █ MMMMMMPTMMMMP="TMMMsg,      \/   db`c"  dMMMMMP"         █     (    )       |  |  |_    █
// █ MMMMMM  TMMM   d$$$b ^          /T$; ;-/TMMMP'  Let's    █    (_)  /        |  |  | )   █
// █ MMMMM; .^`M; d$P^T$$b          :  $$ ::MMMMP  hide some  █        (_,       |  |  |/    █
// █ MMMMMM   .-+d$$   $$$;         ;. $$ ;;MMMP,    Gems !   █                       (J     █
// █ MMMMMMb   _d$$$   $$$$         :$$$; :MMMMMMp.           █                              █
// █ MMMMMM"  " T$$$._.$$$;          T$P.'MMMSSSSSSb          █                _             █
// █ MMM`TMb   -")T$$$$$$P'       `._ ""  :MMSSSMMP'          █       __      ' `:--.--.     █
// █ MMM / \    '  "T$$P"           /     :MMMMMMP'           █  ___.'  '.___    |  |  |     █
// █ MMSb`. ;                      "      :MMMMMM'            █  ____________    |  |  |     █
// █ MMSSb_lSSSb.             .___.       MMMMMP ,d88b.d88b,  █                  |  |  | .., █
// █ MMMMSSSSSSSSb.                     .MMMMMM. 88888888888  █                        `--': █
// █ MMMMMMMMMMMSSSb                  .dMMMMMMMP `Y8888888Y'  █                              █
// █ MMMMMMMMMMMMMSS;               .dMMMMMMMMMM'  `Y888Y'    █         ...             _    █
// █ MMMMGEMMAMMMMb`;"-.          .dMMMMMMMMMMP'     `Y'      █         .':     \      /_)   █
// █ MMMMMMMMMMMMMMb:   `'--.___.dMMMMMMMMMPP'                █       .'         \    /`.    █
// █ MMMMMMMMMMMMMMMb;           dMMMMMMMMPPR                 █   `..'            \  /   ;   █
// █ ▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄ █   .'`.             \/ __.'   █
// █                                                          █                              █
// █          ░░░░░░░░          ▒▒▒▒▒▒▒▒          ░░░░░░░░    █                              █
// █       ▓▓▓░░ ████████    ███▒▒ ▓▓▓▓▓▓▓▓    ▓▓▓░░ ████████ █                 `-.    .-'   █
// █    ▒▒▒▓▓ ░░ ██ ▒▒▒▒▒▒░░░██ ▒▒ ▓▓ ░░░░░░▒▒▒▓▓ ░░ ██+§¥µ██ █ .-"-._.-"-._.-     :  :      █
// █ ███▒▒ ▓▓ ░░░██ ▒▒ ▓▓▓░░ ██ ▒▒▒▓▓ ░░ ███▒▒ ▓▓ ░░░██$@¢¶██ █ .-"-._.-"-._.-   --:--:--    █
// █ ██ ▒▒ ▓▓▓▓▓▓███▒▒ ▓▓ ░░ ██████▓▓▓░░ ██ ▒▒ ▓▓▓▓▓▓████████ █                    :  :      █
// █ ██ ▒▒▒▒▒▒▒▒    ▒▒▒▓▓ ░░░░░░░░    ░░░██ ▒▒▒▒▒▒▒▒          █                 .-'    `-.   █
// █ ████████          ▓▓▓▓▓▓▓▓          ████████    CYBERGEM █                              █
// ▀                                                          ▀                              ▀
// ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀

#include "GEM_OCEAN.h"

#define STB_IMAGE_IMPLEMENTATION
#include "stb_image.h"

#define STB_IMAGE_WRITE_IMPLEMENTATION
#include "stb_image_write.h"

//
//    GEM OCEAN
//

namespace HIDEAGEM_CORE {


GemOcean::~GemOcean()
{
    vanish();
}


GemOcean::GemOcean(const void* source_ocean, const uint64_t source_ocean_size)
{
    if ( source_ocean == nullptr )
    {
        PRINT_ERROR("Tried to create Gem Ocean with nullptr source_ocean.");

        return;
    }
    else if ( source_ocean_size == 0 )
    {
        PRINT_ERROR("Tried to create Gem Ocean with source_ocean_size == 0.");

        return;
    }

    const int desired_channels = 0; // Zero copies channels from source
    const std::string ocean_size_str = bytes_to_size_string(source_ocean_size);

    ocean = static_cast<uint8_t*>(
        stbi_load_from_memory(
            static_cast<const stbi_uc*>(source_ocean), source_ocean_size, &_width, &_height, &_channels, desired_channels
        )
    );

    if ( ocean != nullptr ) // OCEAN is image
    {
        // Set OCEAN type
        switch ( _channels )
        {
            case 1: // Grayscale or PNG8 (indexed color)

                _type = EOceanType::IMAGE_GRAYSCALE;

                break;

            case 3: // RGB

                _type = EOceanType::IMAGE_RGB;

                break;

            case 4: // RGBA

                _type = EOceanType::IMAGE_RGBA;

                break;

            default:
            {
                // TODO test other image types

                stbi_image_free( ocean ); // Free memory
                PRINT_ERROR("Unsupported number of image color channels: %d", _channels);

                return; // E X I T
            }
        }

        _size = static_cast<size_t>( _width * _height * _channels );

        PRINT("Loaded image of size %d x %d [ %s ] with %d color %s.",
		    _width, _height, ocean_size_str.c_str(), _channels, _channels > 1 ? "channels" : "channel");
    }
    else // Not an image: Copy source ocean into OCEAN
    {
        _width    = 0;
        _height   = 0;
        _channels = 0;

        ocean = ( uint8_t* ) malloc( source_ocean_size );
        std::memcpy( ocean, source_ocean, source_ocean_size );

        _size = source_ocean_size;
        _type = EOceanType::BYTES;

        PRINT("Loaded raw file of size %s.", ocean_size_str.c_str());
    }

    // Init OCEAN byte set
    switch_byte_set( DEFAULT_BYTE_SET_KEY );
}


void GemOcean::switch_byte_set(const char* set_key)
{
	if ( byte_set_map.find( set_key ) == byte_set_map.end() )
	{
		// Pass size() rather than _size as the Byte Set may be simulating
		// an OCEAN smaller than the total OCEAN size
		byte_set_map[ set_key ] = OceanByteSet( size(), _type );
	}

	byte_set = &byte_set_map[ set_key ];
	byte_set_key = set_key;
}


void GemOcean::delete_byte_set(const char* delete_key)
{
	byte_set_map.erase( delete_key );

	// Switch to default byte set if deleted current byte set
	if ( delete_key == byte_set_key )
	{
		switch_byte_set( DEFAULT_BYTE_SET_KEY );
	}
}


uint64_t GemOcean::size() const
{
    switch ( _type )
    {
        case EOceanType::BYTES :
        case EOceanType::IMAGE_RGB :
        case EOceanType::IMAGE_GRAYSCALE :

            return _size;

        case EOceanType::IMAGE_RGBA :

            // Subtract alpha channel bytes
            return _size - ( _size / 4 );

        default :

            throw _EXCEPTION("GemOcean :: size() :: Unsupported Ocean type.");
    }

    return _size;
}


bool GemOcean::is_valid() const
{
    return ocean != nullptr && _size > 0;
}


uint8_t* GemOcean::take()
{
    uint8_t* taking_ocean = ocean;
    ocean = nullptr;

    return taking_ocean;
}


void GemOcean::finalize()
{
    if ( ocean == nullptr )
    {
        throw _EXCEPTION("Tried to finalize nullptr Gem Ocean.");
    }
    else if ( b_finalized )
    {
        throw _EXCEPTION("Tried to finalize Gem Ocean that is already finalized.");
    }

    b_finalized = true;

    switch ( _type )
    {
        case EOceanType::IMAGE_RGB :
        case EOceanType::IMAGE_RGBA :
        case EOceanType::IMAGE_GRAYSCALE :

            // Save as PNG image below ...

            break;

        default :

            return; // E X I T
    }

    ///
    //    WRITE OCEAN DATA TO PNG IMAGE FILE IN MEMORY

    int png_size = 0;

    uint8_t* png_data = static_cast<uint8_t*>(
        stbi_write_png_to_mem( ocean, _width * _channels, _width, _height, _channels, &png_size)
    );

    if (sodium_init() < 0)
    {
        free( ocean );
        ocean = nullptr;

        throw _EXCEPTION("Failed to finalize GemOcean: libsodium could not be initialized.");
    }

    sodium_memzero( ocean, _size ); // Secure erase
    free( ocean );                  // Free Ocean memory

    ocean = png_data; // Replace Ocean with PNG file bytes
    _size = png_size; // Update size in bytes
    _type = EOceanType::BYTES; // Set type to BYTES so size() will return correct size
}


void GemOcean::vanish()
{
    _width = 0;
    _height = 0;
    _channels = 0;
    _type = EOceanType::BYTES;

    byte_set_map.clear();

    if ( ocean != nullptr )
    {
        if (sodium_init() < 0)
        {
            _size = 0;
            free( ocean );
            ocean = nullptr;

            throw _EXCEPTION("Failed to vanish GemOcean: libsodium could not be initialized.");
        }

        // Secure erase
        sodium_memzero( ocean, _size );
        free( ocean );
        ocean = nullptr;
    }

    _size = 0;
}

}; // namespace HIDEAGEM_CORE

