//
//  888    888 8888888 8888888b.  8888888888        d8888  .d8888b.  8888888888 888b     d888
//  888    888   888   888  "Y88b 888              d88888 d88P  Y88b 888        8888b   d8888
//  888    888   888   888    888 888             d88P888 888    888 888        88888b.d88888
//  8888888888   888   888    888 8888888        d88P 888 888        8888888    888Y88888P888
//  888    888   888   888    888 888           d88P  888 888  88888 888        888 Y888P 888
//  888    888   888   888    888 888          d88P   888 888    888 888        888  Y8P  888
//  888    888   888   888  .d88P 888         d8888888888 Y88b  d88P 888        888   "   888
//  888    888 8888888 8888888P"  8888888888 d88P     888  "Y8888P88 8888888888 888       888
// ▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄
// ▄    ____ ______ ____                                      ▄                              ▄
// █   /    /      \    \   HIDEAGEM STEGANOGRAPHY PLATFORM   █                  .     .     █
// █  /___ /________\ ___\                                    █   .-.   .-.      '.___.'     █
// █  \    \        /    /  ASTRAL SOFTWARE FROM THE FUTURE   █  (_  \ /  _)     .'   `.     █
// █    \   \      /   /                                      █       |         :       :    █
// █      \  \    /  /      COPYRIGHT 2024 WWW.CYBERGEM.NET   █       |         :       :    █
// █        \ \  / /                                          █       |          `.___.'     █
// █           \/           LET'S DO COMPUTER STUFF ALL DAY   █                              █
// █                                                          █                              █
// █ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀ █    ._____.         .--.      █
// █ MMMMMSSSSSSSSSSSSSSSSSSSSSSSSSSddMMMMMSSSSSSMSSSSSSSSSS; █      | |          /   _`.    █
// █ MMMMSSSSSSSSSSSSSSSSSMSSSSS; ;SSdMMMMSSSSSSMMSSSSSSSSSS, █      | |         (_) ( )     █
// █ MMSSSSSSSMSSSSSMSSSSMMMSS."-.-":MMMMMSSSSMMMMSSMSSSMMSS  █     _|_|_       '.    /      █
// █ MSSSSSSSMSSSSMMMSSMMMPTMM;"-/\":MMM^"     MMMSSMMMSSMM   █    '     '        `--'       █
// █ SSSSSSSMMSSMMMMMMMMMP-.MMM :  ;.;P       dMMMMMMMMMP'    █                              █
// █ SSMSSSMMMSMMMMMMMMMP   :M;`:  ;.'+"""t+dMMMMMMMMMMP      █                _             █
// █ MMMSSMMMMMMMMPTMMMM"""":P `.\// '    ""^^MMMMMMMP'       █      .--.     ' `:--.--.     █
// █ MMMMMMPTMMMMP="TMMMsg,      \/   db`c"  dMMMMMP"         █     (    )       |  |  |_    █
// █ MMMMMM  TMMM   d$$$b ^          /T$; ;-/TMMMP'  Let's    █    (_)  /        |  |  | )   █
// █ MMMMM; .^`M; d$P^T$$b          :  $$ ::MMMMP  hide some  █        (_,       |  |  |/    █
// █ MMMMMM   .-+d$$   $$$;         ;. $$ ;;MMMP,    Gems !   █                       (J     █
// █ MMMMMMb   _d$$$   $$$$         :$$$; :MMMMMMp.           █                              █
// █ MMMMMM"  " T$$$._.$$$;          T$P.'MMMSSSSSSb          █                _             █
// █ MMM`TMb   -")T$$$$$$P'       `._ ""  :MMSSSMMP'          █       __      ' `:--.--.     █
// █ MMM / \    '  "T$$P"           /     :MMMMMMP'           █  ___.'  '.___    |  |  |     █
// █ MMSb`. ;                      "      :MMMMMM'            █  ____________    |  |  |     █
// █ MMSSb_lSSSb.             .___.       MMMMMP ,d88b.d88b,  █                  |  |  | .., █
// █ MMMMSSSSSSSSb.                     .MMMMMM. 88888888888  █                        `--': █
// █ MMMMMMMMMMMSSSb                  .dMMMMMMMP `Y8888888Y'  █                              █
// █ MMMMMMMMMMMMMSS;               .dMMMMMMMMMM'  `Y888Y'    █         ...             _    █
// █ MMMMGEMMAMMMMb`;"-.          .dMMMMMMMMMMP'     `Y'      █         .':     \      /_)   █
// █ MMMMMMMMMMMMMMb:   `'--.___.dMMMMMMMMMPP'                █       .'         \    /`.    █
// █ MMMMMMMMMMMMMMMb;           dMMMMMMMMPPR                 █   `..'            \  /   ;   █
// █ ▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄ █   .'`.             \/ __.'   █
// █                                                          █                              █
// █          ░░░░░░░░          ▒▒▒▒▒▒▒▒          ░░░░░░░░    █                              █
// █       ▓▓▓░░ ████████    ███▒▒ ▓▓▓▓▓▓▓▓    ▓▓▓░░ ████████ █                 `-.    .-'   █
// █    ▒▒▒▓▓ ░░ ██ ▒▒▒▒▒▒░░░██ ▒▒ ▓▓ ░░░░░░▒▒▒▓▓ ░░ ██+§¥µ██ █ .-"-._.-"-._.-     :  :      █
// █ ███▒▒ ▓▓ ░░░██ ▒▒ ▓▓▓░░ ██ ▒▒▒▓▓ ░░ ███▒▒ ▓▓ ░░░██$@¢¶██ █ .-"-._.-"-._.-   --:--:--    █
// █ ██ ▒▒ ▓▓▓▓▓▓███▒▒ ▓▓ ░░ ██████▓▓▓░░ ██ ▒▒ ▓▓▓▓▓▓████████ █                    :  :      █
// █ ██ ▒▒▒▒▒▒▒▒    ▒▒▒▓▓ ░░░░░░░░    ░░░██ ▒▒▒▒▒▒▒▒          █                 .-'    `-.   █
// █ ████████          ▓▓▓▓▓▓▓▓          ████████    CYBERGEM █                              █
// ▀                                                          ▀                              ▀
// ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀

#include "HIDEAGEM_CORE.h"

#include <chrono>
#include <cstdio>
#include <thread>
#include <csignal>
#include <cstdarg>
#include <cstring>
#include <fstream>
#include <iomanip>
#include <sstream>

#include "miniz.h"

#define UTF8PROC_STATIC
#include <utf8proc.h>

#define STB_IMAGE_IMPLEMENTATION
#include "stb_image.h"

#define STB_IMAGE_WRITE_IMPLEMENTATION
#include "stb_image_write.h"

//
//    HIDEAGEM CORE
//

namespace HideAGemCore {

///
//    HIDEAGEM

HideAGem::HideAGem( GemOcean& _ocean )
// TODO initialize all member variables here
: b_pristine(true)
, b_validate_read(false)
, OCEAN(_ocean)
, max_ocean_index(_ocean.size() - 1)
{}


HideAGem::~HideAGem()
{
    erase_sensitive_data();
}


uint64_t HideAGem::get_remaining_byte_capacity() const
{
    return OCEAN.remaining_byte_capacity( GEM_BIT_MODE );
}

///
//    GEM PROTOCOLS

bool HideAGem::init_gem_protocol(const EGemProtocolKey gem_protocol)
{
    if (!b_keys_initialized)
    {
        throw _E("Tried to initialize Gem Protocol before keys were initialized.");
    }

    // Set Gem Protocol
    if (!get_gem_protocol(gem_protocol, GEM_PROTOCOL))
    {
        throw _E("Invalid Gem Protocol key: " + std::to_string((int)gem_protocol));
    }

    if (GEM_PROTOCOL.NAME == "NONE")
    {
        throw _E("Tried to initialize invalid gem protocol.");
    }

    GEM_PROTOCOL_KEY = gem_protocol;

    PRINT("Initialized Gem Protocol %d :: %s", (int)gem_protocol, GEM_PROTOCOL.NAME.c_str());

    return true;
}


void HideAGem::write_gem_header(const EGemProtocolKey gem_protocol_key)
{
    if (b_gem_header_bytes_reserved)
    {
        return; // Already done
    }
    else if (gem_protocol_key == EGemProtocolKey::NONE)
    {
        throw _E("Tried to write NONE Gem Protocol Key to Gem Header.");
    }

    const GemHeader gem_header =
        ( static_cast<GemHeader>( HIDEAGEM_VERSION_MAJOR ) & (( 1U << GEM_PROTOCOL_BIT_SIZE ) - 1 ) ) | 
        ( static_cast<GemHeader>( gem_protocol_key ) << GEM_PROTOCOL_BIT_SIZE );

    // Encrypt Gem Protool Key
    const GemHeader encrypted_gem_header =
        gem_header ^ SHARED_RNG.rand<GemHeader>(); // XOR encrypt

    // Ghost Vector secure erases itself upon destruction
    GhostVector<uint8_t> key_bytes(sizeof encrypted_gem_header);

    for (int i = 0; i < key_bytes.size(); ++i)
    {
        key_bytes[i] = (encrypted_gem_header >> i * 8) & 0xFF;
    }

    BitStream key_bit_stream( key_bytes );

    if ( !GEMMA_RANDOM_write_bit_stream_to_ocean(
            key_bit_stream,               // Bit Stream
            (EBitMode)GEM_HEADER_BIT_MODE // Gem bit mode
        )
    )
    {
        throw _E("Failed to write Gem Header to Ocean.");
    }

    b_gem_header_bytes_reserved = true; // Gem Header bytes reserved
}


EGemProtocolKey HideAGem::read_gem_header()
{
    if (b_gem_header_bytes_reserved)
    {
        return GEM_PROTOCOL_KEY; // Already read
    }

    GemHeader encrypted_gem_header = 0;

    BitCollector bit_collect = GEMMA_RANDOM_extract_gem_bits(
        (EBitMode)GEM_HEADER_BIT_MODE, // Gem bit mode
        sizeof( encrypted_gem_header ) // Bytes to extract
    );

    // Ghost Vector secure erases itself upon destruction
    GhostVector<GemByte>& extra_stream = bit_collect.get_bytes();

    if ( extra_stream.size() == 0 ) // Extracted any bytes ?
    {
        throw _E("Failed to extract Gem Header from Ocean.");
    }

    b_gem_header_bytes_reserved = true; // Gem Header bytes reserved

    const auto key_bytes = bit_collect.get_bytes();

    for (int i = 0; i < sizeof encrypted_gem_header; ++i)
    {
        encrypted_gem_header |= static_cast<uint64_t>(key_bytes[i]) << (i * 8);
    }

    // Decrypt gem header
    GemHeader gem_header =
        encrypted_gem_header ^ SHARED_RNG.rand<GemHeader>(); // XOR decrypt

    // Version number currently unused during extraction,
    // but can be used in the future for helping with backwards compatibility.
    const uint16_t hideagem_version = static_cast<uint16_t>(gem_header & 0xFFFF); // LSB
    const int16_t protocol_key      = static_cast<int16_t>(gem_header >> 16);     // MSB

    return static_cast<EGemProtocolKey>( protocol_key );
}

///
//    MASTER KEY AND SALT

void HideAGem::gen_salt(
    uint8_t* salt,
    const uint64_t salt_size,
    const std::string& password
)
{
    if (b_keys_initialized)
    {
        throw _E("Tried to generate salt after keys were initialized.");
    }

    ///
    //    GENERATE SALT USING RNG SEEDED WITH PASSWORD TO READ RANDOM OCEAN DATA
    //
    //    An RNG is seeded using password and the first Ocean byte index is generated.
    //
    //    Each salt byte written/read, the RNG is warped using the salt byte as coordinates.
    //
    //    Ocean size, NUM_SALT_BYTES bytes read from Ocean, and the random 64-bit salt
    //    byte indices are hashed into a salt.
    //
    //    A random number of salt bytes will have their data randomly "corrupted"
    //    using the Gem Bit Mode specified by the Gem Protocol in order to make
    //    which set each Ocean salt byte is in (mutated or not mutated) indeterminate.
    ///

    const bool b_gem_hide_mode = !b_lock_ocean_write; // Gem hide or find mode

    ///
    //    Salt byte corruption in Gem hide mode

    if ( b_gem_hide_mode && GEM_BIT_MODE == EBitMode::NONE )
    {
        throw _E("Tried to generate salt before GEM_BIT_MODE was initialized.");
    }

    // Data that will be hashed to produce salt.
    // Ghost Vector secure erases itself upon destruction.
    GhostVector<uint8_t> salt_pile;

    auto append_uint64 = [&](uint64_t value) // Local function
    {
        for (int i = 0; i < 8; ++i)
        {
            salt_pile.push_back(static_cast<uint8_t>(value & 0xFF));
            value >>= 8;
        }
    };

    // Append Ocean size to salt
    append_uint64( OCEAN.size() );

    DragonRNG rng( password ); // RNG seeded with password
    DragonRNG true_random_rng; // True random RNG

    // The random rate to corrupt salt byte
    const double rand_corruption_rate = true_random_rng.rand_percent();

    // Read bytes from Ocean into salt hash data vector
    for ( uint8_t i = 0; i < NUM_SALT_BYTES; ++i )
    {
        // Ocean byte index key generated by RNG
        const uint64_t salt_ocean_index = get_rand_ocean_byte_index( rng );
        append_uint64( salt_ocean_index ); // Append random number to salt pile

        GemByte salt_byte = read_ocean_byte( salt_ocean_index );

        // Randomly corrupt salt bytes (only when hiding Gem, not finding)
        if (!b_lock_ocean_write && true_random_rng.rand_bool( rand_corruption_rate ))
        {
            const uint8_t corrupt_byte = true_random_rng.rand_byte();

            salt_byte = write_bits_to_byte_LSB_MATCHING(
                salt_byte,    // Ocean byte
                corrupt_byte, // Corruption bits
                GEM_BIT_MODE  // Num LSBs to write
            );

            write_ocean_byte( salt_ocean_index, salt_byte ); // Write mutated byte to Ocean
        }

        salt_pile.push_back( salt_byte ); // Add salt byte to hash data array

        rng.warp( static_cast<uint64_t>( salt_byte ) ); // Warp RNG !
    }

    // Hash data into salt
    if ( crypto_generichash(
            salt,
            salt_size,
            salt_pile.data(),
            salt_pile.size(),
            nullptr, 0 ) != 0 )
    {
        throw _E("Hashing salt data failed while generating salt.");
    }
}


void HideAGem::init_master_key(const std::string& password)
{
    if ( b_keys_initialized ) // Keys already initialized ... ?
    {
        throw _E("Tried to initialize Master Key more than once.");
    }
    else if ( sodium_init() < 0 )
    {
        throw _E("libsodium could not be initialized."); // W O A H !
    }
    else if ( sodium_library_version_major() != REQUIRED_SODIUM_VERSION_MAJOR ||
              sodium_library_version_minor() != REQUIRED_SODIUM_VERSION_MINOR )
    {
        throw _E("libsodium version mismatch."); // Test new versions thoroughly !
    }

    ///
    //    INITIALIZE SALT AND MASTER KEY

    // Normalize Unicode string
    const std::string NORMALIZED_PASSWORD = normalize_unicode( password );

    // Generate salt from reserved Ocean bytes
    gen_salt( MASTER_KEY.salt_write(), MASTER_KEY.salt_size(), NORMALIZED_PASSWORD );

    // Generate MASTER_KEY using password and salt
    MASTER_KEY.init( NORMALIZED_PASSWORD );

    // Secure erase normalized password
    sodium_memzero( const_cast<char*>( NORMALIZED_PASSWORD.data() ), NORMALIZED_PASSWORD.size() );

    if ( !MASTER_KEY.is_valid() )
    {
        throw _E("Master Key invalid after init.");
    }

    ///
    //    CONFIGURE MASTER KEY

    // Activate auto cycle
    MASTER_KEY.auto_cycle( DEFAULT_MASTER_KEY_AUTO_CYCLE_RATE );

    ///
    //    CREATE GEM STREAM ENCRYPTION KEY
    //
    //    NOTE: copy_key() automatically cycles MASTER_KEY

    // Cache key for encrypting and decrypting Gem Stream
    GEM_STREAM_ENCRYPT_KEY = MASTER_KEY.copy_key();

    ///
    //    INITIALIZE RANDOM NUMBER GENERATORS
    //
    //    NOTE: copy_RNG() automatically cycles MASTER_KEY

    SHARED_RNG = MASTER_KEY.copy_RNG(); // Shared for various tasks

    BYTE_COUNT_ENCRYPT_RNG = MASTER_KEY.copy_RNG(); // Byte count encryption

    READ_STOP_BYTES_ENCRYPT_RNG = MASTER_KEY.copy_RNG(); // Read stop bytes encryption

    DATA_WHITEN_RNG = MASTER_KEY.copy_RNG(); // Data whitening

    // Fast forward data whitening RNG by a true random number of cycles
    DATA_WHITEN_RNG.fast_forward( TRUE_RANDOM::rand<uint64_t>() );

    ///
    //    DONE

    b_keys_initialized = true; // You better have the MAGIC WORD ... <3 !
}


void HideAGem::erase_sensitive_data(const bool b_erase_hash)
{
    MASTER_KEY.vanish(); // !!! WITHOUT A TRACE !!!

    GEM_STREAM_ENCRYPT_KEY.vanish();

    GEM_PROTOCOL     = GemProtocol();
    GEM_PROTOCOL_KEY = EGemProtocolKey::NONE;

    max_ocean_index = 0;

    SHARED_RNG.vanish();
    BYTE_COUNT_ENCRYPT_RNG.vanish();
    READ_STOP_BYTES_ENCRYPT_RNG.vanish();
    DATA_WHITEN_RNG.vanish();

    gem_bit_stream.vanish();
    gem_files.clear();

    GEM_BIT_MODE = EBitMode::NONE;

    if (b_erase_hash)
    {
        sodium_memzero(reinterpret_cast<void*>(GEM_HASH.data()), GEM_HASH.size());
        sodium_memzero(reinterpret_cast<void*>(GEM_SEAL.data()), GEM_SEAL.size());
        GEM_HASH.clear();
        GEM_SEAL.clear();
    }
}

///
//    ENCRYPTION

GemSize HideAGem::encrypt_gem_stream_byte_count(
    const GemSize byte_count,
    const GemSize byte_capacity
)
{
    if (!b_keys_initialized)
    {
        throw _E("Tried to decrypt Gem byte count before keys were initialized.");
    }
    else if (GEM_PROTOCOL_KEY == EGemProtocolKey::NONE)
    {
        throw _E("Tried to encrypt Gem byte count before initializing Gem Protocol.");
    }

    const GemSize XOR_key = BYTE_COUNT_ENCRYPT_RNG.rand<GemSize>();

    // Pad byte count with random multiple of Ocean byte capacity and encrypt with XOR.
    //
    // Padding ensures that it can't be distinguished from a random number.
    const uint64_t max_multiple =
        ( std::numeric_limits<GemSize>::max() / byte_capacity ) - 1;

    const GemSize padded_byte_count = static_cast<GemSize>(
        ( byte_capacity * BYTE_COUNT_ENCRYPT_RNG.rand_range( max_multiple ) ) + byte_count
    );

    const GemSize encrypted_padded_byte_count = padded_byte_count ^ XOR_key; // XOR

    return encrypted_padded_byte_count;
}


GemSize HideAGem::decrypt_gem_stream_byte_count(
    const GemSize encrypted_padded_byte_count,
    const GemSize byte_capacity
)
{
    if (!b_keys_initialized)
    {
        throw _E("Tried to decrypt Gem byte count before keys were initialized.");
    }
    else if (GEM_PROTOCOL_KEY == EGemProtocolKey::NONE)
    {
        throw _E("Tried to decrypt Gem byte count before initializing Gem Protocol.");
    }

    const GemSize XOR_key = BYTE_COUNT_ENCRYPT_RNG.rand<GemSize>();

    if (byte_capacity > 0)
    {
        // Decrypt using XOR and mod
        const GemSize byte_count = 
            ( encrypted_padded_byte_count ^ XOR_key ) % byte_capacity;

        return byte_count;
    }

    return encrypted_padded_byte_count ^ XOR_key;
}

///
//    HIDE GEM FILES

bool HideAGem::hide_gem_files(
    int gem_protocol,
    const std::vector<std::string>& file_paths,
    const std::string& password,
    const int time_trap,
    bool b_validate
)
{
    ///
    //    GEM FILES TO HIDE

    std::vector<GemFile> gem_files;

    for (const auto& file_path : file_paths)
    {
        gem_files.push_back( GemFile( file_path ) );
        GemFile& gem_file = gem_files.back();

        if (!gem_file.is_valid())
        {
            PRINT_ERROR("ERROR: Could not read file: %s", file_path.c_str());
            ERROR_CODE = EGemErrorCode::BAD_ARGUMENT;

            return false;
        }
    }

    return hide_gem_files( gem_protocol, gem_files, password, time_trap, b_validate );
}


bool HideAGem::hide_gem_files(
    int gem_protocol,
    std::vector<GemFile>& gem_files,
    const std::string& password,
    const int time_trap,
    bool b_validate
)
{
    if (!b_pristine)
    {
        PRINT_ERROR("ERROR: HIDEAGEM instance has already been used.");
        ERROR_CODE = EGemErrorCode::NOT_PRISTINE;

        return false;
    }
    // Ocean
    else if (!OCEAN.is_valid())
    {
        PRINT_ERROR("ERROR: Ocean is invalid.");
        ERROR_CODE = EGemErrorCode::BAD_ARGUMENT;

        return false;
    }
    // Gem Files
    else if (gem_files.size() == 0)
    {
        PRINT_ERROR("ERROR: Gem file path is empty.");
        ERROR_CODE = EGemErrorCode::BAD_ARGUMENT;

        return false;
    }

    HIDE_TERM_CURSOR();
    INIT_SIGNAL_WATCHERS() // Init system signal watchers (e.g. SIGINT)

    ///
    //    TIME

    const auto start_time = std::chrono::high_resolution_clock::now();
    auto stop_time = std::chrono::high_resolution_clock::now();
    std::chrono::duration<double> time_duration;
    double time_s = 0;

    ///
    //    INIT VARIABLES

    b_pristine         = false; // Do not reuse HideAGem instances
    b_lock_ocean_write = false; // UNLOCK !!!
    GEM_PROTOCOL_KEY   = static_cast<EGemProtocolKey>(gem_protocol);
    b_validate_read    = b_validate; // Validate Gem Files after hiding by reading from Ocean

    ///
    //    TIME TRAP

    switch ( GEM_PROTOCOL_KEY )
    {
        case EGemProtocolKey::RUBY_TIME_TRAP :

            // Set Time Trap level
            if ( time_trap < static_cast<int>( ETimeTrapLevel::MIN ) ||
                 time_trap > static_cast<int>( ETimeTrapLevel::MAX ) )
            {
                ERROR_CODE = EGemErrorCode::INVALID_TIME_TRAP_LEVEL;
                std::cerr << "Invalid Time Trap level: " << time_trap << "\n\n";

                return false;
            }
            else
            {
                set_time_trap_level( time_trap ); // Set Time Trap level
            }

            break;

        default :

            break;
    }

    ///
    //    HIDE GEM !!!

    try
    {
        const bool b_hidden = hide_gem_files_internal(gem_files, password);

        switch (ERROR_CODE)
        {
            case EGemErrorCode::NONE:
            {
        
                if (!b_hidden)
                {
                    PRINT("ERROR: Gem Hide Failure code is NONE but b_hidden is true.");

                    goto GEM_HIDE_FAILURE; // E X I T ...
                }

                ///
                //    FINAL UNIVERSE STATE

                DragonRNG universe_state_rng = MASTER_KEY.copy_RNG( false /* b_cycle */ );
                process_final_RNG_state( universe_state_rng ); // Magic <3 !

                goto gem_hide_success; // Gem hidden successfully !!! <3
            }

            case EGemErrorCode::NOT_ENOUGH_SPACE:

                // Gem size too large to fit in Ocean !
                goto GEM_HIDE_FAILURE;

            case EGemErrorCode::DEAD_END:

                PRINT("Ran out of Ocean bytes!");

                goto GEM_HIDE_FAILURE; // E X I T ...

            default :
            case EGemErrorCode::UNKNOWN:

                PRINT("ERROR: UNKNOWN ERROR CODE !!! ");

                goto GEM_HIDE_FAILURE; // E X I T ...
        }
    }
    catch (const _E& e)
    {
        std::cerr << e.what() << std::endl << std::endl;

        goto GEM_HIDE_FAILURE; // E X I T ...
    }
    catch(const std::exception& e)
    {
        std::cerr << e.what() << std::endl << std::endl;

        goto GEM_HIDE_FAILURE; // E X I T ...
    }
    catch ( ... )
    {
        std::cerr << "Caught unknown exception!" << std::endl << std::endl;

        goto GEM_HIDE_FAILURE; // E X I T ...
    }

gem_hide_success:

    ///
    //    GEM HIDE SUCCEEDED !!!

    stop_time = std::chrono::high_resolution_clock::now();
    time_duration = stop_time - start_time;
    time_s = time_duration.count();

    if (gem_files.size() > 1)
    {
        PRINT_SUCCESS("*** HID %llu GEMS IN %.2fs ***",
                (uint64_t)gem_files.size(), time_s); // <3 !!!
    }
    else
    {
        PRINT_SUCCESS("*** HID A GEM IN %.2fs ***", time_s); // <3 !!!
    }

    ///
    //    VALIDATE READ

    if (b_validate_read)
    {
        PRINT_WARNING("*** STARTING GEM VALIDATION ***");

        OCEAN.switch_byte_set( GEM_VALIDATION_OCEAN_BYTE_SET_NAME );

        const bool b_time_trap = TIME_TRAP_LEVEL != ETimeTrapLevel::NONE;

        // TODO create copy of Ocean Bit Set before Gem hide,
        //      as the set may not have been unused (e.g. multiple passwords per Ocean)
        HideAGem hag = HideAGem( OCEAN );
        std::vector<GemFile> _gem_files;

        hag.b_print_gem_hash = false;
        hag.b_print_gem_seal = false;

        const uint64_t num_found_gem_files = hag.find_gem_files( password, _gem_files, b_time_trap );

        switch ( hag.get_error_code() ) // PROCESS ERROR
        {
            case EGemErrorCode::EXIT_SIGNAL :
            case EGemErrorCode::GEM_STREAM_DECOMPRESSION_ABORTED :

                goto GEM_HIDE_FAILURE; // E X I T

            default :

                break;
        }

        if (_gem_files.size() == 0)
        {
            PRINT_ERROR("*** ERROR: READ ZERO GEM FILES ***");

            ERROR_CODE = EGemErrorCode::GEM_VALIDATION_FAILED;

            goto GEM_HIDE_FAILURE; // E X I T ...
        }
        if (_gem_files.size() != gem_files.size())
        {
            PRINT_ERROR("*** ERROR: READ %llu GEM FILES BUT EXPECTED %llu ***", (uint64_t)_gem_files.size(), (uint64_t)gem_files.size());

            ERROR_CODE = EGemErrorCode::GEM_VALIDATION_FAILED;

            goto GEM_HIDE_FAILURE; // E X I T ...
        }
        else
        {
            for (int g = 0; g < _gem_files.size(); ++g)
            {
                auto& gem_bytes = gem_files[g];
                gem_bytes.unpack(); // Unpack Gem File

                const auto& read_bytes = _gem_files[g];

                for (int i = 0; i < gem_bytes.size(); ++i)
                {
                    if (read_bytes.data()[i] != gem_bytes.data()[i])
                    {
                        PRINT_ERROR("*** ERROR: GEM READ BYTES _DO_NOT_ MATCH GEM WRITE BYTES IN GEM FILE %d !!! INDEX: %d ***\n\n  READ: %d   EXPECTED: %d",
                                g, i, read_bytes.data()[i], gem_bytes.data()[i]);

                        ERROR_CODE = EGemErrorCode::GEM_VALIDATION_FAILED;

                        goto GEM_HIDE_FAILURE; // E X I T ...
                    }
                }

                const int gem_num = g + 1;
                PRINT_SUCCESS("*** GEM %d VALIDATION SUCCESS: ALL BYTES MATCH ***", gem_num);
            }

            if (_gem_files.size() > 1)
            {
                PRINT_SUCCESS("*** GEM VALIDATION SUCCESS: ALL GEMS VALIDATED ***");
            }
        }
    }

    print_gem_hash();
    PRINT_GEM_SEAL(); // <3

    ///
    //    EXIT

    erase_sensitive_data(); // Erase keys and other sensitive data

    ///
    //    WARN EMPTY PASSWORD

    if (password.length() == 0)
    {
        PRINT_WARNING("*** WARNING: Used an empty password !!! ***");
    }

    SHOW_TERM_CURSOR();

    return true; // E X I T <3

GEM_HIDE_FAILURE:

    ///
    //    EXIT

    // Delete Gem read validation byte set
    OCEAN.delete_byte_set( GEM_VALIDATION_OCEAN_BYTE_SET_NAME );

    if ( ERROR_CODE != EGemErrorCode::EXIT_SIGNAL )
    {
        PRINT_ERROR("*** FAILED TO HIDE GEM ***");
    }

    SHOW_TERM_CURSOR();

    return false; // E X I T </3
}


bool HideAGem::hide_gem_files_internal(
        std::vector<GemFile>& gem_files,
        const std::string& password
        )
{
    ///
    //    VALIDATE GEM PROTOCOL

    switch ( GEM_PROTOCOL_KEY )
    {
        case EGemProtocolKey::AUTO :
        case EGemProtocolKey::GEMMA_RANDOM :
        case EGemProtocolKey::RUBY_TIME_TRAP :

            break;

        default:

            const std::string ERR = "Invalid Gem Protocol: " + std::to_string( (int)GEM_PROTOCOL_KEY );

            throw _E( ERR );
    }

    ///
    //    PRE-PROCESS GEM FILES

    uint64_t gem_files_size = 0;
    uint64_t predicted_file_stream_size = 0;
    GhostVector<size_t> gem_files_uncompressed_sizes;
    gem_files_uncompressed_sizes.reserve( gem_files.size() );

    for (auto& gem_file : gem_files)
    {
        gem_files_size += gem_file.size();
        gem_files_uncompressed_sizes.push_back( gem_file.size() );
        gem_file.pack(); // Pack Gem File
        predicted_file_stream_size += gem_file.size() + GEM_FILE_HEAD_SIZE;
    }

    ///
    //    FILE STREAM

    size_t stream_idx = 0;
    GhostVector<GemByte> file_stream( predicted_file_stream_size );

    for (auto& gem_file : gem_files)
    {
        auto* _data = gem_file.data();
        const GemSize _size = static_cast<GemSize>( gem_file.size() );

        file_stream.write_bytes_at( _size, stream_idx); // Write size
        stream_idx += sizeof( _size );

        for (int i = 0; i < gem_file.size(); ++i) // Write data
        {
            file_stream[ stream_idx ] = _data[i];
            ++stream_idx;
        }
    }

    ///
    //    MINIZ COMPRESS

    uint64_t decompression_size = file_stream.size();

    uint64_t compressed_size       = file_stream.size();
    double miniz_compression_ratio = 0;

    // Add room at the end for compressed size uint64_t
    GemFile compressed_file_stream( compressed_size + MINIZ_TAIL_SIZE );

    // Compress
    HideAGemCore::miniz_compress( file_stream.data(), file_stream.size(), compressed_file_stream.data(), &compressed_size );

    GemByte* file_stream_ptr  = compressed_file_stream.data();
    uint64_t file_stream_size = compressed_size + MINIZ_TAIL_SIZE;

    if ( file_stream_size >= decompression_size ) // Compression failed ?
    {
        decompression_size = 0; // Zero size MINIZ_TAIL indicates no compression

        for (int i = 0; i < MINIZ_TAIL_SIZE; ++i)
        {
            file_stream.push_back( 0 ); // Init MINIZ_TAIL_SIZE bytes
        }

        file_stream_ptr = file_stream.data();

        // Write decompressed size to end ( MINIZ_TAIL )
        uint8_t* size_address = file_stream_ptr + file_stream.size() - MINIZ_TAIL_SIZE;
        std::memcpy( size_address, &decompression_size, MINIZ_TAIL_SIZE );

        file_stream_size = file_stream.size();
    }
    else // Compression successful !
    {
        miniz_compression_ratio = 1 - ( (double)compressed_size / file_stream.size() );

        file_stream.vanish(); // Secure erase

        // Write compressed size to end ( MINIZ_TAIL )
        uint8_t* size_address = file_stream_ptr + compressed_size;
        std::memcpy( size_address, &decompression_size, MINIZ_TAIL_SIZE );
    }

    ///
    //    FINAL GEM STREAM SIZE

    uint64_t gem_stream_final_size = 0;

    switch ( GEM_PROTOCOL_KEY )
    {
        case EGemProtocolKey::AUTO :
        case EGemProtocolKey::GEMMA_RANDOM :

            gem_stream_final_size =
                GEM_STREAM_HEAD_SIZE + file_stream_size +
                GEM_STREAM_TAIL_SIZE + GEM_STREAM_NONCE_SIZE;

            break;

        case EGemProtocolKey::RUBY_TIME_TRAP :

            gem_stream_final_size =
                file_stream_size + GEM_STREAM_TAIL_SIZE +
                GEM_STREAM_NONCE_SIZE + READ_STOP_BYTE_COUNT;

            break;

        default:

            const std::string ERR = "Tried to calculate final Gem Stream size using invalid Gem Protocol: " + std::to_string( (int)GEM_PROTOCOL_KEY );

            throw _E( ERR );
    }

    const uint64_t final_ocean_size = OCEAN.num_bytes_remaining();

    if ( gem_stream_final_size > final_ocean_size ) // Over max capacity ?
    {
        ERROR_CODE = EGemErrorCode::NOT_ENOUGH_SPACE;
        PRINT("Cannot fit Gem of size %llu bytes in Ocean of size %llu bytes.", gem_stream_final_size, final_ocean_size);

        throw _E("Not enough space in Ocean.");
    }

    ///
    //    WELCOME TO HIDEAGEM !!!

    const std::string ocean_size_str = HideAGemCore::bytes_to_size_string( final_ocean_size );
    const std::string gem_size_str   = HideAGemCore::bytes_to_size_string( gem_files_size );

    PRINT("Hiding %llu %s of total size %s", (uint64_t)gem_files.size(), gem_files.size() > 1 ? "Gems" : "Gem", gem_size_str.c_str());

    // Print Gem File info
    for (int i = 0; i < gem_files.size(); ++i)
    {
        const auto& gem_file = gem_files[i];
        const uint64_t gem_file_size = gem_files_uncompressed_sizes[i];
        PRINT_COLOR("CYAN_BRIGHT", " %s \033[97m%llu bytes\033[97m", gem_file.name().c_str(), gem_file_size);
    }

    const std::string gem_stream_final_size_str = HideAGemCore::bytes_to_size_string(gem_stream_final_size);

    // Print final Gem Stream size and compression ratio
    if ( miniz_compression_ratio > 0 )
    {
        PRINT("Final Gem Stream size: %s [ compressed %.2f %% ]",
            gem_stream_final_size_str.c_str(), 100 * miniz_compression_ratio
        );
    }
    else
    {   
        PRINT("Final Gem Stream size: %s", gem_stream_final_size_str.c_str());
    }

    ///
    //    TODO :: TEMPORARY LIMIT ON GEM SIZE DURING ALPHA TESTING
    //

    if ( gem_stream_final_size > TEMPORARY_MAX_GEM_SIZE )
    {
        PRINT( "Max Gem size exceeded: %llu (temporary limit for alpha testing phase).", TEMPORARY_MAX_GEM_SIZE );

        throw _E( "Exiting." );
    }

    ///
    //    GEM PROTOCOLS :: SELECT GEM BIT MODE

    switch ( GEM_PROTOCOL_KEY )
    {
        case EGemProtocolKey::AUTO :

            GEM_PROTOCOL_KEY = EGemProtocolKey::GEMMA_RANDOM;

            // FALL THROUGH -._

        case EGemProtocolKey::GEMMA_RANDOM :
        case EGemProtocolKey::RUBY_TIME_TRAP :
            {
                ///
                //    GEMMA_RANDOM + AUTO GEM BIT MODE

                // Order from least to greatest capacity
                GhostVector<EBitMode> auto_bit_modes =
                {
                    _1_BIT,
                    _2_BIT,
                    _3_BIT,
                    _4_BIT,
                    _5_BIT,
                    _6_BIT,
                    _7_BIT,
                    _8_BIT,
                };

                const uint64_t num_param_bytes      = 8 * GEMMA_RANDOM_PARAMS_SIZE;
                const uint64_t num_gem_header_bytes = 8 * sizeof( GemHeader );

                for (const auto bit_mode : auto_bit_modes)
                {
                    GEM_BIT_MODE = bit_mode; // Set to next bit mode

                    ///
                    //    SUBRACT FROM TOTAL OCEAN BYTES:
                    //
                    //    - Salt bytes
                    //    - Gem Header bytes (1 bit per byte)
                    //    - GEMMA_RANDOM paramater bytes (1 bit per byte)

                    const uint64_t num_ocean_bytes =
                        get_remaining_byte_capacity() - NUM_SALT_BYTES -
                        num_gem_header_bytes - num_param_bytes;

                    const uint64_t capacity = ( GEM_BIT_MODE * num_ocean_bytes ) / 8;

                    if (gem_stream_final_size <= capacity)
                    {
                        break;
                    }
                }

                break;
            }

        default:

            const std::string ERR = "Tried to select Gem bit mode using invalid Gem Protocol: " + std::to_string( (int)GEM_PROTOCOL_KEY );

            throw _E( ERR );
    }

    ///
    //    INITIALIZE MASTER KEY
    //
    //    Must be called after initializing GEM_PROTOCOL_KEY

    init_master_key( password );

    ///
    //    INITIALIZE GEM PROTOCOL

    const bool b_protocol_init = init_gem_protocol( GEM_PROTOCOL_KEY );
    if (!b_protocol_init)
    {
        std::cerr << "Failed to initialize Gem Protocol." << std::endl << std::endl;

        return false;
    }

    ///
    //    WRITE TIME TRAP TO OCEAN

    if ( TIME_TRAP_LEVEL != ETimeTrapLevel::NONE )
    {
        PRINT_COLOR("MAGENTA", "CASTING GEM SPELL: LEVEL %d RUBY TIME TRAP", (int)TIME_TRAP_LEVEL);

        // Write Time Trap using reverse index so that highest levels are first
        write_bit_trap_to_ocean( 7 - static_cast<uint64_t>( TIME_TRAP_LEVEL ) );

        // Smallest bit modes are at front of Bit Trap
        write_bit_trap_to_ocean( static_cast<uint8_t>( GEM_BIT_MODE ) - 1 );
    }

    ///
    //    WRITE GEM HEADER TO GEM OCEAN

    else
    {
        write_gem_header( GEM_PROTOCOL_KEY ); // Auto reserves Ocean bytes

        ///
        //    WRITE GEM BIT MODE TO OCEAN

        // Encrypt with SHARED_RNG
        const uint8_t encrypted_bit_mode = static_cast<uint8_t>( GEM_BIT_MODE ) ^ SHARED_RNG.rand<uint8_t>();

        GhostVector<uint8_t> extra_data = { encrypted_bit_mode };
        BitStream extra_stream( extra_data );

        // Write in 1-bit mode
        if ( !GEMMA_RANDOM_write_bit_stream_to_ocean(
                    extra_stream,               // Bit Stream
                    EBitMode::_1_BIT            // Gem bit mode
                    )
           )
        {
            throw _E("Failed to write extra data to Ocean.");
        }
    }

    ///
    //
    //    IMPORTANT NOTE !!!
    //
    //    The Master Key must be initialized and the Gem metadata
    //    written to the Ocean BEFORE verifying final Gem Stream size.
    //
    //    Writing metadata reserves bytes in the Ocean, reducing the
    //    available data embed capacity.
    //
    ///

    ///
    //    VERIFY FINAL GEM STREAM SIZE

    if (gem_stream_final_size > get_remaining_byte_capacity())
    {
        const uint64_t max_bytes = get_remaining_byte_capacity();
        const std::string max_bytes_str = HideAGemCore::bytes_to_size_string( max_bytes );

        PRINT("Cannot fit Gem of size %llu bytes in Ocean of size %llu bytes using Gem Protocol %s ",
                gem_stream_final_size, max_bytes, GEM_PROTOCOL.NAME.c_str());

        PRINT("Max capacity for this Ocean and Gem Protocol: %s ( %llu bytes )", max_bytes_str.c_str(), max_bytes);

        ERROR_CODE = EGemErrorCode::NOT_ENOUGH_SPACE;

        return false;
    }

    ///
    //    THE GEM STREAM

    GhostVector<GemByte> gem_stream( gem_stream_final_size );

    // Leave room at beginning for stream byte count
    GemByte* gem_stream_ptr = nullptr;

    switch ( GEM_PROTOCOL_KEY )
    {
        case EGemProtocolKey::GEMMA_RANDOM :

            gem_stream_ptr = gem_stream.data() + GEM_STREAM_HEAD_SIZE;

            break;

        case EGemProtocolKey::RUBY_TIME_TRAP :

            // Stop value will be written at end of stream
            gem_stream_ptr = gem_stream.data();

            break;

        default:

            const std::string ERR = "Tried to initialize Gem Stream with invalid Gem Protocol: " + std::to_string( (int)GEM_PROTOCOL_KEY );

            throw _E( ERR );
    }

    ///
    //    GENERATE 192-BIT TRUE RANDOM NONCE

    GhostVector<uint8_t> gem_nonce( GEM_STREAM_NONCE_SIZE );

    TRUE_RANDOM::rand_bytes( gem_nonce.data(), gem_nonce.size() );

    for (auto& _byte : gem_nonce)
    {
        // XOR with data whitening stream to try to mitigate
        // potential compromise of operating system's randomness sources
        _byte ^= DATA_WHITEN_RNG.rand_byte();
    }

    ///
    //    ENCRYPT WITH XChaCha20_Poly1305

    unsigned long long encrypted_len;

    // Encrypt gem using MASTER_KEY
    const auto _err = crypto_aead_xchacha20poly1305_ietf_encrypt(
            gem_stream_ptr,
            &encrypted_len,
            reinterpret_cast<const unsigned char*>(file_stream_ptr),
            file_stream_size,
            nullptr,
            0, // No additional data
            nullptr,
            reinterpret_cast<const unsigned char*>(gem_nonce.data()),
            reinterpret_cast<const unsigned char*>(GEM_STREAM_ENCRYPT_KEY.data())
            );

    // Secure erase
    GEM_STREAM_ENCRYPT_KEY.vanish();
    file_stream.vanish();

    if (_err != 0)
    {
        throw _E("Gem Stream encryption failed.");
    }

    ///
    //    FINALIZE GEM STREAM

    switch ( GEM_PROTOCOL_KEY )
    {
        ///
        //    WRITE STOP VALUE TO END OF GEM STREAM

        case EGemProtocolKey::RUBY_TIME_TRAP :
            {
                if ( gem_stream.size() < ( READ_STOP_BYTE_COUNT + GEM_STREAM_NONCE_SIZE ))
                {
                    throw _E("Final Gem Stream size smaller than expected.");
                }

                ///
                //    WRITE NONCE TO END OF GEM STREAM

                const size_t nonce_offset =
                    gem_stream.size() - GEM_STREAM_NONCE_SIZE - READ_STOP_BYTE_COUNT;

                // XOR nonce with cipher stream (encrypt) and write to Gem Stream
                for (int i = 0; i < gem_nonce.size(); ++i)
                {
                    gem_stream[ nonce_offset + i ] = gem_nonce[i] ^ SHARED_RNG.rand_byte();
                }

                gem_nonce.vanish(); // Secure erase

                // In this mode, the Gem Stream head becomes the tail !
                // The size of the Gem Stream is not known until (and if) it is found.

                for (uint64_t i = gem_stream.size() - READ_STOP_BYTE_COUNT; i < gem_stream.size(); ++i)
                {
                    gem_stream[i] = READ_STOP_BYTE_VALUE ^ READ_STOP_BYTES_ENCRYPT_RNG.rand<GemByte>();
                }

                break;
            }

            // --

        case EGemProtocolKey::GEMMA_RANDOM :
            {
                if ( gem_stream.size() < GEM_STREAM_NONCE_SIZE )
                {
                    throw _E("Final Gem Stream size smaller than expected.");
                }

                ///
                //    WRITE NONCE TO END OF GEM STREAM

                const size_t nonce_offset = gem_stream.size() - GEM_STREAM_NONCE_SIZE;

                // XOR nonce with cipher stream (encrypt) and write to Gem Stream
                for (int i = 0; i < gem_nonce.size(); ++i)
                {
                    gem_stream[ nonce_offset + i ] = gem_nonce[i] ^ SHARED_RNG.rand_byte();
                }

                gem_nonce.vanish(); // Secure erase

                ///
                //    WRITE OBFUSCATED BYTE COUNT TO BEGINNING OF GEM STREAM

                // In this mode, the Gem Stream head becomes the tail !
                // The size of the Gem Stream is not known until (and if) it is found.
                if ( gem_stream.size() < GEM_STREAM_HEAD_SIZE )
                {
                    throw _E("Final Gem Stream size smaller than expected.");
                }

                const GemSize gem_stream_size = encrypt_gem_stream_byte_count(
                        static_cast<GemSize>( gem_stream.size() - GEM_STREAM_HEAD_SIZE ),
                        static_cast<GemSize>( get_remaining_byte_capacity() )
                        );

                gem_stream.write_bytes_at( gem_stream_size, 0 /* index */ );

                break;
            }

            // --

        default:

            const std::string ERR = "Tried to finalize Gem Stream with invalid Gem Protocol: " + std::to_string( (int)GEM_PROTOCOL_KEY );

            throw _E( ERR );
    }

    ///
    //    HIDE GEM

    bool b_gem_hide_success = false;

    // Init gem bit stream
    gem_bit_stream = BitStream( gem_stream );

    switch ( GEM_PROTOCOL_KEY )
    {
        case EGemProtocolKey::GEMMA_RANDOM :
        case EGemProtocolKey::RUBY_TIME_TRAP :
            {
                ///
                //    WRITE GEM STREAM TO OCEAN

                PRINT("Ocean Write Mode: GEMMA_%dR :: %d-BIT RANDOM", GEM_BIT_MODE, GEM_BIT_MODE);

                // Hide gem !!! <3
                b_gem_hide_success = GEMMA_RANDOM_write_bit_stream_to_ocean(
                        gem_bit_stream,          // Bit Stream
                        GEM_BIT_MODE,            // Gem bit mode
                        true                     // Print status
                        );

                break;
            }

        default :

            throw _E("Invalid Gem Protocol key: " + std::to_string((int)GEM_PROTOCOL_KEY));
    }

    return b_gem_hide_success;
}


bool HideAGem::GEMMA_RANDOM_write_bit_stream_to_ocean(
        BitStream& bit_stream,
        const EBitMode bit_mode,
        const bool b_print_status
        )
{
    ///
    //    INIT TIME TRAP ( IF APPLICABLE )

    uint64_t time_trap_byte_count = 0;
    init_time_trap_cycle_rate( get_remaining_byte_capacity() );

    ///
    //    GEMMA_RANDOM

    // Stats
    auto stats_start_time = std::chrono::high_resolution_clock::now();

    for (uint64_t gem_bit_index = 0 ; /* <3 */ ; gem_bit_index += bit_mode)
    {
        EXIT_WARDEN(); // E X I T  S I G N A L

        // Get random Ocean byte index using MASTER_KEY
        const OceanIndex ocean_index = get_rand_ocean_byte_index();

        GemByte gem_byte = read_ocean_byte( ocean_index );

        if ( write_bit_stream_to_byte_LSB_MATCHING( gem_byte, gem_bit_index, bit_stream, bit_mode ) )
        {
            ///
            //    WRITE GEM DATA TO OCEAN

            // Write gem data to Ocean
            write_ocean_byte( ocean_index, gem_byte );

            ///
            //    STATUS

            auto stats_stop_time = std::chrono::high_resolution_clock::now();
            std::chrono::duration<double> stats_cooldown_time = stats_stop_time - stats_start_time;

            if ( b_print_status && stats_cooldown_time.count() >= STATUS_PRINT_COOLDOWN_TIME )
            {
                const uint64_t bytes_hidden = gem_bit_index / 8;
                const float percent_hidden = 100 * (bytes_hidden / (float)bit_stream.get_num_bytes());

                PRINT_SAME_LINE_COLOR("GREEN_BRIGHT", "Gem => Ocean :: %s [ %.2f %% ]",
                        bytes_to_size_string( bytes_hidden , 1 /* KB max unit */, false).c_str(), percent_hidden);

                // Reset status print cooldown
                stats_start_time = std::chrono::high_resolution_clock::now();
            }
        }
        else
        {
            break; // Gem hide complete !!!
        }

        ///
        //    GEM HIDE COMPLETE ?

        if ( ! bit_stream.is_valid_index( gem_bit_index + bit_mode ) )
        {
            break; // Gem hide complete !!!
        }

        ///
        //    FEED GEM OCEAN BYTES TO CYCLE KEY

        MASTER_KEY.consume( gem_byte ); // Consume Gem byte

        ///
        //    TIME TRAP

        ++ time_trap_byte_count; // Increment Time Trap byte count

        if ( TIME_TRAP_CYCLE_RATE > 0 ) // Time Trap has been sprung ?
        {
            const bool b_trap_cycle = time_trap_byte_count % TIME_TRAP_CYCLE_RATE == 0;

            if ( b_trap_cycle )
            {
                MASTER_KEY.regenerate(); // Regenerate Cycle Key
            }
        }
    }

    if (b_print_status)
    {
        PRINT_SAME_LINE_COLOR("GREEN_BRIGHT", "Gem => Ocean :: %s [ 100 %% ]",
                bytes_to_size_string( bit_stream.get_num_bytes() , 1 /* KB max unit */, false).c_str() );

        std::cout << std::endl << std::endl;
    }

    return true;
}

///
//    FIND A GEM

uint64_t HideAGem::find_gem_files(
        const std::string& password,
        std::vector<GemFile>& out_gem_files,
        const bool b_time_trap
        )
{
    if (!b_pristine)
    {
        PRINT_ERROR("ERROR: HideAGem instance has already been used.");
        ERROR_CODE = EGemErrorCode::BAD_ARGUMENT;

        return false;
    }
    // Ocean
    else if (!OCEAN.is_valid())
    {
        PRINT_ERROR("ERROR: Ocean is invalid.");
        ERROR_CODE = EGemErrorCode::BAD_ARGUMENT;

        return false;
    }

    HIDE_TERM_CURSOR();
    INIT_SIGNAL_WATCHERS() // Init system signal watchers (e.g. SIGINT)

        ///
        //    TIME

        const auto start_time = std::chrono::high_resolution_clock::now();

    ///
    //    INIT VARIABLES

    b_pristine         = false; // Do not reuse HideAGem instances
    b_lock_ocean_write = true;  // LOCK !!!

    ///
    //    INITIALIZE MASTER KEY

    init_master_key( password );

    ///
    //    FIND GEM SHARDS IN GEM OCEAN

    uint64_t num_gems = 0; // The number of gem files found

    // TRY FIND GEM DATA
    try
    {
        find_gem_files( b_time_trap );

        // Found Gems !!! <3
    }
    catch (const _E& e)
    {
        std::cerr << e.what() << std::endl << std::endl;


        switch ( ERROR_CODE )
        {
            case EGemErrorCode::EXIT_SIGNAL :
            case EGemErrorCode::GEM_STREAM_DECOMPRESSION_ABORTED :

                goto EXIT_GEM_FIND; // User chose to abort Gem Stream decompression

            default :

                goto NO_MAGIC_WORD; // ;D
        }
    }
    catch ( ... )
    {
        std::cerr << "Unknown exception caught!" << std::endl << std::endl;

        goto NO_MAGIC_WORD; // ;D
    }

    ///
    //    PROCESS GEM FILES
    //
    //    At this stage, the gem_files vector has been populated with with decrypted Gem Files.

    switch ( GEM_PROTOCOL_KEY )
    {
        case EGemProtocolKey::GEMMA_RANDOM :
        case EGemProtocolKey::RUBY_TIME_TRAP :
            {
                num_gems = gem_files.size();

                if (num_gems == 0)
                {
                    PRINT("ERROR: Zero Gem Files extracted.");

                    goto EXIT_GEM_FIND;
                }

                uint64_t gem_stream_size = 0;

                for (auto& gem_file : gem_files)
                {
                    // Force unpack, since pack_state == NONE at this stage
                    gem_file.unpack( true /* b_force */ ); // Unpack Gem file
                    gem_stream_size += gem_file.size();
                }

                const std::string gem_stream_size_str = HideAGemCore::bytes_to_size_string( gem_stream_size );
                PRINT("Found and decrypted %llu %s of total size %s: ", num_gems, num_gems > 1 ? "Gems" : "Gem", gem_stream_size_str.c_str());

                bool b_print_gem_file = true;
                uint64_t print_counter = 0;

                // Mitigate potential DOS attack that could freeze terminal with
                // a flood of output (e.g. thousands of lines of Gem Files)
                if ( num_gems > GEM_FILES_PRINT_ASK_THRESHOLD )
                {
                    PRINT_WARNING("Print first %llu Gem Files?\n\nEnter 'no' to extract %llu total Gem Files without printing.", GEM_FILES_PRINT_ASK_THRESHOLD, num_gems);
                    b_print_gem_file = STDIN_YES_OR_NO(); // <-- Blocks thread
                }

                // Process Gem Files
                for (auto& gem_file : gem_files)
                {
                    if (!gem_file.is_valid())
                    {
                        PRINT("Invalid Gem File while processing Gem Stream.");

                        goto EXIT_GEM_FIND;
                    }

                    // Print Gem File info
                    if ( b_print_gem_file )
                    {
                        if ( ++print_counter > GEM_FILES_PRINT_ASK_THRESHOLD )
                        {
                            PRINT_WARNING("Print more Gem Files?\n\nEnter 'no' to extract %llu total Gem Files without more printing.", num_gems);
                            b_print_gem_file = STDIN_YES_OR_NO(); // <-- Blocks thread
                            print_counter = 0;
                        }

                        PRINT_COLOR("CYAN_BRIGHT", " %s \033[97m%llu bytes\033[0m", gem_file.name().c_str(), gem_file.size());
                    }

                    out_gem_files.push_back( std::move(gem_file) ); // Move Gem File
                }

                ///
                //    TIME

                auto stop_time = std::chrono::high_resolution_clock::now();
                std::chrono::duration<double> time_duration = stop_time - start_time;
                const double time_s = time_duration.count();

                if (num_gems == 1)
                {
                    PRINT_SUCCESS("*** FOUND A GEM IN %.2fs ***", time_s); // <3 !!!
                }
                else
                {
                    PRINT_SUCCESS("*** FOUND %llu GEMS IN %.2fs ***", num_gems, time_s); // <3 !!!
                }

                DragonRNG universe_state_rng = MASTER_KEY.copy_RNG( false /* b_cycle */ );
                process_final_RNG_state( universe_state_rng ); // Magic <3 !

                print_gem_hash();

                PRINT_GEM_SEAL(); // <3

                break;
            }

        default :

            PRINT("Invalid Gem Protocol key: %d ", (int)GEM_PROTOCOL_KEY);

            goto EXIT_GEM_FIND;
    }

    goto EXIT_GEM_FIND; // E X I T

NO_MAGIC_WORD: // ;D

    PRINT_ERROR("*** YOU DIDN'T SAY THE MAGIC WORD !!! ***");

    {
        ///
        //    TIME

        auto stop_time = std::chrono::high_resolution_clock::now();
        std::chrono::duration<double> time_duration = stop_time - start_time;
        const double time_s = time_duration.count();

        PRINT_WARNING(">>> ELAPSED TIME: %.2fs <<<", time_s); // <3 !!!
    }

EXIT_GEM_FIND:

    ///
    //    EXIT

    erase_sensitive_data(); // Erase keys and other sensitive data

    SHOW_TERM_CURSOR();

    return num_gems; // E X I T
}


void HideAGem::find_gem_files(const bool b_time_trap)
{
    ///
    //    FISH TIME TRAP FROM OCEAN

    if ( b_time_trap )
    {
        const uint64_t ocean_time_trap   = 7 - read_bit_trap_from_ocean();
        const uint64_t gem_bit_mode_trap = 1 + read_bit_trap_from_ocean();

        ///
        //    INIT TIME TRAP LEVEL

        set_time_trap_level( (int)( ocean_time_trap ) ); // Set Time Trap level

        PRINT_COLOR("MAGENTA", "GEM ENCHANTMENT: LEVEL %llu RUBY TIME TRAP", ocean_time_trap);

        ///
        //    INIT GEM PROTOCOL AND BIT MODE

        init_gem_protocol( EGemProtocolKey::RUBY_TIME_TRAP );

        const uint64_t final_gem_bit_mode = gem_bit_mode_trap > 8 ? 1 : gem_bit_mode_trap;
        GEM_BIT_MODE = static_cast<EBitMode>( final_gem_bit_mode );
    }

    ///
    //    READ GEM PROTOCOL FROM OCEAN

    else
    {
        // Read Gem Header from Ocean and initialize Gem Protocol
        init_gem_protocol( read_gem_header() );

        // Uses prepared MASTER_KEY to extract 1 byte from Ocean in 1-bit mode
        BitCollector bit_collect = GEMMA_RANDOM_extract_gem_bits(
            EBitMode::_1_BIT, // Bits to extract per byte
            1                 // Bytes to extract
        );

        GhostVector<GemByte>& extra_stream = bit_collect.get_bytes();

        if ( extra_stream.size() == 0 ) // Extracted any bytes ?
        {
            throw _E("Failed to extract extra data from Ocean.");
        }

        const uint8_t decrypted_bit_mode = extra_stream[0] ^ SHARED_RNG.rand<uint8_t>();

        if ( decrypted_bit_mode == 0 || decrypted_bit_mode > EBitMode::MAX ) // Valid bit mode ?
        {
            throw _E("Invalid Gem Bit Mode read from Ocean.");
        }

        GEM_BIT_MODE = static_cast<EBitMode>( decrypted_bit_mode );
    }

    ///
    //    READ GEM STREAM FROM OCEAN

    switch ( GEM_PROTOCOL_KEY )
    {
        case EGemProtocolKey::GEMMA_RANDOM :
        {
            ///
            //    READ GEM STREAM FROM OCEAN

            PRINT("Ocean Read Mode: GEMMA_%dR :: %d-BIT RANDOM", GEM_BIT_MODE, GEM_BIT_MODE);

            // Uses prepared MASTER_KEY to extract from Ocean
            BitCollector bit_collect = GEMMA_RANDOM_extract_gem_bits(
                GEM_BIT_MODE, // Gem bits per Ocean byte
                0,            // No max bytes to read
                true          // Print status
            );

            GhostVector<GemByte>& gem_stream = bit_collect.get_bytes();

            process_extracted_gem_stream( gem_stream );

            break;
        }

        case EGemProtocolKey::RUBY_TIME_TRAP :
        {
            ///
            //    READ GEM STREAM FROM OCEAN

            PRINT("Ocean Read Mode: GEMMA_%dR :: %d-BIT RANDOM", GEM_BIT_MODE, GEM_BIT_MODE);

            // Uses prepared MASTER_KEY to extract from Ocean
            BitCollector bit_collect = GEMMA_RANDOM_extract_gem_bits_TIME_TRAP(
                GEM_BIT_MODE // Gem bits per Ocean byte
            );

            GhostVector<GemByte>& gem_stream = bit_collect.get_bytes();

            process_extracted_gem_stream( gem_stream );

            break;
        }

        default :

            throw _E("Find Gem Files :: Invalid Gem Protocol key: " + std::to_string((int)GEM_PROTOCOL_KEY));
    }
}


void HideAGem::process_extracted_gem_stream(GhostVector<GemByte>& gem_stream)
{
    if ( gem_stream.empty() )
    {
        throw _E("Tried to process empty Gem Stream.");
    }

    ///
    //    VALIDATE PROTOCOL SUPPORT FOR PROCEDURE

    switch ( GEM_PROTOCOL_KEY )
    {
        case EGemProtocolKey::GEMMA_RANDOM :
        case EGemProtocolKey::RUBY_TIME_TRAP :

            break;

        default :

            throw _E("Process Gem Stream :: Invalid Gem Protocol key: " + std::to_string((int)GEM_PROTOCOL_KEY));
    }

    ///
    //    EXTRACT AND DECRYPT GEM STREAM NONCE

    GhostVector<uint8_t> gem_nonce;
    gem_nonce.reserve( GEM_STREAM_NONCE_SIZE );

    const size_t nonce_offset = gem_stream.size() - GEM_STREAM_NONCE_SIZE;

    for (size_t i = nonce_offset; i < gem_stream.size(); ++i)
    {
        gem_nonce.push_back( gem_stream[i] ^ SHARED_RNG.rand_byte() );
    }

    ///
    //    DECRYPT AND DECOMPRESS GEM !!!

    // Remove nonce bytes
    uint64_t gem_stream_size = gem_stream.size() - GEM_STREAM_NONCE_SIZE;

    GhostVector<GemByte> decrypted_gem_stream( gem_stream_size );

    unsigned long long decrypted_len;

    // Decrypt gem using MASTER_KEY
    const auto _err = crypto_aead_xchacha20poly1305_ietf_decrypt(
        decrypted_gem_stream.data(),
        &decrypted_len,
        nullptr, // No nsec (not used in libsodium's current API)
        gem_stream.data(),
        gem_stream_size,
        nullptr,
        0, // No additional data
        reinterpret_cast<const unsigned char*>(gem_nonce.data()),
        reinterpret_cast<const unsigned char*>(GEM_STREAM_ENCRYPT_KEY.data())
    );

    GEM_STREAM_ENCRYPT_KEY.vanish(); // Secure erase

    // Speak friend and enter ...

    if (_err != 0)
    {
        // Ah ah ah! You didn't say the magic word! ... ;D

        throw _E("Gem Stream decryption failed.");
    }

    ///
    //    !!! FOUND GEM <3 !!!
    ///

    // Read first 8 bytes as uint64_t decompression size target
    uint64_t target_size = 0;
    uint8_t* size_address = decrypted_gem_stream.data() + decrypted_len - sizeof( target_size );
    std::memcpy( &target_size, size_address, sizeof( target_size ) );

    // Advance gem file stream pointer
    GemByte* to_decompress = decrypted_gem_stream.data();
    const uint64_t to_decompress_size = decrypted_len - MINIZ_TAIL_SIZE;

    // Decompressed Gem File Stream poiner and size
    GemByte* gem_file_stream      = decrypted_gem_stream.data();
    uint64_t gem_file_stream_size = decrypted_len - MINIZ_TAIL_SIZE;

    ///
    //    MINIZ UNCOMPRESS

    GhostVector<GemByte> u_gem_stream;

    if ( target_size > 0 ) // Compressed ?
    {
        ///
        //    !!! BOMB PATROL !!!
        //
        //    DECOMPRESSION BOMB MITIGATION

        //    TODO pause Gem extraction timer

        if ( target_size > TEMPORARY_MAX_GEM_SIZE )
        {
            throw _E("Max extraction size exceeded (temporary limit for alpha testing phase).");
        }
        else if ( target_size > BOMB_PATROL_THRESHOLD )
        {
            PRINT_WARNING("WARNING: A Gem Stream of size %.2f MB is being decompressed. Do you wish to proceed?",
                target_size / 1024.f / 1024.f // Last uncompress target size
            );

            if ( STDIN_YES_OR_NO() ) // <-- Blocks thread
            {
                PRINT("Continuing Gem Stream decompression.");
            }
            else
            {
                ERROR_CODE = EGemErrorCode::GEM_STREAM_DECOMPRESSION_ABORTED;

                throw _E("Gem Stream decompression aborted.");
            }
        }

        uint64_t decompressed_size = target_size;
        u_gem_stream = GhostVector<uint8_t>( target_size );

        // Decompress
        HideAGemCore::miniz_decompress( to_decompress, to_decompress_size, u_gem_stream.data(), &decompressed_size );

        gem_file_stream      = u_gem_stream.data();
        gem_file_stream_size = decompressed_size;
    }

    ///
    //    PROCESS GEM FILES

    const size_t end_idx = gem_file_stream_size - 1;

    size_t stream_idx = 0;
    size_t file_idx = 0;
    GemSize gem_file_size = 0;
    GemByte* gem_file = nullptr;

    for (;;) // crab loop UwU (looks like a little hermit crab!)
    {
        if ( stream_idx > end_idx )
        {
            break; // Done !
        }

        if ( file_idx >= gem_file_size )
        {
            if ( stream_idx + sizeof(gem_file_size) > end_idx )
            {
                throw _E("Unexpected end of Gem Stream."); // Error !
            }

            std::memcpy( &gem_file_size, &gem_file_stream[ stream_idx ], sizeof(gem_file_size) );
            stream_idx += sizeof(gem_file_size);

            if ( gem_file != nullptr )
            {
                gem_files.back().lock(); // Lock Gem File
            }

            file_idx = 0;
            gem_files.push_back( GemFile( gem_file_size ) );
            gem_file = gem_files.back().data();
        }

        gem_file[ file_idx ] = gem_file_stream[ stream_idx ];

        ++file_idx;
        ++stream_idx;
    }

    if ( gem_file != nullptr )
    {
        gem_files.back().lock(); // Lock Gem File
    }

    ///
    //    VALIDATE

    if ( gem_files.empty() )
    {
        throw _E("Zero Gem Files extracted from Gem Stream.");
    }
}


BitCollector HideAGem::GEMMA_RANDOM_extract_gem_bits(
    const EBitMode bit_mode,
    const uint64_t max_bytes,
    const bool b_print_status
)
{
    ///
    //    GEMMA_RANDOM

    GemSize search_byte_count = 0;
    GemSize byte_capacity = static_cast<GemSize>( get_remaining_byte_capacity() );

    BitCollector bit_collect; // BIT COLLECTOR

    // Stats
    auto stats_start_time = std::chrono::high_resolution_clock::now();

    while ( true /* love !!! */ )
    {
        EXIT_WARDEN(); // E X I T  S I G N A L

        ///
        //    FISH BYTE FROM OCEAN

        const uint64_t last_num_bytes_collected = bit_collect.get_num_bytes();

        // Get random Ocean byte index using MASTER_KEY
        const OceanIndex ocean_index = get_rand_ocean_byte_index();

        GemByte gem_byte = read_ocean_byte( ocean_index );

        // Collect bytes by reading gem chips into bit_collect
        bit_collect.add_bits( gem_byte, bit_mode );

        ///
        //    COLLECT GEM STREAM BYTES

        while ( bit_collect.collect_new_byte() ) // May have collected > 1 byte
        {
            // Maybe done extracting bytes
            if ( max_bytes > 0 && bit_collect.get_num_bytes() >= max_bytes )
            {
                goto extraction_complete; // Done !
            }

            ///
            //    PROCESS GEM STREAM

            // Collect and decrypt Gem Stream bytes
            if ( bit_collect.get_num_bytes() == search_byte_count )
            {
                // Update byte_capacity
                byte_capacity = static_cast<GemSize>( get_remaining_byte_capacity() );

                // TODO Handle case of valid Gem Stream Shards decrypted before
                //      an invalid Gem Stream ends the extraction.
                //      ( Output the found Gem Files ? )

                goto extraction_complete; // Done !
            }
            // Get next search byte count
            else if ( search_byte_count == 0 && bit_collect.get_num_bytes() == GEM_FILE_HEAD_SIZE )
            {
                bit_collect.get_bytes().read_bytes( search_byte_count, 0 );

                search_byte_count = decrypt_gem_stream_byte_count(
                    search_byte_count, byte_capacity );

                bit_collect.clear_collected_bytes(); // Empty collected bytes

                // If search byte count exceeds remaining capacity, it is invalid
                if ( search_byte_count > byte_capacity )
                {
                    throw _E("Gem Stream size exceeds maximum Ocean capacity.");
                }
            }
        }

        ///
        //    FEED GEM OCEAN BYTES TO CYCLE KEY

        MASTER_KEY.consume( gem_byte ); // Consume Gem byte
        
        ///
        //    STATS

        if ( b_print_status )
        {
            auto stats_stop_time = std::chrono::high_resolution_clock::now();
            std::chrono::duration<double> stats_cooldown_time = stats_stop_time - stats_start_time;

            if ( search_byte_count > 0 && stats_cooldown_time.count() >= STATUS_PRINT_COOLDOWN_TIME )
            {
                const size_t num_bytes = bit_collect.get_num_bytes();
                const float percent_read = 100 * (num_bytes / (float)search_byte_count);

                const std::string progress_str = bytes_to_size_string( num_bytes) + " / " +
                    bytes_to_size_string( search_byte_count );

                PRINT_SAME_LINE_COLOR("GREEN_BRIGHT", "Reading Gem Stream :: %s [ %.2f %% ]",
                    progress_str.c_str(), percent_read);

                // Reset status print cooldown
                stats_start_time = std::chrono::high_resolution_clock::now();
            }
        }
    }

extraction_complete:

    if ( b_print_status )
    {
        const size_t num_bytes = bit_collect.get_num_bytes();
        const std::string progress_str = bytes_to_size_string( num_bytes) + " / " +
            bytes_to_size_string( search_byte_count );

        PRINT_SAME_LINE_COLOR("GREEN_BRIGHT", "Reading Gem Stream :: %s [ 100 %% ]", progress_str.c_str());
        std::cout << std::endl << std::endl;
    }

    return bit_collect;
}


BitCollector HideAGem::GEMMA_RANDOM_extract_gem_bits_TIME_TRAP(
    const EBitMode bit_mode,
    const uint64_t max_bytes
)
{
    ///
    //    INIT TIME TRAP ( IF APPLICABLE )

    uint64_t time_trap_byte_count = 0;
    init_time_trap_cycle_rate( get_remaining_byte_capacity() );

    ///
    //    GEMMA_RANDOM

    BitCollector bit_collect; // BIT COLLECTOR

    uint8_t stop_key_idx = 0;
    uint8_t stop_key_bytes_collected = 0;
    std::vector<GemByte> STOP_KEY( READ_STOP_BYTE_COUNT );

    for (int i = 0; i < READ_STOP_BYTE_COUNT; ++i)
    {
        STOP_KEY[i] = READ_STOP_BYTES_ENCRYPT_RNG.rand<GemByte>();
    }

    ///
    //    STATS

    double max_time = 0;
    uint64_t stats_samples = 0;
    double avg_sample_time = 0;
    uint64_t start_capacity = get_remaining_byte_capacity();

    auto max_time_start = std::chrono::high_resolution_clock::now();
    auto stats_start_time = std::chrono::high_resolution_clock::now();

    while ( true /* love !!! */ )
    {
        EXIT_WARDEN(); // E X I T  S I G N A L

        ///
        //    FISH BYTE FROM OCEAN

        const uint64_t last_num_bytes_collected = bit_collect.get_num_bytes();

        // Get random Ocean byte index using MASTER_KEY
        const OceanIndex ocean_index = get_rand_ocean_byte_index();

        GemByte gem_byte = read_ocean_byte( ocean_index );

        // Collect bytes by reading gem chips into bit_collect
        bit_collect.add_bits( gem_byte, bit_mode );

        ///
        //    COLLECT GEM STREAM BYTES

        while ( bit_collect.collect_new_byte() ) // May have collected > 1 byte
        {
            // Maybe done extracting bytes
            if ( max_bytes > 0 && bit_collect.get_num_bytes() >= max_bytes )
            {
                goto extraction_complete; // Done !
            }

            GhostVector<uint8_t>& gem_stream = bit_collect.get_bytes();

            // Try to decrypt last collected byte as stop value
            const bool b_stop_byte =
                (gem_stream.back() ^ STOP_KEY[ stop_key_idx ]) == READ_STOP_BYTE_VALUE;

            if ( b_stop_byte )
            {
                ++stop_key_idx; // Increment stop key index

                if ( stop_key_idx == READ_STOP_BYTE_COUNT )
                {
                    // Pop stop bytes from end of Gem Stream
                    for (int i = 0; i < READ_STOP_BYTE_COUNT; ++i)
                    {
                        gem_stream.pop_back();
                    }

                    goto extraction_complete; // Done !
                }
            }
            else
            {
                stop_key_idx = 0; // Reset stop byte key index
            }
            
            ///
            //    STATS

            auto stats_stop_time = std::chrono::high_resolution_clock::now();
            std::chrono::duration<double> cooldown_time = stats_stop_time - stats_start_time;

            if ( cooldown_time.count() >= STATUS_PRINT_COOLDOWN_TIME )
            {
                ///
                //    MAX TIME REMAINING

                cooldown_time = stats_stop_time - max_time_start;

                if ( cooldown_time.count() >= 1 )
                {
                    ++ stats_samples;

                    const double sample_alpha = 1.0 / stats_samples;
                    const uint64_t current_capacity = get_remaining_byte_capacity();
                    const uint64_t bytes_per_sample = (start_capacity - current_capacity) / stats_samples;

                    avg_sample_time = sample_alpha * cooldown_time.count() + ( 1 - sample_alpha ) * avg_sample_time;

                    const double next_max_time = ( current_capacity / bytes_per_sample ) * avg_sample_time;

                    // Only update max time if it's at the beginning or it has decreased
                    max_time = sample_alpha > 0.1 || ( max_time > next_max_time ) ? next_max_time : max_time;

                    max_time = max_time == 0 && stats_samples > 1 ? 1 : max_time;

                    // Reset time print cooldown
                    max_time_start = std::chrono::high_resolution_clock::now();
                }

                ///
                //    PRINT PROGRESS

                const size_t num_bytes = bit_collect.get_num_bytes();
                const std::string progress_str = bytes_to_size_string( num_bytes, 1 /* max unit KB */ );

                if ( max_time > 0 )
                {
                    PRINT_SAME_LINE_COLOR("GREEN_BRIGHT", "Ocean => Gem :: %s ~ %.0fs Remaining", progress_str.c_str(), max_time );
                }
                else
                {
                    PRINT_SAME_LINE_COLOR("GREEN_BRIGHT", "Ocean => Gem :: %s", progress_str.c_str());
                }

                // Reset status print cooldown
                stats_start_time = std::chrono::high_resolution_clock::now();
            }
        }

        ///
        //    FEED GEM OCEAN BYTES TO CYCLE KEY

        MASTER_KEY.consume( gem_byte ); // Consume Gem byte

        ///
        //    TIME TRAP

        ++ time_trap_byte_count; // Increment Time Trap byte count

        if ( TIME_TRAP_CYCLE_RATE > 0 && time_trap_byte_count % TIME_TRAP_CYCLE_RATE == 0 )
        {
            MASTER_KEY.regenerate(); // Regenerate Cycle Key
        }
    }

extraction_complete:

    const size_t num_bytes = bit_collect.get_num_bytes();
    const std::string progress_str = bytes_to_size_string( num_bytes, 1 /* max unit KB */ );
    PRINT_SAME_LINE_COLOR("GREEN_BRIGHT", "Ocean => Gem :: %s", progress_str.c_str() );

    printf("\n\n");

    return bit_collect;
}

///
//    WRITE GEM DATA TO OCEAN

// Writes data to cahnnel using LSB matching
GemByte HideAGem::write_bits_to_byte_LSB_MATCHING(
    const GemByte byte,
    const GemByte data,
    const uint8_t num_LSB
) const
{
    if (num_LSB == 0)
    {
        return byte;
    }
    else if (num_LSB >= 8) // Replacing entire byte
    {
        return data;
    }

    GemByte byte_LSB = byte & ((1 << num_LSB) - 1);
    GemByte data_LSB = data & ((1 << num_LSB) - 1);

    if (byte_LSB == data_LSB)
    {
        return byte;
    }

    ///
    //    WRITE DATA TO BYTE WITH LSB MATCHING

    // TODO threadsafe data whitening
    //  (remove _DATA_WHITEN below if you need thread safety)
    DragonRNG& _DATA_WHITEN = const_cast<DragonRNG&>( DATA_WHITEN_RNG );

    // Max that could be added or subtracted
    const uint8_t max_val     = 1 << num_LSB;
    const uint8_t max_val_and = max_val - 1;

    const int diff = data_LSB - byte_LSB;

    for (int i = 1; i < max_val; ++i)
    {
        // Randomize adding / subtracting.
        // XOR with data whitening stream in order to mitigate potential
        // compromise or malfunction of system randomness sources.
        const bool b_add_first = TRUE_RANDOM::rand_bool() ^ _DATA_WHITEN.rand_bool();

        const int c1 = b_add_first ? byte + i : byte - i;

        if (c1 >= 0 && c1 <= 255 && (c1 & max_val_and) == data_LSB)
        {
            return c1;
        }

        const int c2 = b_add_first ? byte - i : byte + i;

        if (c2 >= 0 && c2 <= 255 && (c2 & max_val_and) == data_LSB)
        {
            return c2;
        }
    }

    throw _E("Write bits to byte LSBs failed.");

    return byte;
}


bool HideAGem::write_bit_stream_to_byte_LSB_MATCHING(
    GemByte& byte,
    GemBitIndex bit_index,
    const BitStream& bit_stream,
    const EBitMode bit_mode
) const
{
    if (!bit_stream.is_valid_index(bit_index))
    {
        return false;
    }
    else if (bit_mode == EBitMode::NONE)
    {
        throw _E("Tried to write Bit Stream to byte using NONE Bit Mode.");
    }

    GemByte gem_chip = 0;

    uint8_t num_bits = static_cast<uint8_t>( bit_mode );

    // Number of least significant bits (LSBs) to extract/write
    const uint8_t LSB_extract = static_cast<uint8_t>( std::pow( 2, num_bits ) ) - 1;

    // Extract LSBs from byte (they will be copied if not overwritten)
    gem_chip = byte & LSB_extract;

    // Write Gem bits to Gem chip
    while ( num_bits > 0 )
    {
        if ( bit_stream.get_bits( gem_chip, num_bits, bit_index ) )
        {
            break;
        }

        --num_bits;
    }

    // Write the Gem chip to the byte
    byte = write_bits_to_byte_LSB_MATCHING( byte, gem_chip, num_bits );

    return true;
}

///
//    READ / WRITE OCEAN BYTES

GemByte HideAGem::read_ocean_byte(const OceanIndex ocean_index) const
{
    if ( ocean_index > max_ocean_index )
    {
        throw  _E("Tried to read byte outside of Ocean bounds!");
    }

    return OCEAN[ ocean_index ];
}


void HideAGem::write_ocean_byte(const OceanIndex ocean_index, const GemByte& byte)
{
    if (b_lock_ocean_write)
    {
        return;
    }
    else if (ocean_index > max_ocean_index)
    {
        throw  _E("Tried to write outside of Ocean bounds!");
    }

    OCEAN[ ocean_index ] = byte;
}

///
//    BIT TRAP

void HideAGem::write_bit_trap_to_ocean(const uint64_t trap_val)
{
    if ( trap_val > 7 )
    {
        throw _E("Bit Traps larger than 1 byte not yet supported."); // TODO
    }
    else if ( GEM_BIT_MODE == EBitMode::NONE )
    {
        throw _E("Tried to write Bit Trap with NONE Gem Bit Mode.");
    }

    ///
    //    WRITE BIT TRAP TO OCEAN
    //
    //    Writes only as many bits needed to fit trap_val.

    uint64_t bit_index = 0;

    do
    {
        EXIT_WARDEN(); // E X I T  S I G N A L

        ///
        //    CREATE TRAP BYTE

        // Get random Ocean byte index using MASTER_KEY
        const OceanIndex ocean_index = get_rand_ocean_byte_index();

        // Read ocean 
        uint8_t ocean_byte = read_ocean_byte( ocean_index );

        // Set trap bit in ocean byte
        const uint8_t trap_byte = (bit_index == trap_val) ? (ocean_byte | 1) : (ocean_byte & ~1);

        // XOR encrypt trap byte with Master Key
        const uint8_t trap_byte_x = trap_byte ^ ( MASTER_KEY.rand<uint8_t>() & 1 );

        // Write encrypted trap bits to Ocean byte
        ocean_byte = write_bits_to_byte_LSB_MATCHING(
            ocean_byte,      // Ocean byte
            trap_byte_x,     // Trap bits
            EBitMode::_1_BIT // Num LSBs to write
        );

        ///
        //    WRITE TRAP BYTE TO OCEAN

        write_ocean_byte( ocean_index, ocean_byte );

        ///
        //    FEED GEM OCEAN BYTES TO CYCLE KEY

        MASTER_KEY.consume( ocean_byte ); // Consume Gem byte

        // NOTE: Does not regenerate MASTER_KEY
    }
    while ( ++bit_index <= trap_val );
}


uint64_t HideAGem::read_bit_trap_from_ocean()
{
    const uint64_t MAX_BIT_TRAP_INDEX = 7;

    for (uint64_t bit_index = 0; bit_index <= MAX_BIT_TRAP_INDEX; ++bit_index)
    {
        EXIT_WARDEN(); // E X I T  S I G N A L

        // Get random Ocean byte index using MASTER_KEY
        const OceanIndex ocean_index = get_rand_ocean_byte_index();

        GemByte trap_byte = read_ocean_byte( ocean_index );

        // NOTE: Does not regenerate MASTER_KEY

        const bool b_sprung_trap =
            (((trap_byte & 1) ^ (MASTER_KEY.rand<uint8_t>() & 1)) == 1);

        ///
        //    FEED GEM OCEAN BYTES TO CYCLE KEY

        MASTER_KEY.consume( trap_byte ); // Consume Gem byte

        if ( b_sprung_trap )
        {
            ///
            //    SPRUNG BIT TRAP !!!

            return bit_index; // Bit Trap index
        }
    }

    return MAX_BIT_TRAP_INDEX; // No trap sprung is last index
}

///
//    TIME TRAP

void HideAGem::set_time_trap_level( const int time_trap )
{
    TIME_TRAP_LEVEL = static_cast<ETimeTrapLevel>( time_trap );
}


void HideAGem::init_time_trap_cycle_rate(const uint64_t num_bytes)
{
    if ( TIME_TRAP_LEVEL == ETimeTrapLevel::NONE || TIME_TRAP_LEVEL == ETimeTrapLevel::ZERO )
    {
        TIME_TRAP_CYCLE_RATE = 0;

        return; // No Time Trap
    }
    else if ( num_bytes == 0 ) // Not enough bytes to cycle
    {
        TIME_TRAP_CYCLE_RATE = 0;

        return;
    }

    const int time_trap = static_cast<int>( TIME_TRAP_LEVEL );

    ///
    //    TIME TRAP TYPE

    switch ( GEM_PROTOCOL_KEY )
    {
        case EGemProtocolKey::RUBY_TIME_TRAP :
        {
            ///
            //    LEVEL 7 = Max cycle rate, and levels below it are a fraction of max e.g. 1/7

            const int max_level = static_cast<int>( ETimeTrapLevel::MAX );

            TIME_TRAP_CYCLE_RATE = static_cast<uint64_t>(
                RUBY_TIME_TRAP_MAX_CYCLE_RATE * ( max_level / (double)time_trap )
            );

            break;
        }

        default:

            throw _E("Tried to initialize Time Trap cyle rate with invalid Gem Protocol.");
    }
}

///
//    RANDOM

void HideAGem::process_final_RNG_state(DragonRNG& rng)
{
    //
    //    *** PERMANENT RNG USE ORDER ***
    //

    // Unique 256-bit web-safe basea64 hash
    gen_gem_hash( rng.rand_seed() );

    // Charming Gem legend <3 !
    READ_GEM_SEAL( rng.rand_seed() );
}

///
//    GEM HASH

void HideAGem::print_gem_hash() const
{
    if ( b_print_gem_hash )
    {
        PRINT_NO_NEWLINE("GEM HASH: %s\n", GEM_HASH.c_str());
    }
}


void HideAGem::gen_gem_hash(const DragonRNG::RNGSeed& seed)
{
    const auto _seed = seed; // Copy to use constexpr size() below

    constexpr size_t b64_maxlen = sodium_base64_ENCODED_LEN(
        _seed.size(),
        sodium_base64_VARIANT_URLSAFE_NO_PADDING
    );
    
    char encoded[b64_maxlen];

    sodium_bin2base64(
        encoded,
        b64_maxlen,
        seed.data(),
        seed.size(),
        sodium_base64_VARIANT_URLSAFE_NO_PADDING
    );

    GEM_HASH = std::string(encoded);
}

///
//    GEM SEAL

void HideAGem::PRINT_GEM_SEAL() const
{
    if ( b_print_gem_seal )
    {
        std::cout << GEM_SEAL << "\n\n";
    }
}


void HideAGem::READ_GEM_SEAL(const DragonRNG::RNGSeed& seed)
{
    //  Set me as a seal upon your heart,
    //  as a seal upon your arm,
    //  
    //  for love is strong as death,
    //  jealousy is fierce as the grave.
    //  
    //  Its flashes are flashes of fire,
    //  the very flame of the LORD.
    //  
    //  Many waters cannot quench love,
    //  neither can floods drown it.
    //  
    //  If a man offered for love
    //  all the wealth of his house,
    //  he would be utterly despised.

    const std::array<std::string, 12> ZODIACS =
    {
        "ARIES"       ,
        "TAURUS"      ,
        "GEMINI"      ,
        "CANCER"      ,
        "LEO"         ,
        "VIRGO"       ,
        "LIBRA"       ,
        "SCORPIO"     ,
        "SAGITTARIUS" ,
        "CAPRICORN"   ,
        "AQUARIUS"    ,
        "PISCES"      ,
    };

    ///
    //    WARD

    const std::map<std::string, std::vector<std::string>> GEM_WARDS_MAP =
    {
        { "FIRE", {

            // ALCHEMICAL
            "SALAMANDER'S",

            // ANCIENT
            "DRAGON'S",
            "GIANT'S",

            // ANIMAL
            "LION'S",
            "SCARAB'S",

            // BIBLICAL
            "CHERUBIM'S",
            "SERAPHIM'S",

            // CLASS
            "ALCHEMIST'S",
            "JUDGE'S",
            "KING'S",
            "KNIGHT'S",
            "PRIEST'S",
            "PREACHER'S",
            "PROPHET'S",

            // EGYPTIAN
            "RA'S",
            "SEKHMET'S",

            // GREEK
            "APOLLO'S",  // LEO
            "ARES'",     // ARIES
            "CHIMERA'S",
            "CYCLOPS'",
            "HYDRA'S",
            "PHOENIX'S",
            "ZEUS'",     // SAGITTARIUS

            // PLANT
            "NETTLES'",

            // ROMAN
            //"APOLLO'S" // LEO [ DUPLICATE ]
            "JUPITER'S", // SAGITTARIUS
            "MARS'",     // ARIES

        }},

        { "EARTH", {

            // ALCHEMICAL
            "GNOME'S",

            // ANCIENT
            "CENTAUR'S",
            "DWARF'S",
            "GOBLIN'S",
            "KOBOLD'S",
            "TROLL'S",

            // ANIMAL
            "CICADA'S", // 3301
            "TOAD'S",

            // BIBLICAL
            "BEHEMOTH'S",

            // CLASS
            "GUARDIAN'S",
            "HERMIT'S",
            "MAIDEN'S",
            "QUEEN'S",

            // EGYPTIAN
            "BASTET'S",
            "HATHOR'S",

            // GREEK
            "APHRODITE'S", // TAURUS / LIBRA
            "ARTEMIS'",    // VIRGO
            "DRYAD'S",
            "HEPHAESTUS'", // VIRGO
            "HERMES'",     // GEMINI / VIRGO
            "HESTIA'S",    // VIRGO
            "MINOTAUR'S",
            "TITAN'S",

            // PLANT
            "MANDRAKE'S",

            // ROMAN
            "DIANA'S",   // VIRGO
            "MERCURY'S", // GEMINI / VIRGO
            "VENUS'",    // TAURUS / LIBRA
            "VESTA'S",   // VIRGO
            "VULCAN'S",  // VIRGO
        }},

        { "AIR", {

            // ALCHEMICAL
            "SYLPH'S",

            // ANCIENT
            "ELVES'",
            "FAERY'S",
            "PIXIE'S",
            "SPRITE'S",
            "UNICORN'S",

            // ANIMAL
            "MAGPIE'S",
            "SONGBIRD'S",

            // BIBLICAL
            "ARCHANGEL'S",

            // CLASS
            "MAGICIAN'S",
            "MONK'S",
            "PHILOSOPHER'S",
            "POET'S",
            "TWINS'",

            // EGYPTIAN
            "HORUS'",
            "MAAT'S",

            // GREEK
            "APHRODITE'S", // TAURUS / LIBRA
            "ATHENA'S",    // LIBRA
            "GRIFFIN'S",
            "HARPY'S",
            "HERMES'",     // GEMINI / VIRGO
            "PEGASUS'",

            // PLANT
            "ROSE'S",

            // ROMAN
            "MERCURY'S", // GEMINI / VIRGO
            "MINERVA'S", // LIBRA
            "VENUS'",    // TAURUS / LIBRA
        }},

        { "WATER", {

            // ANIMAL
            "CHAMELEON'S",
            "DOLPHIN'S",
            "FROG'S",
            "SERPENT'S",
            "WHALE'S",
            "WOLF'S",

            // ALCHEMICAL
            "UNDINE'S",

            // ANCIENT
            "BASILISK'S",
            "DEATH'S",
            "MANTICORE'S",
            "PHANTOM'S",
            "VAMPIRE'S",
            "WEREWOLF'S",
            "WILL-O-THE-WISP'S",

            // BIBLICAL
            "LEVIATHAN'S",
            "NEPHILIM'S",

            // CLASS
            "BANDIT'S",
            "BARD'S",
            "MINSTREL'S",
            "MYSTIC'S",
            "ORACLE'S",
            "THIEF'S",

            // EGYPTIAN
            "ANUBIS'",
            "KHONSU'S",
            "OSIRIS'",
            "THOTH'S",

            // GREEK
            "DOLOS'",
            "HADES'",     // SCORPIO
            "HERA'S",     // CANCER
            "MEDUSA'S",
            "MERMAID'S",
            "NYMPH'S",
            "POSEIDON'S", // PISCES
            "SATYR'S",
            "SIREN'S",
            "SPHINX'S",

            // PLANT
            "LOTUS'",
            "NIGHTSHADE'S",

            // ROMAN
            "JUNO'S",    // CANCER
            "NEPTUNE'S", // PISCES
            "PLUTO'S",   // SCORPIO
        }},
    };

    ///
    //    QUALITY

    const std::vector<std::string> GEM_QUALITIES =
    {
        "ASTRAL"        ,
        "BLESSED"       ,
        "CELESTIAL"     ,
        "CHARMED"       ,
        "COSMIC"        ,
        "CYCLONE"       ,
        "DISAPPEARING"  ,
        "DREAMING"      ,
        "ECLIPSE"       ,
        "ELEMENTAL"     ,
        "ENIGMATIC"     ,
        "ENLIGHTENING"  ,
        "ETERNAL"       ,
        "ETHERIC"       ,
        "FLAWLESS"      ,
        "FORBIDDEN"     ,
        "GATEWAY"       ,
        "GHOSTLY"       ,
        "GLOWING"       ,
        "HOLY"          ,
        "ILLUMINATING"  ,
        "ILLUSORY"      ,
        "IMMACULATE"    ,
        "IMMORTAL"      ,
        "INCANDESCENT"  ,
        "INVISIBLE"     ,
        "IRIDESCENT"    ,
        "LEVITATING"    ,
        "LIQUID"        ,
        "LUCKY"         ,
        "LUSTROUS"      ,
        "MAELSTROM"     ,
        "HUMMING"       ,
        "METEORIC"      ,
        "MUTATING"      ,
        "MYSTICAL"      ,
        "NEBULOUS"      ,
        "OUROBOROS"     ,
        "PHASING"       ,
        "PHOSPHORESCENT",
        "PORTAL"        ,
        "PRISTINE"      ,
        "PROTECTIVE"    ,
        "PSYCHIC"       ,
        "RADIANT"       ,
        "ROYAL"         ,
        "SERPENTINE"    ,
        "SHADOW"        ,
        "SHIMMERING"    ,
        "SINGING"       ,
        "SLEEPING"      ,
        "SOOTHING"      ,
        "SPARKLING"     ,
        "SPECTRAL"      ,
        "TELEPORTING"   ,
        "TEMPEST"       ,
        "TRANSLUCENT"   ,
        "VAPOROUS"      ,
        "VIBRATING"     ,
        "WARDING"       ,
    };

    ///
    //    MAGIC

    const std::map<std::string, std::vector<std::string>> GEM_MAGIC_MAP =
    {
        { "FIRE", {  // 17

            "BURNING",
            "CLEANSING",
            "FIGHTING",
            "IGNITING",
            "IMMORTALITY",
            "JUDGING",
            "LIFE",
            "POWER",
            "PROPHESYING",
            "RENEWING",
            "RESURRECTING",
            "REVEALING",
            "RULING",
            "TEMPERING",
            "TRANSMUTING",
            "VENGEANCE",
            "WAR",
        }},

        { "EARTH", {  // 19

            "BINDING",
            "BLOCKING",
            "CRAFTING",
            "DIGGING",
            "ENDURANCE",
            "FRUITING",
            "GROWING",
            "GUARDING",
            "HIDING",
            "HUNTING",
            "INVINCIBILITY",
            "MULTIPLYING",
            "PERSUADING",
            "PROTECTING",
            "RESISTING",
            "SMITHING",
            "STABILITY",
            "STRENGTH",
            "TEMPTING",
        }},

        { "AIR", {  // 20

            "BALANCE",
            "BLESSING",
            "CLARIFYING",
            "CONJURING",
            "DISAPPEARING",
            "DUPLICATING",
            "ENCHANTING",
            "ENLIGHTENING",
            "FLYING",
            "INSIGHT",
            "INVISIBILITY",
            "LIGHTNESS",
            "MEDITATING",
            "PROTECTING",
            "RUMINATING",
            "SINGING",
            "SUBLIMATING",
            "TELEPORTING",
            "TRANQUILITY",
            "VANISHING",
            "WARDING",
        }},

        { "WATER", {  // 23

            "CHARMING",
            "CLEANSING",
            "CONCEALING",
            "CONFUSING",
            "CUNNING",
            "DISSOLVING",
            "DIVINING",
            "ERODING",
            "FLOODING",
            "HEALING",
            "LURING",
            "MUTATING",
            "PHASING",
            "REFLECTING",
            "REGENERATING",
            "RENEWING",
            "ROMANCING",
            "SEDUCING",
            "SHAPESHIFTING",
            "SPYING",
            "TIMESHIFTING",
            "TIMESTOPPING",
            "TRANSFORMING",
        }},
    };

    ///
    //    GEM TYPE

    constexpr static size_t NUM_GEM_TYPES = 4;

    const std::map<std::string, std::array<std::string, NUM_GEM_TYPES>> GEM_MAP =
    {
        // ZODIAC            EXODUS        VEDIC               REVELATION      TROPICAL
                                                                           
        { "ARIES"       , { "DIAMOND"   , "RED CORAL"       , "SARDIUS"     , "BLOODSTONE"   }, },
        { "TAURUS"      , { "EMERALD"   , "OPAL"            , "CHRYSOPRASE" , "ROSE QUARTZ"  }, },
        { "GEMINI"      , { "AGATE"     , "EMERALD"         , "CHALCEDONY"  , "CITRINE"      }, },
        { "CANCER"      , { "RUBY"      , "PEARL"           , "EMERALD"     , "MOONSTONE"    }, },
        { "LEO"         , { "ONYX"      , "RUBY"            , "JASPER"      , "SUNSTONE"     }, },
        { "VIRGO"       , { "JASPER"    , "EMERALD"         , "SAPPHIRE"    , "PERIDOT"      }, },
        { "LIBRA"       , { "SAPPHIRE"  , "OPAL"            , "CHRYSOLITE"  , "LAPIS LAZULI" }, },
        { "SCORPIO"     , { "TOPAZ"     , "RED CORAL"       , "JACINTH"     , "MALACHITE"    }, },
        { "SAGITTARIUS" , { "TURQUOISE" , "YELLOW SAPPHIRE" , "SARDONYX"    , "BLUE TOPAZ"   }, },
        { "CAPRICORN"   , { "BERYL"     , "BLUE SAPPHIRE"   , "TOPAZ"       , "BLACK ONYX"   }, },
        { "AQUARIUS"    , { "JACINTH"   , "BLUE SAPPHIRE"   , "AMETHYST"    , "GARNET"       }, },
        { "PISCES"      , { "AMETHYST"  , "YELLOW SAPPHIRE" , "BERYL"       , "AQUAMARINE"   }, },
    };

    ///
    //    PLANET

    const std::map<std::string, std::string> PLANET_MAP =
    {
        // ZODIAC          PLANET

        { "ARIES"       , "MARS"     },
        { "TAURUS"      , "VENUS"    },
        { "GEMINI"      , "MERCURY"  },
        { "CANCER"      , "THE MOON" },
        { "LEO"         , "THE SUN"  },
        { "VIRGO"       , "MERCURY"  },
        { "LIBRA"       , "VENUS"    },
        { "SCORPIO"     , "MARS"     },
        { "SAGITTARIUS" , "JUPITER"  },
        { "CAPRICORN"   , "SATURN"   },
        { "AQUARIUS"    , "SATURN"   },
        { "PISCES"      , "JUPITER"  },
    };

    ///
    //    ELEMENT

    const std::map<std::string, std::string> ELEMENT_MAP =
    {
        // ZODIAC          ELEMENT

        { "ARIES"       , "FIRE"  },
        { "TAURUS"      , "EARTH" },
        { "GEMINI"      , "AIR"   },
        { "CANCER"      , "WATER" },
        { "LEO"         , "FIRE"  },
        { "VIRGO"       , "EARTH" },
        { "LIBRA"       , "AIR"   },
        { "SCORPIO"     , "WATER" },
        { "SAGITTARIUS" , "FIRE"  },
        { "CAPRICORN"   , "EARTH" },
        { "AQUARIUS"    , "AIR"   },
        { "PISCES"      , "WATER" },
    };

    ///
    //    COLOR

    const std::map<std::string, std::string> COLOR_MAP =
    {
        // ZODIAC          COLOR

        { "ARIES"       , "\033[91m" },
        { "TAURUS"      , "\033[92m" },
        { "GEMINI"      , "\033[35m" },
        { "CANCER"      , "\033[94m" },
        { "LEO"         , "\033[91m" },
        { "VIRGO"       , "\033[92m" },
        { "LIBRA"       , "\033[35m" },
        { "SCORPIO"     , "\033[94m" },
        { "SAGITTARIUS" , "\033[91m" },
        { "CAPRICORN"   , "\033[92m" },
        { "AQUARIUS"    , "\033[35m" },
        { "PISCES"      , "\033[94m" },
    };

    ///
    //    SYMBOL

    const uint8_t SYMBOL_WIDTH = 17; // In chars

    const std::map<std::string, std::string> ZODIAC_SYMBOLS =
    {

    { "ARIES",
R"(
   .-.   .-.     %s
  (_  \ /  _) 
       |         %s
       |      
       |         %s)" },

    { "TAURUS",
R"(     .     .  
     '.___.'     %s
     .'   `.   
    :       :    %s
    :       :  
     `.___.'     %s)" },

    { "GEMINI",
R"(
    ._____.      %s
      | |     
      | |        %s
     _|_|_    
    '     '      %s)" },

    { "CANCER",
R"(
      .--.       %s
     /   _`.  
    (_) ( )      %s
   '.    /    
     `--'        %s)" },

    { "LEO",
R"(
      .--.       %s
     (    )   
    (_)  /       %s
        (_,   
                 %s)" },

    { "VIRGO",
R"(   _          
  ' `:--.--.     %s
     |  |  |_  
     |  |  | )   %s
     |  |  |/  
          (J     %s)" },

    { "LIBRA",
R"(
       __        %s
  ___.'  '.___
  ____________   %s
              
                 %s)" },

    { "SCORPIO",
R"(  _           
 ' `:--.--.      %s
    |  |  |    
    |  |  |      %s
    |  |  | ..,
          `--':  %s)" },

    { "SAGITTARIUS",
R"(
          ...    %s
          .':  
        .'       %s
    `..'       
    .'`.         %s)" },

    { "CAPRICORN",
R"(          _   
  \      /_)     %s
   \    /`.   
    \  /   ;     %s
     \/ __.'  
                 %s)" },

    { "AQUARIUS",
R"(
                 %s
 .-"-._.-"-._.-
 .-"-._.-"-._.-  %s
               
                 %s)" },

    { "PISCES",
R"(              
   `-.    .-'    %s
      :  :     
    --:--:--     %s
      :  :     
   .-'    `-.    %s)" },

    };

    //
    //    *** PERMANENT RNG USE ORDER ***
    //

    ///
    //    ZODIAC CYCLE
    //
    //    COMBINED INFLUENCE OF SOL SYSTEM HEAVENLY BODIES AT RANDOM TIME
    //
    //    RAND RANGE MAX: HEAVENLY BODY SIDEREAL CYCLE TIME IN SECONDS

    DragonRNG rng( seed ); // HEAVEN SEEDS EARTH

    const uint64_t SUN_CYCLE = rng.rand_range( (uint64_t) 31558149 ); // SUN

    const std::vector<uint64_t> COSMIC_WARP = 
    {
        SUN_CYCLE,                              // SUN
        rng.rand_range( (uint64_t)   2360591 ), // MOON
        rng.rand_range( (uint64_t)   7600543 ), // MERCURY
        rng.rand_range( (uint64_t)  19414496 ), // VENUS
        rng.rand_range( (uint64_t)  59401546 ), // MARS
        rng.rand_range( (uint64_t) 374335440 ), // JUPITER
        rng.rand_range( (uint64_t) 930116928 ), // SATURN
        rng.rand_range( (uint64_t) 586512112 )  // NORTH / SOUTH NODE
    };

    rng.warp( COSMIC_WARP ); // WARP TO UNIVERSE WITH COSMIC STATE

    ///
    //    COSMIC + GALACTIC + ZODIAC CYCLES

    const uint64_t COSMIC_CYCLE   = rng.rand();
    const uint64_t GALACTIC_CYCLE = rng.rand();
    const uint64_t ZODIAC_CYCLE   = COSMIC_CYCLE ^ GALACTIC_CYCLE;

    const uint32_t ZODIAC_IDX = ZODIAC_CYCLE % ZODIACS.size();

    const std::string ZODIAC   = ZODIACS       .at( ZODIAC_IDX );
    const std::string PLANET   = PLANET_MAP    .at( ZODIAC );
    const std::string SYMBOL   = ZODIAC_SYMBOLS.at( ZODIAC );
    const std::string ELEMENT  = ELEMENT_MAP   .at( ZODIAC );

    const auto& GEM_WARDS      = GEM_WARDS_MAP.at( ELEMENT );
    const auto& GEM_MAGICS     = GEM_MAGIC_MAP.at( ELEMENT );

    const uint32_t GEM_IDX     = rng.rand_range( (uint32_t) NUM_GEM_TYPES        - 1 );
    const uint32_t WARD_IDX    = rng.rand_range( (uint32_t) GEM_WARDS.size()     - 1 );
    const uint32_t MAGIC_IDX   = rng.rand_range( (uint32_t) GEM_MAGICS.size()    - 1 );
    const uint32_t QUALITY_IDX = rng.rand_range( (uint32_t) GEM_QUALITIES.size() - 1 );

    const std::string WARD     = GEM_WARDS [ WARD_IDX  ];
    const std::string MAGIC    = GEM_MAGICS[ MAGIC_IDX ];

    const std::string GEM      = GEM_MAP      .at( ZODIAC      )[ GEM_IDX ];
    const std::string COLOR    = COLOR_MAP    .at( ZODIAC      );
    const std::string QUALITY  = GEM_QUALITIES.at( QUALITY_IDX );

    ///
    //    MOON

    const uint64_t EQUINOX_PRECESSION  = 26000;   // PRECESSION OF THE EQUINOX
    const int SECONDS_IN_SYNODIC_MONTH = 2551442; // 29.5306 DAYS

    // CONVERT SIDEREAL SUN CYCLE TO TROPICAL SUN CYCLE
    const uint64_t SOLAR_CYCLE = SUN_CYCLE - ( SUN_CYCLE / EQUINOX_PRECESSION );

    // SECONDS SINCE NEW MOON
    const uint64_t MOON_SECONDS = SUN_CYCLE % SECONDS_IN_SYNODIC_MONTH;

    std::string MOON_NAME;

         if ( MOON_SECONDS <  318930 ) MOON_NAME = "NEW MOON";
    else if ( MOON_SECONDS <  669754 ) MOON_NAME = "WAXING CRESCENT MOON";
    else if ( MOON_SECONDS <  956791 ) MOON_NAME = "FIRST QUARTER MOON";
    else if ( MOON_SECONDS < 1307614 ) MOON_NAME = "WAXING GIBBOUS MOON";
    else if ( MOON_SECONDS < 1626545 ) MOON_NAME = "FULL MOON";
    else if ( MOON_SECONDS < 1987368 ) MOON_NAME = "WANING GIBBOUS MOON";
    else if ( MOON_SECONDS < 2275405 ) MOON_NAME = "LAST QUARTER MOON";
    else                               MOON_NAME = "WANING CRESCENT MOON";

    ///
    //    SIGN

    const std::string GEM_SIGN = ZODIAC + " :: " + PLANET + " :: " + MOON_NAME;

    ///
    //    LEGEND

    const std::string GEM_LEGEND =
        WARD + " " + QUALITY + " " + GEM + " " + ELEMENT + " GEM OF " + MAGIC;

    ///
    //    CHARM

    std::string GEM_CHARM;
    std::vector<std::string> CHARMS;

    const uint64_t MIRACLE_CHARM_LEVEL = 777;

    uint64_t charm_num      = 0;
    uint64_t charm_level    = 0;
    uint64_t charm_rollover = 0;

    auto sum_digits = [&]( const std::string& charm_str ) // Local function
    {
        for ( int i = 0; i < charm_str.size(); ++i )
        {
            auto digit = charm_str[ i ];
            const uint64_t last_sum = charm_num;
            charm_num += std::stoull( std::string ( { digit } ) ); // + CHARM NUM

            if ( charm_num < last_sum ) ++charm_rollover; // ROLLOVER
        }
    };

    auto find_charms = [&]( const std::string& charm_str ) // Local function
    {
        if ( CHARMS.empty() ) CHARMS.push_back( "" );

        uint64_t str_sum = 0;

        for ( const auto digit : charm_str )
        {
            auto& charm = CHARMS.back();

            str_sum += std::stoull( std::string ( { digit } ) );

            if ( charm.empty() || digit == charm.back() )
            {
                charm += digit;
            }
            else
            {
                if ( charm.size() == 1 ) CHARMS.pop_back();

                CHARMS.push_back( { digit } );
            }
        }

        std::vector<std::string> new_charms;

        for ( int i = (int)CHARMS.size() - 1; i >= 0; --i )
        {
            const std::string& charm = CHARMS[ i ];

            if ( charm.size() < 2 ) continue;

            new_charms.push_back( charm );
            CHARMS.erase( CHARMS.begin() + i );
        }

        if ( new_charms.size() == 0 ) // FOUND CHARMS ?
        {
            return false;
        }

        ++charm_level; // LEVEL UP

        charm_num += str_sum; // + CHARM NUM

        // Maintain charm order of left to right (reading charm int as string)
        for ( int i = (int)new_charms.size() - 1; i >= 0; --i )
        {
            std::string charm = new_charms[ i ];

            const uint64_t last_sum = charm_num;
            charm_num += std::stoull( charm ); // + CHARM NUM
            if ( charm_num < last_sum ) ++charm_rollover; // ROLLOVER

            charm += " + ";
            GEM_CHARM += charm;
        }

        // Multiply final sum by number of charms raised to the power of charm depth
        for ( uint64_t i = 0; i < charm_level; ++i )
        {
            const uint64_t last_val = charm_num;
            charm_num *= new_charms.size(); // * CHARM NUM
            if ( charm_num < last_val ) ++charm_rollover; // ROLLOVER
        }

        return true;
    };

    ///
    //    RECURSIVELY FIND CHARMS IN COSMIC + GALACTIC CYCLES

    std::string charm_search =
        std::to_string( COSMIC_CYCLE ) + std::to_string( GALACTIC_CYCLE );

    while ( charm_level < MIRACLE_CHARM_LEVEL &&
            find_charms( charm_search ) )
    {
        charm_search = std::to_string( charm_num );
    }

    // If no charms found, sum Universe Cycle digits
    if ( charm_level == 0 )
    {
        sum_digits( charm_search ); // + CHARM NUM
    }

    ///
    //    CHARM STRING

    std::string CHARM_LEVEL = int_to_base_26( charm_level );

    // ROLLOVER
    CHARM_LEVEL += charm_rollover > 0 ? "*" + std::to_string(charm_rollover) : "";

    std::string charm_header = "CHARM [" + CHARM_LEVEL + "] " +
        std::to_string( charm_num );

    if ( GEM_CHARM.size() > 0 )
    {
        charm_header += " :: ";
        GEM_CHARM.resize( GEM_CHARM.size() - 2 ); // Remove trailing +
    }

    // Wrap Gem Charm at width of Gem Legend
    int wrap_width = GEM_LEGEND.size() - charm_header.size();

    if ( GEM_CHARM.size() > wrap_width ) // Auto line break
    {
        const std::string WRAP_CHARS = "\n\n                 ";
        int wrap_idx = wrap_width;

        auto adjustBreakLocation = [&]() // Break on space
        {
            while ( wrap_idx > 0 && GEM_CHARM[ wrap_idx - 1] != '+' )
            {
                --wrap_idx;
            }

            ++wrap_idx; // Ensure trailing space is at end of line
        };

        adjustBreakLocation();

        GEM_CHARM.insert( wrap_idx, WRAP_CHARS);
        wrap_idx += WRAP_CHARS.size();

        wrap_width = GEM_LEGEND.size(); // Remove Charm header width

        while ( wrap_idx + wrap_width < GEM_CHARM.size() )
        {
            wrap_idx += wrap_width;
            adjustBreakLocation();
            GEM_CHARM.insert( wrap_idx, WRAP_CHARS);
        }
    }

    GEM_CHARM = charm_header + GEM_CHARM;

    if ( charm_level >= MIRACLE_CHARM_LEVEL ) // MIRACLE CHARM !!!
    {
        GEM_CHARM = "MIRACLE CHARM :: " +
            std::to_string( COSMIC_CYCLE ) + " :: " +
            std::to_string( GALACTIC_CYCLE );
    }

    ///
    //    GEM SEAL

    const int str_size = snprintf(
        nullptr,
        0,
        SYMBOL.c_str(),
        GEM_SIGN.c_str(),
        GEM_LEGEND.c_str(),
        GEM_CHARM.c_str()
    );
    
    GEM_SEAL = std::string(str_size, '\0');

    snprintf(
        &GEM_SEAL[0],
        GEM_SEAL.size() + 1,
        SYMBOL.c_str(),
        GEM_SIGN.c_str(),
        GEM_LEGEND.c_str(),
        GEM_CHARM.c_str()
    );

    GEM_SEAL = COLOR + GEM_SEAL;

    // He who made the Pleiades and Orion,
    // and turns deep darkness into the morning
    // and darkens the day into night,
    // who calls for the waters of the sea
    // and pours them out on the surface of the earth,
    // the LORD is his name

    // SEALED !!! <3
}

///
//    HIDEAGEM CORE API

// TODO version of hide_gems() that does not create copy of ocean

// Returns Gem Ocean of out_ocean_size bytes if successful, or nullptr on failure.
//
// Caller is responsible for freeing returned Gem Ocean memory.
GemOcean hide_gems(
    int gem_protocol,
    const void* ocean,
    const uint64_t ocean_size,
    std::vector<GemFile>& gem_files,
    const std::string& password,
    int time_trap,
    bool b_validate
)
{
    ///
    //    WELCOME TO HIDEAGEM !!!

    PRINT_SPLASH_SCREEN();

    // Ocean
    if (ocean == nullptr)
    {
        PRINT_ERROR("ERROR: Ocean is nullptr.");

        return GemOcean( EGemErrorCode::BAD_ARGUMENT );
    }
    else if (ocean_size == 0)
    {
        std::cerr << "ERROR: Ocean has size of 0." << std::endl;

        return GemOcean( EGemErrorCode::BAD_ARGUMENT );
    }
    else if (gem_files.size() == 0)
    {
        PRINT_ERROR("ERROR: Gem file paths are empty.");

        return GemOcean( EGemErrorCode::BAD_ARGUMENT );
    }

    ///
    //    INIT SHARED OCEAN

    GemOcean SHARED_OCEAN( ocean, ocean_size );

    if ( ! SHARED_OCEAN.is_valid() )
    {
        PRINT_ERROR("Could not initialize Gem Ocean.");

        return GemOcean( EGemErrorCode::INVALID_OCEAN );
    }

    ///
    //    HIDE GEMS

    HideAGem hag( SHARED_OCEAN );

    const bool b_hid_gem = hag.hide_gem_files(
        gem_protocol,
        gem_files,
        password,
        time_trap,
        b_validate
    );

    if ( ! b_hid_gem ) // Error ?
    {
        return GemOcean( hag.get_error_code() );
    }

    return SHARED_OCEAN;
}


GemOcean hide_gems(
    int gem_protocol,
    const void* ocean,
    const uint64_t ocean_size,
    const std::vector<std::vector<std::string>>& file_paths,
    const std::vector<std::string>& passwords,
    const std::vector<int> time_traps,
    bool b_validate
)
{
    ///
    //    WELCOME TO HIDEAGEM !!!

    PRINT_SPLASH_SCREEN();

    PRINT("Starting Gem hide with %u %s.",
        (uint32_t)passwords.size(), passwords.size() > 1 ? "passwords" : "password");

    // Ocean
    if (ocean == nullptr)
    {
        PRINT_ERROR("ERROR: Ocean is nullptr.");

        return GemOcean( EGemErrorCode::BAD_ARGUMENT );
    }
    else if (ocean_size == 0)
    {
        PRINT_ERROR("ERROR: Ocean has size of 0.");

        return GemOcean( EGemErrorCode::BAD_ARGUMENT );
    }
    // Passwords
    else if (passwords.size() == 0)
    {
        PRINT_ERROR("ERROR: Empty passwords.");

        return GemOcean( EGemErrorCode::BAD_ARGUMENT );
    }
    // File paths
    else if (file_paths.size() == 0)
    {
        PRINT_ERROR("ERROR: Gem file paths are empty.");

        return GemOcean( EGemErrorCode::BAD_ARGUMENT );
    }
    else if (file_paths.size() != passwords.size())
    {
        PRINT_ERROR("ERROR: Number of passwords does not match number of file path vectors.");

        return GemOcean( EGemErrorCode::BAD_ARGUMENT );
    }

    ///
    //    INIT SHARED OCEAN

    GemOcean SHARED_OCEAN( ocean, ocean_size );

    if ( ! SHARED_OCEAN.is_valid() )
    {
        PRINT_ERROR("Could not initialize Gem Ocean.");

        return GemOcean( EGemErrorCode::INVALID_OCEAN );
    }

    ///
    //    HIDE GEMS

    // Hide Gems at all password layers
    for (int i = 0; i < passwords.size(); ++i)
    {
        if (passwords.size() > 1)
        {
            const uint64_t num_gem_files = file_paths[i].size();

            PRINT("Password %d: Hiding %llu Gem %s ",
                i + 1, num_gem_files, num_gem_files > 1 ? "Files" : "File");
        }

        HideAGem hag( SHARED_OCEAN );

        const int time_trap = i < time_traps.size() ? time_traps[i] : -1;

        const bool b_hid_gem = hag.hide_gem_files(
            gem_protocol,
            file_paths[i],
            passwords[i],
            time_trap,
            b_validate
        );

        if ( ! b_hid_gem ) // Error ?
        {
            return GemOcean( hag.get_error_code() );
        }
    }

    return SHARED_OCEAN;
}


std::vector<GemFile> find_gems(
    const void* ocean, 
    uint64_t ocean_size,
    const std::vector<std::string>& passwords,
    const std::string* output_dir,
    const std::vector<bool> time_traps
)
{
    ///
    //    WELCOME TO HIDEAGEM !!!

    PRINT_SPLASH_SCREEN(); // It's Ocean time !!!

    std::vector<GemFile> gem_files;

    ///
    //    INIT SHARED OCEAN

    GemOcean SHARED_OCEAN( ocean, ocean_size );

    if ( ! SHARED_OCEAN.is_valid() )
    {
        PRINT_ERROR("Could not initialize Ocean.");

        return gem_files;
    }

    ///
    //    FIND GEMS !!!

    const std::string ocean_size_str = HideAGemCore::bytes_to_size_string( SHARED_OCEAN.size() );
    PRINT("Starting Gem search in Ocean of size %llu bytes [ %s ]", SHARED_OCEAN.size(), ocean_size_str.c_str());

    const auto start_time = std::chrono::high_resolution_clock::now();

    // For each password, search for gem files in ocean
    for (uint64_t i = 0; i < passwords.size(); ++i)
    {
        if (passwords.size() > 1)
        {
            PRINT("Searching with password %llu.", i + 1);
        }

        try
        {
            HideAGem hag( SHARED_OCEAN );

            const bool b_time_trap = i < time_traps.size() ? time_traps[i] : false;

            const uint64_t num_found = hag.find_gem_files(
                passwords[i],
                gem_files,
                b_time_trap
            );

            if (num_found > 0)
            {
                PRINT("Found %llu %s with password %llu ",
                    num_found, num_found > 1 ? "Gems" : "Gem", i + 1);

                continue; // Success !
            }

            switch ( hag.get_error_code() ) // PROCESS ERROR
            {
                case EGemErrorCode::EXIT_SIGNAL :
                case EGemErrorCode::GEM_STREAM_DECOMPRESSION_ABORTED :

                    return gem_files; // E X I T

                default :

                    break;
            }
        }
        catch (const _E& e)
        {
            std::cerr << e.what() << std::endl << std::endl;

            break;
        }
        catch(const std::exception& e)
        {
            std::cerr << e.what() << std::endl << std::endl;

            break;
        }
        catch( ... )
        {
            PRINT("Caught unknown exception!");

            break;
        }
    }

    auto stop_time = std::chrono::high_resolution_clock::now();
    std::chrono::duration<double> time_duration = stop_time - start_time;
    const double   time_s = time_duration.count();
    const uint64_t time_m = (uint64_t)(time_s / 60);
    const char* files_str = gem_files.size() > 1 ? "FILES" : "FILE";

    if ( gem_files.size() == 0 ) // WOW REKT !!! >_< </3
    {
        PRINT_ERROR("*** FOUND ZERO GEM FILES ***");

        goto NO_MAGIC_WORD; // </3 !
    }

    // Found gem files !!! ^_^ <3 <3 <3

    if ( output_dir == nullptr )
    {
        PRINT_WARNING("No output directory specified. Nothing saved to disk.");

        goto GEM_FIND_SUCCESS; // Done !
    }

    ///
    //    OPTIONALLY SAVE GEM FILES TO DISK

    {

    std::string save_path = *output_dir;
    const std::filesystem::path _save_path(save_path);
    save_path = _save_path.lexically_normal().string(); // Normalize file path

    if ( ! std::filesystem::exists( save_path ) ) // Create output directory ?
    {
        PRINT_WARNING("Create directory %s and save %llu Gem %s ?", save_path.c_str(),
            (uint64_t)gem_files.size(), gem_files.size() > 1 ? "Files" : "File" );

        if ( STDIN_YES_OR_NO() ) // <-- Blocks thread
        {
            PRINT("Creating directory: %s", save_path.c_str());
            std::filesystem::create_directories( save_path );
        }
        else
        {
            PRINT("Output directory not created. No Gem Files saved to disk.");

            goto GEM_FIND_SUCCESS;
        }
    }
    else
    {
        PRINT_WARNING("Save %llu Gem %s to directory %s ?",
            (uint64_t)gem_files.size(), gem_files.size() > 1 ? "Files" : "File", save_path.c_str()
        );

        if ( ! STDIN_YES_OR_NO() ) // <-- Blocks thread
        {
            PRINT("No Gem Files saved to disk.");

            goto GEM_FIND_SUCCESS;
        }
    }

    // --

    if ( ! std::filesystem::is_directory( save_path ) ) // Is destination a directory ?
    {
        PRINT_ERROR("Invalid output directory (not a directory): %s", save_path.c_str());

        goto GEM_FIND_SUCCESS;
    }

#ifdef _WIN32   // Ensure trailing slash
    if (save_path.back() != '\\') save_path.push_back('\\');
#else 
    if (save_path.back() != '/') save_path.push_back('/');
#endif
    
    for (const auto& gem_file : gem_files)
    {
        std::string file_name = gem_file.name();
        std::string file_ext;

        const size_t dot_pos = file_name.rfind('.');
        if (dot_pos != std::string::npos)
        {
            file_ext = file_name.substr(dot_pos + 1);
            file_name = file_name.substr(0, dot_pos);
        }

        std::string file_path = save_path + file_name + "." + file_ext;
        int file_num = 1;

        // Prevent over-writing files
        while(std::ifstream(file_path).is_open())
        {
            file_path = save_path + file_name + "_" + std::to_string(file_num) +  "." + file_ext;
            ++file_num;
        }

        std::ofstream out_file(file_path, std::ios::binary);

        if (!out_file)
        {
            std::cerr << "Failed to open file: " << file_path << std::endl;
            continue;
        }

        out_file.write(reinterpret_cast<const char*>(gem_file.data()), gem_file.size());
        out_file.close();

        PRINT_NO_NEWLINE("Saved file: %s \n", file_path.c_str());
    }

    printf("\n");

    }

GEM_FIND_SUCCESS:
    
    // <3 !!! ^_^

    if (time_m < 1)
    {
        PRINT_SUCCESS("*** FOUND %llu GEM %s IN %.2fs ***",
            (uint64_t)gem_files.size(), files_str, time_s);
    }
    else
    {
        PRINT_SUCCESS("*** FOUND %llu GEM %s IN %llum %.2fs ***",
            (uint64_t)gem_files.size(), files_str, time_m, time_s);
    }

NO_MAGIC_WORD:

    return gem_files; // E X I T
}

///
//    GEM OCEAN

GemOcean::GemOcean(const void* source_ocean, const uint64_t source_ocean_size)
{
    if ( source_ocean == nullptr )
    {
        PRINT_ERROR("Tried to create Gem Ocean with nullptr source_ocean.");

        return;
    }
    else if ( source_ocean_size == 0 )
    {
        PRINT_ERROR("Tried to create Gem Ocean with source_ocean_size == 0.");

        return;
    }

    const int desired_channels = 0; // Zero copies channels from source
    const std::string ocean_size_str = bytes_to_size_string(source_ocean_size);

    ocean = static_cast<uint8_t*>(
        stbi_load_from_memory(
            static_cast<const stbi_uc*>(source_ocean), source_ocean_size, &_width, &_height, &_channels, desired_channels
        )
    );

    if ( ocean != nullptr ) // OCEAN is image
    {
        // Set OCEAN type
        switch ( _channels )
        {
            case 1: // Grayscale or PNG8 (indexed color)

                _type = EOceanType::IMAGE_GRAYSCALE;

                break;

            case 3: // RGB

                _type = EOceanType::IMAGE_RGB;

                break;

            case 4: // RGBA

                _type = EOceanType::IMAGE_RGBA;

                break;

            default:
            {
                // TODO test other image types

                stbi_image_free( ocean ); // Free memory
                PRINT_ERROR("Unsupported number of image color channels: %d", _channels);

                return; // E X I T
            }
        }

        _size = static_cast<size_t>( _width * _height * _channels );

        PRINT("Loaded Ocean of size %s as image with %d color %s.", ocean_size_str.c_str(), _channels, _channels > 1 ? "channels" : "channel");
    }
    else // Not an image: Copy source ocean into OCEAN
    {
        _width = 0;
        _height = 0;
        _channels = 0;

        ocean = ( uint8_t* ) malloc( source_ocean_size );
        std::memcpy( ocean, source_ocean, source_ocean_size );

        _size = source_ocean_size;
        _type = EOceanType::BYTES;

        PRINT("Loaded Ocean of size %s as raw bytes.", ocean_size_str.c_str());
    }

    // Init OCEAN byte set
    switch_byte_set( DEFAULT_BYTE_SET_KEY );
}


GemOcean::~GemOcean()
{
    vanish();
}


uint64_t GemOcean::size() const
{
    switch ( _type )
    {
        case EOceanType::BYTES :
        case EOceanType::IMAGE_RGB :
        case EOceanType::IMAGE_GRAYSCALE :

            return _size;

        case EOceanType::IMAGE_RGBA :

            // Subtract alpha channel bytes
            return _size - ( _size / 4 );

        default :

            throw _E("GemOcean :: size() :: Unsupported Ocean type.");
    }

    return _size;
}


bool GemOcean::is_valid() const
{
    return ocean != nullptr && _size > 0;
}


// Caller becomes responsible for freeing Ocean memory!
uint8_t* GemOcean::take()
{
    uint8_t* taking_ocean = ocean;
    ocean = nullptr;

    return taking_ocean;
}


void GemOcean::finalize()
{
    if ( ocean == nullptr )
    {
        throw _E("Tried to finalize nullptr Gem Ocean.");
    }
    else if ( b_finalized )
    {
        throw _E("Tried to finalize Gem Ocean that is already finalized.");
    }

    b_finalized = true;

    switch ( _type )
    {
        case EOceanType::IMAGE_RGB :
        case EOceanType::IMAGE_RGBA :
        case EOceanType::IMAGE_GRAYSCALE :

            // Save as PNG image below ...

            break;

        default :

            return; // E X I T
    }

    ///
    //    WRITE OCEAN DATA TO PNG IMAGE FILE IN MEMORY

    int png_size = 0;

    uint8_t* png_data = static_cast<uint8_t*>(
        stbi_write_png_to_mem( ocean, _width * _channels, _width, _height, _channels, &png_size)
    );

    if (sodium_init() < 0)
    {
        free( ocean );
        ocean = nullptr;

        throw _E("Failed to finalize GemOcean: libsodium could not be initialized.");
    }

    sodium_memzero( ocean, _size ); // Secure erase
    free( ocean );                  // Free Ocean memory

    ocean = png_data; // Replace Ocean with PNG file bytes
    _size = png_size; // Update size in bytes
    _type = EOceanType::BYTES; // Set type to BYTES so size() will return correct size
}


void GemOcean::vanish()
{
    _width = 0;
    _height = 0;
    _channels = 0;
    _type = EOceanType::BYTES;

    byte_set_map.clear();

    if ( ocean != nullptr )
    {
        if (sodium_init() < 0)
        {
            _size = 0;
            free( ocean );
            ocean = nullptr;

            throw _E("Failed to vanish GemOcean: libsodium could not be initialized.");
        }

        // Secure erase
        sodium_memzero( ocean, _size );
        free( ocean );
        ocean = nullptr;
    }

    _size = 0;
}

///
//    GEM FILE

bool GemFile::pack()
{
    if (!b_data_init)
    {
        throw _E("ERROR: GemFile::pack() :: Tried to pack Gem data before initializing data.");
    }
    else if (sodium_init() < 0)
    {
        throw _E("ERROR: GemFile::pack() :: libsodium could not be initialized.");
    }
    else if (pack_state == PackState::PACKED)
    {
        return true; // Already packed
    }
    else if (_name.size() > MAX_NAME_LEN)
    {
        PRINT_WARNING("WARNING: GemFile::pack() :: File name exceeds 255 characters and will be truncated to first 255 chars.");
    }

    // TODO preserve file extension when truncating
    const uint8_t name_size =
        _name.size() > MAX_NAME_LEN ? 255 : static_cast<uint8_t>(_name.size());

    const uint64_t blob_size = size() + name_size + sizeof(name_size);

    uint8_t* blob     = (uint8_t*)sodium_malloc( blob_size );
    uint8_t* blob_idx = blob;

    std::memcpy( blob_idx, &name_size, sizeof(name_size) ); // Name size byte
    blob_idx += sizeof(name_size);

    if ( name_size > 0 )
    {
        std::memcpy( blob_idx, _name.data(), name_size ); // Name string
        blob_idx += name_size;
    }

    std::memcpy( blob_idx, _data, size() ); // Data

    if ( b_locked ) // Locked ?
    {
        sodium_mprotect_readonly( blob ); // Read-only
    }

    free_data( _data ); // Free old data

    _data = blob;
    data_size = blob_size;

    pack_state = PackState::PACKED;

    return true;
}


bool GemFile::unpack(const bool b_force)
{
    if (!b_data_init)
    {
        throw _E("ERROR: GemFile::unpack() :: Tried to unpack Gem data before initializing data.");
    }
    else if (sodium_init() < 0)
    {
        throw _E("ERROR: GemFile::unpack() :: libsodium could not be initialized.");
    }

    const bool b_packed = pack_state == PackState::PACKED;

    if ( !b_packed && !b_force )
    {
        return true; // (Possibly) already unpacked
    }

    uint8_t* blob_idx = _data;

    // Unpack file name
    const uint8_t name_size = _data[0];
    blob_idx += sizeof(name_size);

    if ( name_size > 0 )
    {
        _name = std::string( reinterpret_cast<char*>(blob_idx), name_size );
        blob_idx += name_size;
    }

    data_size = data_size - sizeof(name_size) - name_size;

    if ( data_size == 0 ) // Error ?
    {
        throw _E("ERROR: GemFile::Unpack() :: Uncompressed data size is zero.");
    }

    uint8_t* final_data = (uint8_t*)sodium_malloc( data_size );
    std::memcpy( final_data, blob_idx, data_size ); // Copy data

    free_data( _data ); // Free packed data

    _data = final_data;
    pack_state = PackState::UNPACKED;

    if ( b_locked ) // Locked ?
    {
        sodium_mprotect_readonly( _data ); // Read-only
    }

    return true;
}

///
//    GEM PROTOCOL GLOBALS

bool get_gem_protocol(const EGemProtocolKey gem_protocol, GemProtocol& out_protocol)
{
    auto proto = GEM_PROTOCOLS.find(gem_protocol);
    
    if (proto != GEM_PROTOCOLS.end())
    {
        out_protocol = proto->second;

        return true;
    }

    return false;
}

//
//    MINIZ COMPRESSION / DECOMPRESSION
//

bool miniz_compress
(
    uint8_t*  input, 
    uint64_t  input_size, 
    uint8_t*  output, 
    uint64_t* output_size
)
{
    if (output == nullptr)
    {
        throw _E("Tried to compress data into nullptr output.");
    }
    else if (input == nullptr)
    {
        throw _E("Tried to compress nullptr data.");
    }
    else if (output_size == nullptr)
    {
        throw _E("Tried to compress data with nullptr output_size.");
    }
    else if (*output_size > std::numeric_limits<uint32_t>::max())
    {
        // TODO handle streams > 4GB
        throw _E("Hiding Gem Streams larger than 4 GB not yet supported!");
    }

    mz_stream stream = {0};
    stream.next_in   = input;
    stream.avail_in  = (mz_uint32)input_size;
    stream.next_out  = output;
    stream.avail_out = (mz_uint32)(*output_size);

    if (mz_deflateInit(&stream, MZ_BEST_COMPRESSION) != MZ_OK)
    {
        throw _E("Data compression initialization failed.");
    }

    const int status = mz_deflate( &stream, MZ_FINISH );

    if ( status == MZ_STREAM_ERROR )
    {
        mz_deflateEnd( &stream );

        throw _E("Data compression failed.");
    }

    mz_deflateEnd( &stream );

    *output_size = stream.total_out;

    return true; // Success
}


bool miniz_decompress
(
    uint8_t*  input, 
    uint64_t  input_size, 
    uint8_t*  output, 
    uint64_t* output_size
)
{
    if (output == nullptr)
    {
        throw _E("Tried to decompress data into nullptr output.");
    }
    else if (input == nullptr)
    {
        throw _E("Tried to decompress nullptr data.");
    }
    else if (output_size == nullptr)
    {
        throw _E("Tried to decompress data with nullptr output_size.");
    }
    else if (*output_size > std::numeric_limits<uint32_t>::max())
    {
        // TODO handle streams > 4GB
        throw _E("Hiding Gem Streams larger than 4 GB not yet supported!");
    }

    mz_stream stream = {0};
    stream.next_in   = input;
    stream.avail_in  = (mz_uint32)input_size;
    stream.next_out  = output;
    stream.avail_out = (mz_uint32)(*output_size);

    if (mz_inflateInit(&stream) != MZ_OK)
    {
        throw _E("Data decompression initialization failed.");
    }

    // TODO extract stream > 4GB

    const int status = mz_inflate( &stream, MZ_FINISH );
    mz_inflateEnd( &stream );

    if (status != MZ_STREAM_END)
    {
        throw _E("Data decompression failed.");
    }

    *output_size = stream.total_out;

    return true; // Success
}

///
//    UTILITIES

std::string bytes_to_size_string(const uint64_t size, const int max_unit_index, const bool b_decimal)
{
    constexpr std::array<const char*, 5> units = {" bytes", " KB", " MB", " GB", " TB"};

    int unit_index = 0;
    uint64_t unit_size = size;

    while (unit_size >= 1024 && unit_index < max_unit_index && unit_index < units.size())
    {
        unit_size /= 1024;
        ++unit_index;
    }

    if (unit_index == 0 || !b_decimal)
    {
        return std::to_string(unit_size) + units[unit_index];
    }

    // Calculating integer and decimal parts for sizes in KB and above
    uint64_t scale = 1;

    for (int i = 0; i < unit_index; i++)
    {
        scale *= 1024;
    }

    uint64_t integer_part = size / scale;
    uint64_t remainder = size % scale;
    uint64_t decimal_part = (remainder * 100) / scale;

    std::string formatted_size = std::to_string(integer_part);

    if (decimal_part > 0)
    {
        formatted_size += std::string(".") + (decimal_part < 10 ? "0" : "") + std::to_string(decimal_part);
    }
    else
    {
        formatted_size += std::string(".00");
    }

    formatted_size += units[unit_index];

    return formatted_size;
}


std::string int_to_base_26(uint64_t n)
{
    if (n == 0)
    {
        return "A";
    }

    std::string result = "";

    while (n > 0)
    {
        char c = 'A' + (n % 26);
        result = c + result;
        n /= 26;
    }

    return result;
}


std::string normalize_unicode(const std::string& input)
{
    const utf8proc_uint8_t* input_data = reinterpret_cast<const utf8proc_uint8_t*>(input.c_str());
    utf8proc_uint8_t* normalized_data = utf8proc_NFC(input_data);

    if (normalized_data != nullptr)
    {
        // Convert the normalized data to a C++ string
        const std::string normalized_string(reinterpret_cast<const char*>(normalized_data));

        free(normalized_data);

        return normalized_string;
    }

    return input;
}

///
//    DEBUG ZONE

bool RUN_UNIT_TESTS(bool b_loop, bool b_demo_mode)
{
    INIT_SIGNAL_WATCHERS() // Init system signal watchers (e.g. SIGINT)

    //
    //    NOTE: These tests are not exhaustive !
    //

    constexpr int    start_protocol   = 0;
    constexpr int    end_protocol     = 0;
    constexpr size_t min_password_len = 1;
    constexpr size_t max_password_len = 1024;
    constexpr size_t file_name_len    = 43;

    DragonRNG rng; // True random RNG

    auto rand_password = [&]() // Local function
    {
        std::string password;
        const size_t len = rng.rand_range(max_password_len, min_password_len);

        for (size_t k = 0; k < len; ++k)
        {
            password += (char)rng.rand_range((uint8_t)255, (uint8_t)32);
        }

        return password;
    };

    auto rand_filename = [&]() // Local function
    {
        std::string filename;

        for (size_t k = 0; k < file_name_len; ++k)
        {
            filename += (char)rng.rand_range((uint8_t)90, (uint8_t)65);
        }

        return filename;
    };

    bool b_error = false;

    //
    //    ** DEMO MODE ( SLOW MODE ) **
    //

    while ( b_demo_mode )
    {
        const int demo_time_ms = 6000;

        const uint64_t start_byte = 311111;
        const uint64_t ocean_size = 1024 * 350; // 350 KB
        GhostVector<uint8_t> ocean_vec( ocean_size );
        uint8_t* ocean = ocean_vec.data();

        ///
        //    SINGLE PASSWORD + SINGLE FILE

        for (int gem_bytes = start_byte; gem_bytes < ocean_size; gem_bytes += 1)
        {
            if ( EXIT_SIGNAL ) return true; // E X I T  S I G N A L

            std::vector<GemFile> gem_files;
            gem_files.push_back( GemFile( gem_bytes ) );
            GemFile& gem_file = gem_files.back();
            gem_file.set_name(  rand_filename() );
            TRUE_RANDOM::rand_bytes( gem_file.data(), gem_file.size() );

            //
            //    HIDE GEMS
            //

            auto gem_ocean = hide_gems(
                0, // Auto Gem Protocol
                ocean,
                ocean_size,
                gem_files,
                rand_password()
            );

            if (gem_ocean.get_error() == EGemErrorCode::NOT_ENOUGH_SPACE)
            {
                gem_bytes = 0; // Restart demo cycle !

                continue;
            }
            else if (gem_ocean.get_error() != EGemErrorCode::NONE)
            {
                return false; // E X I T...
            }

            auto start_time = std::chrono::high_resolution_clock::now();

            for (;;)
            {
                if ( EXIT_SIGNAL ) return true; // E X I T  S I G N A L

                auto end_time = std::chrono::high_resolution_clock::now();
                std::chrono::duration<double, std::milli> elapsed = end_time - start_time;

                if (elapsed.count() >= demo_time_ms) break;

                std::this_thread::sleep_for(std::chrono::milliseconds(1));
            }
        }
    }

    //
    //    *** END DEMO MODE ***
    //

UNIT_LOOP:

    ///
    //    BEGIN UNIT TESTS

    PRINT("\nBEGIN HIDEAGEM UNIT TESTS");

    //
    //    CYCLE KEY
    //

    /*    <--  DISABLE
    PRINT("BEGINNING CYCLE KEY UNIT TESTS ");

    const int num_keys = max_password_len - min_password_len + 1;

    std::vector<int> _keys(num_keys);
    std::iota(_keys.begin(), _keys.end(), 1);
    std::atomic<bool> b_key_error(false);

    // TIME
    const auto start_time = std::chrono::high_resolution_clock::now();
    auto stop_time = std::chrono::high_resolution_clock::now();
    std::chrono::duration<double> time_duration;
    double time_s = 0;

    std::for_each(std::execution::par, _keys.begin(), _keys.end(), [&](int password_len)
    {
        CycleKey _key;
        uint8_t* _salt = _key.salt_write();

        for (int j = 0; j < _key.salt_size(); ++j)
        {
            _salt[j] = TRUE_RANDOM::rand_byte();
        }

        try
        {
            _key.init( rand_password() );
        }
        catch (const _E& e)
        {
            std::cerr << e.what() << std::endl << std::endl;
            PRINT_ERROR("*** FAILED TO GENERATE CYCLE KEY ***");
            b_key_error = true;
        }
        catch ( ... )
        {
            b_key_error = true;
            PRINT_ERROR("*** UNKNOWN ERROR *** ");
            PRINT_ERROR("*** FAILED TO GENERATE CYCLE KEY ***");
        }
    });

    if (b_key_error)
    {
        return false; // E X I T
    }

    // TIME
    stop_time = std::chrono::high_resolution_clock::now();
    time_duration = stop_time - start_time;
    time_s = time_duration.count();

    PRINT("Took %.4f seconds to generate %d keys in parallel.", time_s, num_keys);

    PRINT_SUCCESS("CYCLE KEY UNIT TESTS COMPLETE !!!");

    //
    //    GEM FILE
    //

    PRINT("BEGINNING GEM FILE UNIT TESTS ");

    for (size_t file_size = 1; file_size < 1024; ++file_size)
    {
        if ( EXIT_SIGNAL )
        {
            return true; // E X I T
        }

        std::string file_path = DEBUG_DIR + rand_filename();

        // Check if directory exists
        std::filesystem::path dir_path(std::filesystem::path(file_path).parent_path());

        // Write the random bytes to file
        std::vector<unsigned char> random_bytes(file_size);
        for (auto &byte : random_bytes)
        {
            byte = static_cast<unsigned char>(rng.rand());
        }

        std::ofstream output_file(file_path, std::ios::out | std::ios::binary);
        if (output_file.is_open())
        {
            output_file.write(reinterpret_cast<const char *>(random_bytes.data()), random_bytes.size());
            output_file.close();
        }
        else
        {
            PRINT_ERROR("Failed to open file for writing: %s", file_path.c_str());

            return false; // E X I T
        }

        GemFile _file( file_path );

        std::filesystem::remove( file_path ); // Delete test file
    }

    PRINT_SUCCESS("GEM FILE UNIT TESTS COMPLETE !!!");

    DISABLE  -->    */

    //
    //    OCEAN PARAMETERS
    //

    const uint64_t start_byte = 1;
    const uint64_t ocean_size = 1024 * 10; // 10 KB
    GhostVector<uint8_t> ocean_vec( ocean_size );
    uint8_t* ocean = ocean_vec.data();

    //
    //    SINGLE PASSWORD SINGLE FILE
    //

    for (int gem_bytes = start_byte; gem_bytes < ocean_size; gem_bytes += 1)
    {
        const size_t file_size = gem_bytes;

        for (int gem_protocol_key = start_protocol; gem_protocol_key <= end_protocol; ++gem_protocol_key)
        {
            if ( EXIT_SIGNAL ) return true; // E X I T  S I G N A L

            PRINT("SINGLE PASSWORD SINGLE FILE :: %d BYTES :: GEM PROTOCOL %d \n", gem_bytes, gem_protocol_key);

            std::vector<GemFile> gem_files;
            gem_files.push_back( GemFile( gem_bytes ) );
            GemFile& gem_file = gem_files.back();
            gem_file.set_name(  rand_filename() );
            TRUE_RANDOM::rand_bytes( gem_file.data(), gem_file.size() );

            const std::string password = rand_password();

            //
            //    HIDE GEMS
            //

            auto gem_ocean = hide_gems(
                0, // Auto Gem Protocol
                ocean,
                ocean_size,
                gem_files,
                rand_password(),
                true // b_validate
            );

            if (gem_ocean.get_error() == EGemErrorCode::NOT_ENOUGH_SPACE)
            {
                break;
            }
            else if (gem_ocean.get_error() == EGemErrorCode::EXIT_SIGNAL)
            {
                return true; // E X I T  S I G N A L
            }
            else if (gem_ocean.get_error() != EGemErrorCode::NONE)
            {
                b_error = true;
                break;
            }

            PRINT_SUCCESS("*** ALL READ GEM FILES MATCH DISK FILES: GEM PROTOCOL %d ***",
                gem_protocol_key); // <3 !!!
        }

        if (b_error)
        {
            break; // E X I T
        }
    }

    if (b_error)
    {
        PRINT_ERROR("*** SOME UNIT TESTS FAILED ***");

        return false; // E X I T
    }

    //
    //    SINGLE PASSWORD + MULTIPLE FILES
    //

    {
    int num_files = 100;
    int max_bytes = (int)ocean_size;
    int byte_skip = (int)ocean_size / 25;

    for (int gem_bytes = start_byte; gem_bytes < max_bytes; gem_bytes += byte_skip)
    {
        const size_t file_size = gem_bytes < num_files ? gem_bytes : gem_bytes / num_files;

        for (int gem_protocol_key = start_protocol; gem_protocol_key <= end_protocol; ++gem_protocol_key)
        {
            if ( EXIT_SIGNAL )
            {
                return true; // E X I T
            }

            PRINT("SINGLE PASSWORD + MULTIPLE FILES :: %d BYTES :: GEM PROTOCOL %d \n", gem_bytes, gem_protocol_key);

            std::vector<GemFile> gem_files;
            const std::string password = rand_password();

            for (int j = 0; j < num_files; ++j)
            {
                // Add new Gem File
                gem_files.push_back( GemFile( gem_bytes ) );
                GemFile& gem_file = gem_files.back();
                gem_file.set_name(  rand_filename() );
                TRUE_RANDOM::rand_bytes( gem_file.data(), gem_file.size() );

                //
                //    HIDE GEMS
                //

                auto gem_ocean = hide_gems(
                    0, // Auto Gem Protocol
                    ocean,
                    ocean_size,
                    gem_files,
                    rand_password(),
                    true // b_validate
                );

                if (gem_ocean.get_error() == EGemErrorCode::NOT_ENOUGH_SPACE)
                {
                    break;
                }
                else if (gem_ocean.get_error() != EGemErrorCode::NONE)
                {
                    b_error = true;
                    break;
                }
            }

            if (b_error)
            {
                break; // E X I T
            }
            else
            {
                PRINT_SUCCESS("*** ALL READ GEM FILES MATCH DISK FILES: GEM PROTOCOL %d ***",
                    gem_protocol_key); // <3 !!!
            }
        }

        if (b_error)
        {
            break; // E X I T
        }
    }

    if (b_error)
    {
        PRINT_ERROR("*** SOME UNIT TESTS FAILED ***");

        return false; // E X I T
    }
    }

    if (b_error)
    {
        PRINT_ERROR("*** SOME UNIT TESTS FAILED ***");

        return false;
    }

    PRINT_SUCCESS("*** ALL UNIT TESTS RAN SUCCESSFULLY ***"); // <3 !!!

    ///
    //    LOOP

    if ( b_loop ) goto UNIT_LOOP;

    ///
    //    E X I T

    return true;
}

///
//    TERMINAL

void WRITE_STD_OUT(const char* str, va_list args)
{
    vprintf(str, args);
}


void PRINT(const char* str, va_list args)
{
    printf( "%s", TERM_COLORS[ "WHITE_BRIGHT" ] );
    WRITE_STD_OUT( str, args );
    RESET_TERM_CURSOR(); // RESET CURSOR
    printf("\n\n"); // DOUBLE NEWLINE
}


void PRINT(const char* str, ...)
{
    va_list args;
    va_start(args, str);
    PRINT( str, args );
    va_end( args);
}


void PRINT_COLOR(const char* color, const char* str, va_list args)
{
    printf( "%s", TERM_COLORS[ color ] );
    WRITE_STD_OUT( str, args );
    RESET_TERM_CURSOR(); // RESET CURSOR
    printf("\n\n"); // DOUBLE NEWLINE
}


void PRINT_COLOR(const char* color, const char* str, ...)
{
    va_list args;
    va_start(args, str);
    printf( "%s", TERM_COLORS[ color ] );
    WRITE_STD_OUT( str, args );
    RESET_TERM_CURSOR(); // RESET CURSOR
    printf("\n\n"); // DOUBLE NEWLINE
    va_end( args);
}


void PRINT_SUCCESS(const char* str, ...)
{
    va_list args;
    va_start(args, str);
    PRINT_COLOR( "GREEN_BRIGHT", str, args );
    va_end( args);
}


void PRINT_WARNING(const char* str, ...)
{
    va_list args;
    va_start(args, str);
    PRINT_COLOR( "YELLOW_BRIGHT", str, args );
    va_end( args);
}


void PRINT_ERROR(const char* str, ...)
{
    va_list args;
    va_start(args, str);
    PRINT_COLOR( "RED_BRIGHT", str, args );
    va_end( args);
}


void PRINT_NO_NEWLINE(const char* str, ...)
{
    va_list args;
    va_start(args, str);
    printf( "%s", TERM_COLORS[ "WHITE_BRIGHT" ] );
    WRITE_STD_OUT( str, args );
    RESET_TERM_CURSOR(); // RESET CURSOR
    va_end( args);
}


void PRINT_SAME_LINE(const char* str, ...)
{
    va_list args;
    va_start(args, str);
    printf( "%s", TERM_COLORS[ "WHITE_BRIGHT" ] );
    WRITE_STD_OUT( str, args );
    va_end( args);
    RESET_TERM_CURSOR(); // RESET CURSOR

    // MOVE CURSOR TO BEGINNING OF LINE
    //
    // Injects newline to force terminal redraw
    // then moves cursor back up one line.
    printf("\033[K\r\n\x1B[1A");
}


void PRINT_SAME_LINE_COLOR(const char* color, const char* str, ...)
{
    va_list args;
    va_start(args, str);
    printf( "%s", TERM_COLORS[ color ] );
    WRITE_STD_OUT( str, args );
    va_end( args);
    RESET_TERM_CURSOR(); // RESET CURSOR

    // MOVE CURSOR TO BEGINNING OF LINE
    //
    // Injects newline to force terminal redraw
    // then moves cursor back up one line.
    printf("\033[K\r\n\x1B[1A");
}


void HIDE_TERM_CURSOR()
{
    printf("\033[?25l");
}


void SHOW_TERM_CURSOR()
{
    printf("\033[?25h");
}


void RESET_TERM_CURSOR()
{
    printf("\033[0m");
}


bool STDIN_YES_OR_NO()
{
    auto PRINT_PROMPT = []()
    {
        printf("\033[97m\033[92myes\033[97m / \033[91mno\033[97m => ");
    };
    
    PRINT_PROMPT(); // Yes / No

    SHOW_TERM_CURSOR(); // Show cursor

    bool b_yes = false;

    do
    {
        int ch = getchar();

        b_yes = ch == 'y';

        if ( ch == '\n' )
        {
            PRINT_PROMPT();

            continue;
        }

        break;
    }
    while ( true );

    HIDE_TERM_CURSOR(); // Hide cursor

    std::cout << "\n"; // Double newline

    return b_yes;
}


void PRINT_SPLASH_SCREEN()
{
    HIDE_TERM_CURSOR();
    RESET_TERM_CURSOR();

    //  _    _ _____ _____  ______          _____ ______ __  __ 
    // | |  | |_   _|  __ \|  ____|   /\   / ____|  ____|  \/  |
    // | |__| | | | | |  | | |__     /  \ | |  __| |__  | \  / |
    // |  __  | | | | |  | |  __|   / /\ \| | |_ |  __| | |\/| |
    // | |  | |_| |_| |__| | |____ / ____ \ |__| | |____| |  | |
    // |_|  |_|_____|_____/|______/_/    \_\_____|______|_|  |_|
    //
    //                      WWW.CYBERGEM.NET
    //                      ____ ______ ____
    //                     /    /      \    \
    //                    /___ /________\ ___\
    //                    \    \        /    /
    //                      \   \      /   /
    //                        \  \    /  /
    //                          \ \  / /
    //                             \/
    //
    //

    printf("\033[35m  _    _ _____ _____  ______          \033[92m_____ \033[94m______\033[91m __  __ \033[97m\n");
    printf("\033[35m | |  | |_   _|  __ \\|  ____|\033[97m   /\\   \033[92m/ ____|\033[94m  ____\033[91m|  \\/  |\033[97m\n");
    printf("\033[35m | |__| | | | | |  | | |__  \033[97m   /  \\ \033[92m| |  __\033[94m| |__  \033[91m| \\  / |\033[97m\n");
    printf("\033[35m |  __  | | | | |  | |  __| \033[97m  / /\\ \\\033[92m| | |_ |\033[94m  __| \033[91m| |\\/| |\033[97m\n");
    printf("\033[35m | |  | |_| |_| |__| | |____\033[97m / ____ \\ \033[92m|__| |\033[94m |____\033[91m| |  | |\033[97m\n");
    printf("\033[35m |_|  |_|_____|_____/|______\033[97m/_/    \\_\\\033[92m_____|\033[94m______\033[91m|_|  |_|\033[97m\n");

    std::string version = "  v" + std::to_string( HIDEAGEM_VERSION_MAJOR ) +
        "." + std::to_string( HIDEAGEM_VERSION_MAJOR ) + " " + HIDEAGEM_VERSION_NAME;

    const int space_add = 21 - (int)version.size();

    for (int i = 0; i < space_add; ++i)
    {
        version += " ";
    }

    std::cout << "                      \033[92m____ ______ ____";

    std::cout << "\n\033[97m" << version << "\033[92m/    /      \\    \\\033[97m  WWW.CYBER\033[92mG\033[94mE\033[31mM\033[97m.NET";

    printf("\033[92m"); // Bright Green
printf(R"(
                    /___ /________\ ___\
)");
    printf("\033[94m"); // Bright Blue
printf(R"(                    \    \        /    /
                      \   \      /   /
)");
    printf("\033[91m"); // Bright Red
printf(R"(                        \  \    /  /
                          \ \  / /
                             \/

)");

    SHOW_TERM_CURSOR();
    RESET_TERM_CURSOR(); // Reset term cursor colors
}

}; // namespace HideAGemCore

//
//    HIDEAGEM C WRAPPER FOR PYTHON
//

// Returns a pointer to Gem Ocean data.
// WARNING !!! Caller is responsible for freeing Gem Ocean memory !
uint8_t* HIDEAGEM_HIDE_GEMS_C(
    int gem_protocol,
    void* ocean,
    uint64_t ocean_size,
    const char** file_paths,
    int file_paths_length,
    const char* password,
    int time_trap,
    uint64_t* out_ocean_size,
    bool b_validate
)
{
    if ( ocean == nullptr )
    {
        std::cerr << "Ocean is nullptr.\n\n";

        return nullptr;
    }
    else if ( out_ocean_size == nullptr )
    {
        std::cerr << "Out Ocean size is nullptr.\n\n";

        return nullptr;
    }
    else if ( file_paths == nullptr )
    {
        std::cerr << "Gem File paths are nullptr.\n\n";

        return nullptr;
    }
    else if ( out_ocean_size == nullptr )
    {
        std::cerr << "Out Ocean size is nullptr.\n\n";

        return nullptr;
    }

    std::vector<std::string> file_paths_vec;

    for (int i = 0; i < file_paths_length; ++i)
    {
        file_paths_vec.push_back(std::string(file_paths[i]));
    }

    std::string password_str(password);
    HideAGemCore::EGemErrorCode error_code;

    HideAGemCore::GemOcean out_ocean = HideAGemCore::hide_gems(
        gem_protocol,
        ocean,
        ocean_size,
        { file_paths_vec },
        { password_str },
        { time_trap },
        b_validate
    );

    // TODO return error_code

    if ( ! out_ocean.is_valid() )
    {
        *out_ocean_size = 0;

        return nullptr;
    }

    // Finalize Gem Ocean data (e.g. write pixel data to PNG image file)
    out_ocean.finalize();
    *out_ocean_size = out_ocean.size(); // Must call after finalize()

    // WARNING !!! Caller is now responsible for freeing Ocean memory !
    return out_ocean.take();
}


// Returns a pointer to Gem Ocean data.
// WARNING !!! Caller is responsible for freeing Gem Ocean memory !
uint8_t* HIDEAGEM_HIDE_GEMS_32_BIT_C(
    int gem_protocol,
    void* ocean,
    uint32_t ocean_size,
    const char** file_paths,
    int file_paths_length,
    const char* password,
    int time_trap,
    uint32_t* out_ocean_size,
    bool b_validate
)
{
    uint64_t _out_ocean_size = 0;

    uint8_t* out_ocean = HIDEAGEM_HIDE_GEMS_C(
        gem_protocol,
        ocean,
        ocean_size,
        file_paths,
        file_paths_length,
        password,
        time_trap,
        &_out_ocean_size,
        b_validate
    );

    *out_ocean_size = _out_ocean_size;

    return out_ocean;
}


// Returns a pointer to Gem Ocean data.
// WARNING !!! Caller is responsible for freeing Gem Ocean memory !
uint8_t* HIDEAGEM_HIDE_GEM_FILES_C(
    int gem_protocol,
    void* ocean,
    uint64_t ocean_size,
    const uint8_t** gem_files,
    const uint64_t* gem_file_sizes,
    const char** gem_file_names,
    const uint64_t num_gem_files,
    const char* password,
    int time_trap,
    uint64_t* out_ocean_size,
    bool b_validate
)
{
    if ( ocean == nullptr )
    {
        std::cerr << "Ocean is nullptr.\n\n";

        return nullptr;
    }
    else if ( out_ocean_size == nullptr )
    {
        std::cerr << "Out Ocean size is nullptr.\n\n";

        return nullptr;
    }
    else if ( gem_files == nullptr )
    {
        std::cerr << "Gem Files are nullptr.\n\n";

        return nullptr;
    }
    else if ( gem_file_sizes == nullptr )
    {
        std::cerr << "Gem File sizes are nullptr.\n\n";

        return nullptr;
    }
    else if ( out_ocean_size == nullptr )
    {
        std::cerr << "Out Ocean size is nullptr.\n\n";

        return nullptr;
    }

    std::string password_str(password);
    HideAGemCore::EGemErrorCode error_code;

    std::vector<HideAGemCore::GemFile> _gem_files;

    for (int i = 0; i < num_gem_files; ++i)
    {
        _gem_files.push_back(
            HideAGemCore::GemFile( gem_files[i], gem_file_sizes[i], gem_file_names[i], false /* b_pack */ )
        );
    }

    HideAGemCore::GemOcean out_ocean = HideAGemCore::hide_gems(
        gem_protocol,
        ocean,
        ocean_size,
        _gem_files,
        password_str,
        time_trap,
        b_validate
    );

    // TODO return error_code

    if ( ! out_ocean.is_valid() )
    {
        *out_ocean_size = 0;

        return nullptr;
    }

    // Finalize Gem Ocean data (e.g. write pixel data to PNG image file)
    out_ocean.finalize();
    *out_ocean_size = out_ocean.size(); // Must call after finalize()

    // WARNING !!! Caller is now responsible for freeing Ocean memory !
    return out_ocean.take();
}


// Returns a pointer to Gem Ocean data.
// WARNING !!! Caller is responsible for freeing Gem Ocean memory !
uint8_t* HIDEAGEM_HIDE_GEM_FILES_32_BIT_C(
    int gem_protocol,
    void* ocean,
    uint32_t ocean_size,
    const uint8_t** gem_files,
    const uint32_t* gem_file_sizes,
    const char** gem_file_names,
    const uint32_t num_gem_files,
    const char* password,
    int time_trap,
    uint32_t* out_ocean_size,
    bool b_validate
)
{
    uint64_t _out_ocean_size = 0;

    std::vector<uint64_t> sizes_64;
    for (int i = 0; i < num_gem_files; ++i)
    {
        sizes_64.push_back( static_cast<uint64_t>( gem_file_sizes[i] ) );
    }

    uint8_t* out_ocean = HIDEAGEM_HIDE_GEM_FILES_C(
        gem_protocol,
        ocean,
        ocean_size,
        gem_files,
        sizes_64.data(),
        gem_file_names,
        num_gem_files,
        password,
        time_trap,
        &_out_ocean_size,
        b_validate
    );

    *out_ocean_size = _out_ocean_size;

    return out_ocean;
}


void HIDEAGEM_FIND_GEMS_C(
    void* ocean,
    uint64_t ocean_size,
    const char* password,
    const char* output_dir,
    bool b_time_trap
)
{
    std::string password_str(password);

    std::string output_dir_str;
    std::string* optional_output_dir = nullptr;

    if ( output_dir != nullptr )
    {
        output_dir_str = std::string( output_dir );
        optional_output_dir = &output_dir_str;
    }

    FOUND_GEM_FILES_C =
        HideAGemCore::find_gems(
            ocean,
            ocean_size,
            { password_str },
            optional_output_dir,
            { b_time_trap }
        );
}


void HIDEAGEM_FIND_GEMS_32_BIT_C(
    void* ocean,
    uint32_t ocean_size,
    const char* password,
    const char* output_dir,
    bool b_time_trap
)
{
    HIDEAGEM_FIND_GEMS_C(
        ocean,
        ocean_size,
        password,
        output_dir,
        b_time_trap
    );
}


void HIDEAGEM_ACTIVATE_DEMO_MODE_C()
{
    HideAGemCore::RUN_UNIT_TESTS(true, true);
}


bool HIDEAGEM_RUN_UNIT_TESTS_C(
    bool b_loop,
    bool b_demo_mode
)
{
    return HideAGemCore::RUN_UNIT_TESTS(
        b_loop,
        b_demo_mode
    );
}


HIDEAGEM_DLL_EXPORT void HIDEAGEM_FREE_OCEAN_C(void* ocean)
{
    if ( ocean != nullptr )
    {
        free( ocean );
    }
}

