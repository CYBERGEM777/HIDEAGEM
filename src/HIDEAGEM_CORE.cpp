//
//  888    888 8888888 8888888b.  8888888888        d8888  .d8888b.  8888888888 888b     d888
//  888    888   888   888  "Y88b 888              d88888 d88P  Y88b 888        8888b   d8888
//  888    888   888   888    888 888             d88P888 888    888 888        88888b.d88888
//  8888888888   888   888    888 8888888        d88P 888 888        8888888    888Y88888P888
//  888    888   888   888    888 888           d88P  888 888  88888 888        888 Y888P 888
//  888    888   888   888    888 888          d88P   888 888    888 888        888  Y8P  888
//  888    888   888   888  .d88P 888         d8888888888 Y88b  d88P 888        888   "   888
//  888    888 8888888 8888888P"  8888888888 d88P     888  "Y8888P88 8888888888 888       888
// ▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄
// ▄    ____ ______ ____                                      ▄                              ▄
// █   /    /      \    \   HIDEAGEM STEGANOGRAPHY PLATFORM   █                  .     .     █
// █  /___ /________\ ___\                                    █   .-.   .-.      '.___.'     █
// █  \    \        /    /  ASTRAL SOFTWARE FROM THE FUTURE   █  (_  \ /  _)     .'   `.     █
// █    \   \      /   /                                      █       |         :       :    █
// █      \  \    /  /      COPYRIGHT 2024 WWW.CYBERGEM.NET   █       |         :       :    █
// █        \ \  / /                                          █       |          `.___.'     █
// █           \/           LET'S DO COMPUTER STUFF ALL DAY   █                              █
// █                                                          █                              █
// █ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀ █    ._____.         .--.      █
// █ MMMMMSSSSSSSSSSSSSSSSSSSSSSSSSSddMMMMMSSSSSSMSSSSSSSSSS; █      | |          /   _`.    █
// █ MMMMSSSSSSSSSSSSSSSSSMSSSSS; ;SSdMMMMSSSSSSMMSSSSSSSSSS, █      | |         (_) ( )     █
// █ MMSSSSSSSMSSSSSMSSSSMMMSS."-.-":MMMMMSSSSMMMMSSMSSSMMSS  █     _|_|_       '.    /      █
// █ MSSSSSSSMSSSSMMMSSMMMPTMM;"-/\":MMM^"     MMMSSMMMSSMM   █    '     '        `--'       █
// █ SSSSSSSMMSSMMMMMMMMMP-.MMM :  ;.;P       dMMMMMMMMMP'    █                              █
// █ SSMSSSMMMSMMMMMMMMMP   :M;`:  ;.'+"""t+dMMMMMMMMMMP      █                _             █
// █ MMMSSMMMMMMMMPTMMMM"""":P `.\// '    ""^^MMMMMMMP'       █      .--.     ' `:--.--.     █
// █ MMMMMMPTMMMMP="TMMMsg,      \/   db`c"  dMMMMMP"         █     (    )       |  |  |_    █
// █ MMMMMM  TMMM   d$$$b ^          /T$; ;-/TMMMP'  Let's    █    (_)  /        |  |  | )   █
// █ MMMMM; .^`M; d$P^T$$b          :  $$ ::MMMMP  hide some  █        (_,       |  |  |/    █
// █ MMMMMM   .-+d$$   $$$;         ;. $$ ;;MMMP,    Gems !   █                       (J     █
// █ MMMMMMb   _d$$$   $$$$         :$$$; :MMMMMMp.           █                              █
// █ MMMMMM"  " T$$$._.$$$;          T$P.'MMMSSSSSSb          █                _             █
// █ MMM`TMb   -")T$$$$$$P'       `._ ""  :MMSSSMMP'          █       __      ' `:--.--.     █
// █ MMM / \    '  "T$$P"           /     :MMMMMMP'           █  ___.'  '.___    |  |  |     █
// █ MMSb`. ;                      "      :MMMMMM'            █  ____________    |  |  |     █
// █ MMSSb_lSSSb.             .___.       MMMMMP ,d88b.d88b,  █                  |  |  | .., █
// █ MMMMSSSSSSSSb.                     .MMMMMM. 88888888888  █                        `--': █
// █ MMMMMMMMMMMSSSb                  .dMMMMMMMP `Y8888888Y'  █                              █
// █ MMMMMMMMMMMMMSS;               .dMMMMMMMMMM'  `Y888Y'    █         ...             _    █
// █ MMMMGEMMAMMMMb`;"-.          .dMMMMMMMMMMP'     `Y'      █         .':     \      /_)   █
// █ MMMMMMMMMMMMMMb:   `'--.___.dMMMMMMMMMPP'                █       .'         \    /`.    █
// █ MMMMMMMMMMMMMMMb;           dMMMMMMMMPPR                 █   `..'            \  /   ;   █
// █ ▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄ █   .'`.             \/ __.'   █
// █                                                          █                              █
// █          ░░░░░░░░          ▒▒▒▒▒▒▒▒          ░░░░░░░░    █                              █
// █       ▓▓▓░░ ████████    ███▒▒ ▓▓▓▓▓▓▓▓    ▓▓▓░░ ████████ █                 `-.    .-'   █
// █    ▒▒▒▓▓ ░░ ██ ▒▒▒▒▒▒░░░██ ▒▒ ▓▓ ░░░░░░▒▒▒▓▓ ░░ ██+§¥µ██ █ .-"-._.-"-._.-     :  :      █
// █ ███▒▒ ▓▓ ░░░██ ▒▒ ▓▓▓░░ ██ ▒▒▒▓▓ ░░ ███▒▒ ▓▓ ░░░██$@¢¶██ █ .-"-._.-"-._.-   --:--:--    █
// █ ██ ▒▒ ▓▓▓▓▓▓███▒▒ ▓▓ ░░ ██████▓▓▓░░ ██ ▒▒ ▓▓▓▓▓▓████████ █                    :  :      █
// █ ██ ▒▒▒▒▒▒▒▒    ▒▒▒▓▓ ░░░░░░░░    ░░░██ ▒▒▒▒▒▒▒▒          █                 .-'    `-.   █
// █ ████████          ▓▓▓▓▓▓▓▓          ████████    CYBERGEM █                              █
// ▀                                                          ▀                              ▀
// ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀

#include "HIDEAGEM_CORE.h"
#include "HIDEAGEM.h"

#include <chrono>
#include <cstdio>
#include <thread>
#include <fstream>
#include <iostream>
#include <filesystem>

//
//    HIDEAGEM CORE
//

namespace HIDEAGEM_CORE {

///
//    HIDEAGEM CORE API

// TODO version of hide_gems() that does not create copy of ocean

// Returns Gem Ocean of out_ocean_size bytes if successful, or nullptr on failure.
//
// Caller is responsible for freeing returned Gem Ocean memory.
GemOcean hide_gems(
    int gem_protocol,
    const void* ocean,
    const uint64_t ocean_size,
    std::vector<GemFile>& gem_files,
    const std::string& password,
    int time_trap,
    bool b_validate
)
{
    ///
    //    WELCOME TO HIDEAGEM !!!

    PRINT_SPLASH_SCREEN();

    // Ocean
    if (ocean == nullptr)
    {
        PRINT_ERROR("ERROR: Ocean is nullptr.");

        return GemOcean( EGemErrorCode::BAD_ARGUMENT );
    }
    else if (ocean_size == 0)
    {
        PRINT_ERROR("ERROR: Ocean has size of 0.");

        return GemOcean( EGemErrorCode::BAD_ARGUMENT );
    }
    else if (gem_files.size() == 0)
    {
        PRINT_ERROR("ERROR: Gem file paths are empty.");

        return GemOcean( EGemErrorCode::BAD_ARGUMENT );
    }

    ///
    //    INIT SHARED OCEAN

    GemOcean SHARED_OCEAN( ocean, ocean_size );

    if ( ! SHARED_OCEAN.is_valid() )
    {
        PRINT_ERROR("Could not initialize Gem Ocean.");

        return GemOcean( EGemErrorCode::INVALID_OCEAN );
    }

    ///
    //    HIDE GEMS

    const std::string ocean_size_str = HIDEAGEM_CORE::bytes_to_size_string( SHARED_OCEAN.size() );
    PRINT("Starting Gem hide in Ocean of size %llu bytes [ %s ]", SHARED_OCEAN.size(), ocean_size_str.c_str());

    HideAGem hag( SHARED_OCEAN );

    const bool b_hid_gem = hag.hide_gem_files(
        gem_protocol,
        gem_files,
        password,
        time_trap,
        b_validate
    );

    if ( ! b_hid_gem ) // Error ?
    {
        return GemOcean( hag.get_error_code() );
    }

    return SHARED_OCEAN;
}


GemOcean hide_gems(
    int gem_protocol,
    const void* ocean,
    const uint64_t ocean_size,
    const std::vector<std::vector<std::string>>& file_paths,
    const std::vector<std::string>& passwords,
    const std::vector<int> time_traps,
    bool b_validate
)
{
    ///
    //    WELCOME TO HIDEAGEM !!!

    PRINT_SPLASH_SCREEN();

    // Ocean
    if (ocean == nullptr)
    {
        PRINT_ERROR("ERROR: Ocean is nullptr.");

        return GemOcean( EGemErrorCode::BAD_ARGUMENT );
    }
    else if (ocean_size == 0)
    {
        PRINT_ERROR("ERROR: Ocean has size of 0.");

        return GemOcean( EGemErrorCode::BAD_ARGUMENT );
    }
    // Passwords
    else if (passwords.size() == 0)
    {
        PRINT_ERROR("ERROR: Empty passwords.");

        return GemOcean( EGemErrorCode::BAD_ARGUMENT );
    }
    // File paths
    else if (file_paths.size() == 0)
    {
        PRINT_ERROR("ERROR: Gem file paths are empty.");

        return GemOcean( EGemErrorCode::BAD_ARGUMENT );
    }
    else if (file_paths.size() != passwords.size())
    {
        PRINT_ERROR("ERROR: Number of passwords does not match number of file path vectors.");

        return GemOcean( EGemErrorCode::BAD_ARGUMENT );
    }

    ///
    //    INIT SHARED OCEAN

    GemOcean SHARED_OCEAN( ocean, ocean_size );

    if ( ! SHARED_OCEAN.is_valid() )
    {
        PRINT_ERROR("Could not initialize Gem Ocean.");

        return GemOcean( EGemErrorCode::INVALID_OCEAN );
    }

    ///
    //    HIDE GEMS

    const std::string ocean_size_str = HIDEAGEM_CORE::bytes_to_size_string( SHARED_OCEAN.size() );
    PRINT("Starting Gem hide in Ocean of size %llu bytes [ %s ] with %u %s.",
	    SHARED_OCEAN.size(), ocean_size_str.c_str(),
        (uint32_t)passwords.size(), passwords.size() > 1 ? "passwords" : "password");

    // Hide Gems at all password layers
    for (int i = 0; i < passwords.size(); ++i)
    {
        if (passwords.size() > 1)
        {
            const uint64_t num_gem_files = file_paths[i].size();

            PRINT("Password %d: Hiding %llu Gem %s ",
                i + 1, num_gem_files, num_gem_files > 1 ? "Files" : "File");
        }

        HideAGem hag( SHARED_OCEAN );

        const int time_trap = i < time_traps.size() ? time_traps[i] : -1;

        const bool b_hid_gem = hag.hide_gem_files(
            gem_protocol,
            file_paths[i],
            passwords[i],
            time_trap,
            b_validate
        );

        if ( ! b_hid_gem ) // Error ?
        {
            return GemOcean( hag.get_error_code() );
        }
    }

    return SHARED_OCEAN;
}


std::vector<GemFile> find_gems(
    const void* ocean, 
    uint64_t ocean_size,
    const std::vector<std::string>& passwords,
    const std::string* output_dir,
    const std::vector<bool> time_traps
)
{
    ///
    //    WELCOME TO HIDEAGEM !!!

    PRINT_SPLASH_SCREEN(); // It's Ocean time !!!

    std::vector<GemFile> gem_files;

    ///
    //    INIT SHARED OCEAN

    GemOcean SHARED_OCEAN( ocean, ocean_size );

    if ( ! SHARED_OCEAN.is_valid() )
    {
        PRINT_ERROR("Could not initialize Ocean.");

        return gem_files;
    }

    ///
    //    FIND GEMS !!!

    const std::string ocean_size_str = HIDEAGEM_CORE::bytes_to_size_string( SHARED_OCEAN.size() );
    PRINT("Starting Gem find in Ocean of size %llu bytes [ %s ]", SHARED_OCEAN.size(), ocean_size_str.c_str());

    const auto start_time = std::chrono::high_resolution_clock::now();

    // For each password, search for gem files in ocean
    for (uint64_t i = 0; i < passwords.size(); ++i)
    {
        if (passwords.size() > 1)
        {
            PRINT("Searching with password %llu.", i + 1);
        }

        try
        {
            HideAGem hag( SHARED_OCEAN );

            const bool b_time_trap = i < time_traps.size() ? time_traps[i] : false;

            const uint64_t num_found = hag.find_gem_files(
                passwords[i],
                gem_files,
                b_time_trap
            );

            if (num_found > 0)
            {
                PRINT("Found %llu %s with password %llu ",
                    num_found, num_found > 1 ? "Gems" : "Gem", i + 1);

                continue; // Success !
            }

            switch ( hag.get_error_code() ) // PROCESS ERROR
            {
                case EGemErrorCode::EXIT_SIGNAL :
                case EGemErrorCode::GEM_STREAM_DECOMPRESSION_ABORTED :

                    return gem_files; // E X I T

                default :

                    break;
            }
        }
        catch (const _EXCEPTION& e)
        {
            std::cerr << e.what() << std::endl << std::endl;

            break;
        }
        catch(const std::exception& e)
        {
            std::cerr << e.what() << std::endl << std::endl;

            break;
        }
        catch( ... )
        {
            PRINT("Caught unknown exception!");

            break;
        }
    }

    auto stop_time = std::chrono::high_resolution_clock::now();
    std::chrono::duration<double> time_duration = stop_time - start_time;
    const double   time_s = time_duration.count();
    const uint64_t time_m = (uint64_t)(time_s / 60);
    const char* files_str = gem_files.size() > 1 ? "FILES" : "FILE";

    if ( gem_files.size() == 0 ) // WOW REKT !!! >_< </3
    {
        PRINT_ERROR("*** FOUND ZERO GEM FILES ***");

        goto NO_MAGIC_WORD; // </3 !
    }

    // Found gem files !!! ^_^ <3 <3 <3

    if ( output_dir == nullptr )
    {
        PRINT_WARNING("No output directory specified. Nothing saved to disk.");

        goto GEM_FIND_SUCCESS; // Done !
    }

    ///
    //    OPTIONALLY SAVE GEM FILES TO DISK

    {

    std::string save_path = *output_dir;
    const std::filesystem::path _save_path(save_path);
    save_path = _save_path.lexically_normal().string(); // Normalize file path

    if ( ! std::filesystem::exists( save_path ) ) // Create output directory ?
    {
        PRINT_WARNING("Create directory %s and save %llu Gem %s ?", save_path.c_str(),
            (uint64_t)gem_files.size(), gem_files.size() > 1 ? "Files" : "File" );

        if ( STDIN_YES_OR_NO() ) // <-- Blocks thread
        {
            PRINT("Creating directory: %s", save_path.c_str());
            std::filesystem::create_directories( save_path );
        }
        else
        {
            PRINT("Output directory not created. No Gem Files saved to disk.");

            goto GEM_FIND_SUCCESS;
        }
    }
    else
    {
        PRINT_WARNING("Save %llu Gem %s to directory %s ?",
            (uint64_t)gem_files.size(), gem_files.size() > 1 ? "Files" : "File", save_path.c_str()
        );

        if ( ! STDIN_YES_OR_NO() ) // <-- Blocks thread
        {
            PRINT("No Gem Files saved to disk.");

            goto GEM_FIND_SUCCESS;
        }
    }

    // --

    if ( ! std::filesystem::is_directory( save_path ) ) // Is destination a directory ?
    {
        PRINT_ERROR("Invalid output directory (not a directory): %s", save_path.c_str());

        goto GEM_FIND_SUCCESS;
    }

#ifdef _WIN32   // Ensure trailing slash
    if (save_path.back() != '\\') save_path.push_back('\\');
#else 
    if (save_path.back() != '/') save_path.push_back('/');
#endif
    
    for (const auto& gem_file : gem_files)
    {
        std::string file_name = gem_file.name();
        std::string file_ext;

        const size_t dot_pos = file_name.rfind('.');
        if (dot_pos != std::string::npos)
        {
            file_ext = file_name.substr(dot_pos + 1);
            file_name = file_name.substr(0, dot_pos);
        }

        std::string file_path = save_path + file_name + "." + file_ext;
        int file_num = 1;

        // Prevent over-writing files
        while(std::ifstream(file_path).is_open())
        {
            file_path = save_path + file_name + "_" + std::to_string(file_num) +  "." + file_ext;
            ++file_num;
        }

        std::ofstream out_file(file_path, std::ios::binary);

        if (!out_file)
        {
            std::cerr << "Failed to open file: " << file_path << std::endl;
            continue;
        }

        out_file.write(reinterpret_cast<const char*>(gem_file.data()), gem_file.size());
        out_file.close();

        PRINT_NO_NEWLINE("Saved file: %s \n", file_path.c_str());
    }

    printf("\n");

    }

GEM_FIND_SUCCESS:
    
    // <3 !!! ^_^

    if (time_m < 1)
    {
        PRINT_SUCCESS("*** FOUND %llu GEM %s IN %.2fs ***",
            (uint64_t)gem_files.size(), files_str, time_s);
    }
    else
    {
        PRINT_SUCCESS("*** FOUND %llu GEM %s IN %llum %.2fs ***",
            (uint64_t)gem_files.size(), files_str, time_m, time_s);
    }

NO_MAGIC_WORD:

    return gem_files; // E X I T
}

///
//    DEBUG ZONE

bool RUN_UNIT_TESTS(bool b_loop, bool b_demo_mode)
{
    INIT_SIGNAL_WATCHERS() // Init system signal watchers (e.g. SIGINT)

    //
    //    NOTE: These tests are not exhaustive !
    //

    constexpr int    start_protocol   = 0;
    constexpr int    end_protocol     = 0;
    constexpr size_t min_password_len = 1;
    constexpr size_t max_password_len = 1024;
    constexpr size_t file_name_len    = 43;

    DragonRNG rng; // True random RNG

    auto rand_password = [&]() // Local function
    {
        std::string password;
        const size_t len = rng.rand_range(max_password_len, min_password_len);

        for (size_t k = 0; k < len; ++k)
        {
            password += (char)rng.rand_range((uint8_t)255, (uint8_t)32);
        }

        return password;
    };

    auto rand_filename = [&]() // Local function
    {
        std::string filename;

        for (size_t k = 0; k < file_name_len; ++k)
        {
            filename += (char)rng.rand_range((uint8_t)90, (uint8_t)65);
        }

        return filename;
    };

    bool b_error = false;

    //
    //    ** DEMO MODE ( SLOW MODE ) **
    //

    while ( b_demo_mode )
    {
        const int demo_time_ms = 6000;

        const uint64_t start_byte = 311111;
        const uint64_t ocean_size = 1024 * 350; // 350 KB
        GhostVector<uint8_t> ocean_vec( ocean_size );
        uint8_t* ocean = ocean_vec.data();

        ///
        //    SINGLE PASSWORD + SINGLE FILE

        for (int gem_bytes = start_byte; gem_bytes < ocean_size; gem_bytes += 1)
        {
            if ( EXIT_SIGNAL ) return true; // E X I T  S I G N A L

            std::vector<GemFile> gem_files;
            gem_files.push_back( GemFile( gem_bytes ) );
            GemFile& gem_file = gem_files.back();
            gem_file.set_name(  rand_filename() );
            TRUE_RANDOM::rand_bytes( gem_file.data(), gem_file.size() );

            //
            //    HIDE GEMS
            //

            auto gem_ocean = hide_gems(
                0, // Auto Gem Protocol
                ocean,
                ocean_size,
                gem_files,
                rand_password()
            );

            if (gem_ocean.get_error() == EGemErrorCode::NOT_ENOUGH_SPACE)
            {
                gem_bytes = 0; // Restart demo cycle !

                continue;
            }
            else if (gem_ocean.get_error() != EGemErrorCode::NONE)
            {
                return false; // E X I T...
            }

            auto start_time = std::chrono::high_resolution_clock::now();

            for (;;)
            {
                if ( EXIT_SIGNAL ) return true; // E X I T  S I G N A L

                auto end_time = std::chrono::high_resolution_clock::now();
                std::chrono::duration<double, std::milli> elapsed = end_time - start_time;

                if (elapsed.count() >= demo_time_ms) break;

                std::this_thread::sleep_for(std::chrono::milliseconds(1));
            }
        }
    }

    //
    //    *** END DEMO MODE ***
    //

UNIT_LOOP:

    ///
    //    BEGIN UNIT TESTS

    PRINT("\nBEGIN HIDEAGEM UNIT TESTS");

    //
    //    CYCLE KEY
    //

    /*    <--  DISABLE
    PRINT("BEGINNING CYCLE KEY UNIT TESTS ");

    const int num_keys = max_password_len - min_password_len + 1;

    std::vector<int> _keys(num_keys);
    std::iota(_keys.begin(), _keys.end(), 1);
    std::atomic<bool> b_key_error(false);

    // TIME
    const auto start_time = std::chrono::high_resolution_clock::now();
    auto stop_time = std::chrono::high_resolution_clock::now();
    std::chrono::duration<double> time_duration;
    double time_s = 0;

    std::for_each(std::execution::par, _keys.begin(), _keys.end(), [&](int password_len)
    {
        CycleKey _key;
        uint8_t* _salt = _key.salt_write();

        for (int j = 0; j < _key.salt_size(); ++j)
        {
            _salt[j] = TRUE_RANDOM::rand_byte();
        }

        try
        {
            _key.init( rand_password() );
        }
        catch (const _EXCEPTION& e)
        {
            std::cerr << e.what() << std::endl << std::endl;
            PRINT_ERROR("*** FAILED TO GENERATE CYCLE KEY ***");
            b_key_error = true;
        }
        catch ( ... )
        {
            b_key_error = true;
            PRINT_ERROR("*** UNKNOWN ERROR *** ");
            PRINT_ERROR("*** FAILED TO GENERATE CYCLE KEY ***");
        }
    });

    if (b_key_error)
    {
        return false; // E X I T
    }

    // TIME
    stop_time = std::chrono::high_resolution_clock::now();
    time_duration = stop_time - start_time;
    time_s = time_duration.count();

    PRINT("Took %.4f seconds to generate %d keys in parallel.", time_s, num_keys);

    PRINT_SUCCESS("CYCLE KEY UNIT TESTS COMPLETE !!!");

    //
    //    GEM FILE
    //

    PRINT("BEGINNING GEM FILE UNIT TESTS ");

    for (size_t file_size = 1; file_size < 1024; ++file_size)
    {
        if ( EXIT_SIGNAL )
        {
            return true; // E X I T
        }

        std::string file_path = DEBUG_DIR + rand_filename();

        // Check if directory exists
        std::filesystem::path dir_path(std::filesystem::path(file_path).parent_path());

        // Write the random bytes to file
        std::vector<unsigned char> random_bytes(file_size);
        for (auto &byte : random_bytes)
        {
            byte = static_cast<unsigned char>(rng.rand());
        }

        std::ofstream output_file(file_path, std::ios::out | std::ios::binary);
        if (output_file.is_open())
        {
            output_file.write(reinterpret_cast<const char *>(random_bytes.data()), random_bytes.size());
            output_file.close();
        }
        else
        {
            PRINT_ERROR("Failed to open file for writing: %s", file_path.c_str());

            return false; // E X I T
        }

        GemFile _file( file_path );

        std::filesystem::remove( file_path ); // Delete test file
    }

    PRINT_SUCCESS("GEM FILE UNIT TESTS COMPLETE !!!");

    DISABLE  -->    */

    //
    //    OCEAN PARAMETERS
    //

    const uint64_t start_byte = 1;
    const uint64_t ocean_size = 1024 * 10; // 10 KB
    GhostVector<uint8_t> ocean_vec( ocean_size );
    uint8_t* ocean = ocean_vec.data();

    //
    //    SINGLE PASSWORD SINGLE FILE
    //

    for (int gem_bytes = start_byte; gem_bytes < ocean_size; gem_bytes += 1)
    {
        const size_t file_size = gem_bytes;

        for (int gem_protocol_key = start_protocol; gem_protocol_key <= end_protocol; ++gem_protocol_key)
        {
            if ( EXIT_SIGNAL ) return true; // E X I T  S I G N A L

            PRINT("SINGLE PASSWORD SINGLE FILE :: %d BYTES :: GEM PROTOCOL %d \n", gem_bytes, gem_protocol_key);

            std::vector<GemFile> gem_files;
            gem_files.push_back( GemFile( gem_bytes ) );
            GemFile& gem_file = gem_files.back();
            gem_file.set_name(  rand_filename() );
            TRUE_RANDOM::rand_bytes( gem_file.data(), gem_file.size() );

            const std::string password = rand_password();

            //
            //    HIDE GEMS
            //

            auto gem_ocean = hide_gems(
                0, // Auto Gem Protocol
                ocean,
                ocean_size,
                gem_files,
                rand_password(),
                true // b_validate
            );

            if (gem_ocean.get_error() == EGemErrorCode::NOT_ENOUGH_SPACE)
            {
                break;
            }
            else if (gem_ocean.get_error() == EGemErrorCode::EXIT_SIGNAL)
            {
                return true; // E X I T  S I G N A L
            }
            else if (gem_ocean.get_error() != EGemErrorCode::NONE)
            {
                b_error = true;
                break;
            }

            PRINT_SUCCESS("*** ALL READ GEM FILES MATCH DISK FILES: GEM PROTOCOL %d ***",
                gem_protocol_key); // <3 !!!
        }

        if (b_error)
        {
            break; // E X I T
        }
    }

    if (b_error)
    {
        PRINT_ERROR("*** SOME UNIT TESTS FAILED ***");

        return false; // E X I T
    }

    //
    //    SINGLE PASSWORD + MULTIPLE FILES
    //

    {
    int num_files = 100;
    int max_bytes = (int)ocean_size;
    int byte_skip = (int)ocean_size / 25;

    for (int gem_bytes = start_byte; gem_bytes < max_bytes; gem_bytes += byte_skip)
    {
        const size_t file_size = gem_bytes < num_files ? gem_bytes : gem_bytes / num_files;

        for (int gem_protocol_key = start_protocol; gem_protocol_key <= end_protocol; ++gem_protocol_key)
        {
            if ( EXIT_SIGNAL )
            {
                return true; // E X I T
            }

            PRINT("SINGLE PASSWORD + MULTIPLE FILES :: %d BYTES :: GEM PROTOCOL %d \n", gem_bytes, gem_protocol_key);

            std::vector<GemFile> gem_files;
            const std::string password = rand_password();

            for (int j = 0; j < num_files; ++j)
            {
                // Add new Gem File
                gem_files.push_back( GemFile( gem_bytes ) );
                GemFile& gem_file = gem_files.back();
                gem_file.set_name(  rand_filename() );
                TRUE_RANDOM::rand_bytes( gem_file.data(), gem_file.size() );

                //
                //    HIDE GEMS
                //

                auto gem_ocean = hide_gems(
                    0, // Auto Gem Protocol
                    ocean,
                    ocean_size,
                    gem_files,
                    rand_password(),
                    true // b_validate
                );

                if (gem_ocean.get_error() == EGemErrorCode::NOT_ENOUGH_SPACE)
                {
                    break;
                }
                else if (gem_ocean.get_error() != EGemErrorCode::NONE)
                {
                    b_error = true;
                    break;
                }
            }

            if (b_error)
            {
                break; // E X I T
            }
            else
            {
                PRINT_SUCCESS("*** ALL READ GEM FILES MATCH DISK FILES: GEM PROTOCOL %d ***",
                    gem_protocol_key); // <3 !!!
            }
        }

        if (b_error)
        {
            break; // E X I T
        }
    }

    if (b_error)
    {
        PRINT_ERROR("*** SOME UNIT TESTS FAILED ***");

        return false; // E X I T
    }
    }

    if (b_error)
    {
        PRINT_ERROR("*** SOME UNIT TESTS FAILED ***");

        return false;
    }

    PRINT_SUCCESS("*** ALL UNIT TESTS RAN SUCCESSFULLY ***"); // <3 !!!

    ///
    //    LOOP

    if ( b_loop ) goto UNIT_LOOP;

    ///
    //    E X I T

    return true;
}

}; // namespace HIDEAGEM_CORE

