//
//  888    888 8888888 8888888b.  8888888888        d8888  .d8888b.  8888888888 888b     d888
//  888    888   888   888  "Y88b 888              d88888 d88P  Y88b 888        8888b   d8888
//  888    888   888   888    888 888             d88P888 888    888 888        88888b.d88888
//  8888888888   888   888    888 8888888        d88P 888 888        8888888    888Y88888P888
//  888    888   888   888    888 888           d88P  888 888  88888 888        888 Y888P 888
//  888    888   888   888    888 888          d88P   888 888    888 888        888  Y8P  888
//  888    888   888   888  .d88P 888         d8888888888 Y88b  d88P 888        888   "   888
//  888    888 8888888 8888888P"  8888888888 d88P     888  "Y8888P88 8888888888 888       888
// ▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄
// ▄    ____ ______ ____                                      ▄                              ▄
// █   /    /      \    \   HIDEAGEM STEGANOGRAPHY PLATFORM   █                  .     .     █
// █  /___ /________\ ___\                                    █   .-.   .-.      '.___.'     █
// █  \    \        /    /  ASTRAL SOFTWARE FROM THE FUTURE   █  (_  \ /  _)     .'   `.     █
// █    \   \      /   /                                      █       |         :       :    █
// █      \  \    /  /      COPYRIGHT 2024 WWW.CYBERGEM.NET   █       |         :       :    █
// █        \ \  / /                                          █       |          `.___.'     █
// █           \/           LET'S DO COMPUTER STUFF ALL DAY   █                              █
// █                                                          █                              █
// █ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀ █    ._____.         .--.      █
// █ MMMMMSSSSSSSSSSSSSSSSSSSSSSSSSSddMMMMMSSSSSSMSSSSSSSSSS; █      | |          /   _`.    █
// █ MMMMSSSSSSSSSSSSSSSSSMSSSSS; ;SSdMMMMSSSSSSMMSSSSSSSSSS, █      | |         (_) ( )     █
// █ MMSSSSSSSMSSSSSMSSSSMMMSS."-.-":MMMMMSSSSMMMMSSMSSSMMSS  █     _|_|_       '.    /      █
// █ MSSSSSSSMSSSSMMMSSMMMPTMM;"-/\":MMM^"     MMMSSMMMSSMM   █    '     '        `--'       █
// █ SSSSSSSMMSSMMMMMMMMMP-.MMM :  ;.;P       dMMMMMMMMMP'    █                              █
// █ SSMSSSMMMSMMMMMMMMMP   :M;`:  ;.'+"""t+dMMMMMMMMMMP      █                _             █
// █ MMMSSMMMMMMMMPTMMMM"""":P `.\// '    ""^^MMMMMMMP'       █      .--.     ' `:--.--.     █
// █ MMMMMMPTMMMMP="TMMMsg,      \/   db`c"  dMMMMMP"         █     (    )       |  |  |_    █
// █ MMMMMM  TMMM   d$$$b ^          /T$; ;-/TMMMP'  Let's    █    (_)  /        |  |  | )   █
// █ MMMMM; .^`M; d$P^T$$b          :  $$ ::MMMMP  hide some  █        (_,       |  |  |/    █
// █ MMMMMM   .-+d$$   $$$;         ;. $$ ;;MMMP,    Gems !   █                       (J     █
// █ MMMMMMb   _d$$$   $$$$         :$$$; :MMMMMMp.           █                              █
// █ MMMMMM"  " T$$$._.$$$;          T$P.'MMMSSSSSSb          █                _             █
// █ MMM`TMb   -")T$$$$$$P'       `._ ""  :MMSSSMMP'          █       __      ' `:--.--.     █
// █ MMM / \    '  "T$$P"           /     :MMMMMMP'           █  ___.'  '.___    |  |  |     █
// █ MMSb`. ;                      "      :MMMMMM'            █  ____________    |  |  |     █
// █ MMSSb_lSSSb.             .___.       MMMMMP ,d88b.d88b,  █                  |  |  | .., █
// █ MMMMSSSSSSSSb.                     .MMMMMM. 88888888888  █                        `--': █
// █ MMMMMMMMMMMSSSb                  .dMMMMMMMP `Y8888888Y'  █                              █
// █ MMMMMMMMMMMMMSS;               .dMMMMMMMMMM'  `Y888Y'    █         ...             _    █
// █ MMMMGEMMAMMMMb`;"-.          .dMMMMMMMMMMP'     `Y'      █         .':     \      /_)   █
// █ MMMMMMMMMMMMMMb:   `'--.___.dMMMMMMMMMPP'                █       .'         \    /`.    █
// █ MMMMMMMMMMMMMMMb;           dMMMMMMMMPPR                 █   `..'            \  /   ;   █
// █ ▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄ █   .'`.             \/ __.'   █
// █                                                          █                              █
// █          ░░░░░░░░          ▒▒▒▒▒▒▒▒          ░░░░░░░░    █                              █
// █       ▓▓▓░░ ████████    ███▒▒ ▓▓▓▓▓▓▓▓    ▓▓▓░░ ████████ █                 `-.    .-'   █
// █    ▒▒▒▓▓ ░░ ██ ▒▒▒▒▒▒░░░██ ▒▒ ▓▓ ░░░░░░▒▒▒▓▓ ░░ ██+§¥µ██ █ .-"-._.-"-._.-     :  :      █
// █ ███▒▒ ▓▓ ░░░██ ▒▒ ▓▓▓░░ ██ ▒▒▒▓▓ ░░ ███▒▒ ▓▓ ░░░██$@¢¶██ █ .-"-._.-"-._.-   --:--:--    █
// █ ██ ▒▒ ▓▓▓▓▓▓███▒▒ ▓▓ ░░ ██████▓▓▓░░ ██ ▒▒ ▓▓▓▓▓▓████████ █                    :  :      █
// █ ██ ▒▒▒▒▒▒▒▒    ▒▒▒▓▓ ░░░░░░░░    ░░░██ ▒▒▒▒▒▒▒▒          █                 .-'    `-.   █
// █ ████████          ▓▓▓▓▓▓▓▓          ████████    CYBERGEM █                              █
// ▀                                                          ▀                              ▀
// ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀

#pragma /* <3 */ once // upon a time ...

#include <vector>

#define SODIUM_STATIC = 1
#include <sodium.h>

#include "EXCEPTION.h"

//
//    GHOST VECTOR
//
//    Securely erases trivially destructible types, such as int, float, bool etc.
//    when erasing and popping elements, and upon destruction.

namespace HIDEAGEM_CORE {

template <typename T>
class GhostVector
{
public:

    using iterator       = typename std::vector<T>::iterator;
    using const_iterator = typename std::vector<T>::const_iterator;

    GhostVector() {}

    GhostVector(size_t size) : vec(size) {}

    GhostVector(size_t size, T init) : vec(size, init) {}

    GhostVector(std::initializer_list<T> initList) : vec(initList) {}

    template <class InputIterator>
    GhostVector(InputIterator first, InputIterator last) : vec(first, last) {}

    ~GhostVector()
    {
        secure_erase();
    }

    void push_back(const T& t) { vec.push_back(t); }

    void pop_back()
    {
        if constexpr (std::is_trivially_destructible<T>::value)
        {
            if (sodium_init() < 0)
            {
                throw _EXCEPTION("Failed to pop_back() GhostVector: libsodium could not be initialized.");
            }

            sodium_memzero(&back(), sizeof(T));
        }

        vec.pop_back();
    }

    T& front() { return vec.front(); }
    T& back()  { return vec.back();  }

    const T& front() const { return vec.front(); }
    const T& back()  const { return vec.back();  }

    T* data() { return vec.data(); }
    const T* data() const { return vec.data(); }

    void reserve(size_t size)
    {
        vec.reserve(size);
    }

    size_t size() const { return vec.size(); }

    void resize(size_t count)
    {
        if (count < vec.size())
        {
            secure_erase_from(count);
        }

        vec.resize(count);
    }

    void resize(size_t count, const T& value)
    {
        if (count < vec.size())
        {
            secure_erase_from(count);
        }

        vec.resize(count, value);
    }

    bool empty() const { return vec.empty(); }

    iterator erase(iterator pos)
    {
        if constexpr (std::is_trivially_destructible<T>::value)
        {
            if (sodium_init() < 0)
            {
                throw _EXCEPTION("Failed to erase() GhostVector: libsodium could not be initialized.");
            }

            sodium_memzero(&*pos, sizeof(T));
        }

        return vec.erase(pos);
    }

    void clear()
    {
        secure_erase();
        vec.clear();
    }

    void vanish()
    {
        clear();
        std::vector<T>().swap( vec );
    }

    std::vector<T>& vector() { return vec; }

    ///
    //    Read / write bytes from vector

    template<typename U>
    void append_bytes(U value)
    {
        for (int i = 0; i < sizeof(U); ++i)
        {
            uint8_t byte = static_cast<uint8_t>(value & 0xFF);
            push_back(byte);
            value >>= 8;
        }
    }

    template<typename U>
    void write_bytes_at(U value, size_t index)
    {
        if ( index + sizeof(U) >= size() )
        {
            throw _EXCEPTION("ERROR: GhostVector::write_bytes_at() :: Write operation exceeds vector size.");
        }

        for (int i = 0; i < sizeof(U); ++i)
        {
            (*this)[ index + i ] = static_cast<uint8_t>(value & 0xFF);
            value >>= 8;
        }
    }

    template<typename U>
    void read_bytes(U& out, size_t start) const
    {
        out = 0;
        for (int i = 0; i < sizeof(U); ++i)
        {
            uint64_t byte = (*this)[start + i];
            out |= (byte << (i * 8));
        }
    }

    iterator begin()
    {
        return vec.begin();
    }

    const_iterator begin() const
    {
        return vec.begin();
    }

    iterator end()
    {
        return vec.end();
    }

    const_iterator end() const
    {
        return vec.end();
    }

    T& operator[](size_t index)
    {
        return vec[index];
    }

    const T& operator[](size_t index) const
    {
        return vec[index];
    }

    GhostVector& operator=(std::initializer_list<T> init_list)
    {
        secure_erase();
        vec = init_list;

        return *this;
    }

private:

    std::vector<T> vec;

    void secure_erase()
    {
        if (sodium_init() < 0)
        {
            throw _EXCEPTION("Failed to secure erase GhostVector: libsodium could not be initialized.");
        }

        // Secure erase trivially destructible element types
        if constexpr (std::is_trivially_destructible<T>::value)
        {
            sodium_memzero(vec.data(), vec.size() * sizeof(T));
        }

        // TODO warn when not trivially destructible

        vec.resize(0); // This will call destructors
    }

    void secure_erase_from(size_t start_index)
    {
        if (sodium_init() < 0)
        {
            throw _EXCEPTION("Failed to secure erase GhostVector: libsodium could not be initialized.");
        }

        if ( start_index < vec.size() )
        {
            size_t bytes_to_erase = (vec.size() - start_index) * sizeof(T);
            sodium_memzero(vec.data() + start_index, bytes_to_erase);
        }
    }
};

}; // namespace HIDEAGEM_CORE

