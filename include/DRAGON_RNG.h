//
//  888    888 8888888 8888888b.  8888888888        d8888  .d8888b.  8888888888 888b     d888
//  888    888   888   888  "Y88b 888              d88888 d88P  Y88b 888        8888b   d8888
//  888    888   888   888    888 888             d88P888 888    888 888        88888b.d88888
//  8888888888   888   888    888 8888888        d88P 888 888        8888888    888Y88888P888
//  888    888   888   888    888 888           d88P  888 888  88888 888        888 Y888P 888
//  888    888   888   888    888 888          d88P   888 888    888 888        888  Y8P  888
//  888    888   888   888  .d88P 888         d8888888888 Y88b  d88P 888        888   "   888
//  888    888 8888888 8888888P"  8888888888 d88P     888  "Y8888P88 8888888888 888       888
// ▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄
// ▄    ____ ______ ____                                      ▄                              ▄
// █   /    /      \    \   HIDEAGEM STEGANOGRAPHY PLATFORM   █                  .     .     █
// █  /___ /________\ ___\                                    █   .-.   .-.      '.___.'     █
// █  \    \        /    /  ASTRAL SOFTWARE FROM THE FUTURE   █  (_  \ /  _)     .'   `.     █
// █    \   \      /   /                                      █       |         :       :    █
// █      \  \    /  /      COPYRIGHT 2024 WWW.CYBERGEM.NET   █       |         :       :    █
// █        \ \  / /                                          █       |          `.___.'     █
// █           \/           LET'S DO COMPUTER STUFF ALL DAY   █                              █
// █                                                          █                              █
// █ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀ █    ._____.         .--.      █
// █ MMMMMSSSSSSSSSSSSSSSSSSSSSSSSSSddMMMMMSSSSSSMSSSSSSSSSS; █      | |          /   _`.    █
// █ MMMMSSSSSSSSSSSSSSSSSMSSSSS; ;SSdMMMMSSSSSSMMSSSSSSSSSS, █      | |         (_) ( )     █
// █ MMSSSSSSSMSSSSSMSSSSMMMSS."-.-":MMMMMSSSSMMMMSSMSSSMMSS  █     _|_|_       '.    /      █
// █ MSSSSSSSMSSSSMMMSSMMMPTMM;"-/\":MMM^"     MMMSSMMMSSMM   █    '     '        `--'       █
// █ SSSSSSSMMSSMMMMMMMMMP-.MMM :  ;.;P       dMMMMMMMMMP'    █                              █
// █ SSMSSSMMMSMMMMMMMMMP   :M;`:  ;.'+"""t+dMMMMMMMMMMP      █                _             █
// █ MMMSSMMMMMMMMPTMMMM"""":P `.\// '    ""^^MMMMMMMP'       █      .--.     ' `:--.--.     █
// █ MMMMMMPTMMMMP="TMMMsg,      \/   db`c"  dMMMMMP"         █     (    )       |  |  |_    █
// █ MMMMMM  TMMM   d$$$b ^          /T$; ;-/TMMMP'  Let's    █    (_)  /        |  |  | )   █
// █ MMMMM; .^`M; d$P^T$$b          :  $$ ::MMMMP  hide some  █        (_,       |  |  |/    █
// █ MMMMMM   .-+d$$   $$$;         ;. $$ ;;MMMP,    Gems !   █                       (J     █
// █ MMMMMMb   _d$$$   $$$$         :$$$; :MMMMMMp.           █                              █
// █ MMMMMM"  " T$$$._.$$$;          T$P.'MMMSSSSSSb          █                _             █
// █ MMM`TMb   -")T$$$$$$P'       `._ ""  :MMSSSMMP'          █       __      ' `:--.--.     █
// █ MMM / \    '  "T$$P"           /     :MMMMMMP'           █  ___.'  '.___    |  |  |     █
// █ MMSb`. ;                      "      :MMMMMM'            █  ____________    |  |  |     █
// █ MMSSb_lSSSb.             .___.       MMMMMP ,d88b.d88b,  █                  |  |  | .., █
// █ MMMMSSSSSSSSb.                     .MMMMMM. 88888888888  █                        `--': █
// █ MMMMMMMMMMMSSSb                  .dMMMMMMMP `Y8888888Y'  █                              █
// █ MMMMMMMMMMMMMSS;               .dMMMMMMMMMM'  `Y888Y'    █         ...             _    █
// █ MMMMGEMMAMMMMb`;"-.          .dMMMMMMMMMMP'     `Y'      █         .':     \      /_)   █
// █ MMMMMMMMMMMMMMb:   `'--.___.dMMMMMMMMMPP'                █       .'         \    /`.    █
// █ MMMMMMMMMMMMMMMb;           dMMMMMMMMPPR                 █   `..'            \  /   ;   █
// █ ▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄ █   .'`.             \/ __.'   █
// █                                                          █                              █
// █          ░░░░░░░░          ▒▒▒▒▒▒▒▒          ░░░░░░░░    █                              █
// █       ▓▓▓░░ ████████    ███▒▒ ▓▓▓▓▓▓▓▓    ▓▓▓░░ ████████ █                 `-.    .-'   █
// █    ▒▒▒▓▓ ░░ ██ ▒▒▒▒▒▒░░░██ ▒▒ ▓▓ ░░░░░░▒▒▒▓▓ ░░ ██+§¥µ██ █ .-"-._.-"-._.-     :  :      █
// █ ███▒▒ ▓▓ ░░░██ ▒▒ ▓▓▓░░ ██ ▒▒▒▓▓ ░░ ███▒▒ ▓▓ ░░░██$@¢¶██ █ .-"-._.-"-._.-   --:--:--    █
// █ ██ ▒▒ ▓▓▓▓▓▓███▒▒ ▓▓ ░░ ██████▓▓▓░░ ██ ▒▒ ▓▓▓▓▓▓████████ █                    :  :      █
// █ ██ ▒▒▒▒▒▒▒▒    ▒▒▒▓▓ ░░░░░░░░    ░░░██ ▒▒▒▒▒▒▒▒          █                 .-'    `-.   █
// █ ████████          ▓▓▓▓▓▓▓▓          ████████    CYBERGEM █                              █
// ▀                                                          ▀                              ▀
// ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀

#pragma /* <3 */ once // upon a time ...

#include <array>
#include <cmath>
#include <limits>
#include <string>
#include <vector>
#include <cstring>

#define SODIUM_STATIC = 1
#include <sodium.h>

#include "EXCEPTION.h"
#include "HIDEAGEM_CONSTANTS.h"
#include "TRUE_RANDOM.h"
#include "GHOST_VECTOR.h"

//
//    DRAGON RNG
//
//    Ouroboros Class CSPRNG
//
//    Cryptographically secure pseudo random number generator implemented with XChaCha20.
//
//    Fast forwards in O(1) time. Can warp universes by eating its own tail.
//
//    Seed is hashed before storing in memory and is securely erased upon destruction.

namespace HIDEAGEM_CORE {

class DragonRNG
{
public:

    static constexpr uint64_t SEED_SIZE = crypto_stream_xchacha20_KEYBYTES; // 256 bits
    
    using RNGSeed = std::array<uint8_t, SEED_SIZE>;

    // --

    // Constructor that initializes with true random seed.
    DragonRNG();

    // Constructor that initializes with seed.
    DragonRNG(const RNGSeed& seed);

    // Constructor that initializes using str as a seed.
    DragonRNG(const std::string& str);

    // Constructor that initializes with seed of arbitrary size in bytes.
    template <typename T>
    DragonRNG(const T* seed, const size_t seed_size)
    {
        initialize( seed, seed_size );
    }

    // Constructor that initializes with seed of arbitrary size in bytes,
    // and warps to universe at coords.
    template<typename T, std::size_t N>
    DragonRNG(const T* seed, const size_t seed_size, const RNGWarp<N>& coords)
    : DragonRNG( seed, seed_size )
    {
        warp( coords );
    }

    // Constructor that initializes with seed of arbitrary size in bytes,
    // and warps to universe at coords.
    template<typename T>
    DragonRNG(const T* seed, const size_t seed_size, const GhostVector<uint64_t>& coords)
    : DragonRNG( seed, seed_size )
    {
        warp( coords );
    }

    // Constructor that initializes with seed of arbitrary size in bytes,
    // and warps to universe at coords with terminal_coord appended as the final coordinate.
    template<typename T, std::size_t N>
    DragonRNG(const T* seed, const size_t seed_size, const RNGWarp<N>& coords, const uint64_t terminal_coord)
    : DragonRNG( seed, seed_size )
    {
        std::vector<uint64_t> final_coords;

        for ( const auto& coord : coords )
        {
            final_coords.push_back( coord );
        }

        final_coords.push_back( terminal_coord );

        warp( final_coords );
    }

    // Constructor that initializes with seed and warps to universe at coords.
    template<std::size_t N>
    DragonRNG(const RNGSeed& seed, const RNGWarp<N>& coords)
    : DragonRNG(seed)
    {
        warp(coords);
    }

    // Constructor that initializes using str as a seed and warps to universe at coords.
    template<std::size_t N>
    DragonRNG(const std::string& str, const RNGWarp<N>& coords)
    {
        warp(coords);
    }

    ~DragonRNG();

    // --

	// Returns a random 64-bit integer.
    uint64_t rand();

	// Returns a random byte.
    uint8_t rand_byte();

    // Returns random double in 0.0 .. 1.0 range (inclusive)
    double rand_percent();

	// Returns a random boolean (true or false).
    bool rand_bool();

    // Returns a random bool that is true chance_true percent of the time.
    // chance_true should be in range 0.0 .. 1.0 (inclusive).
    bool rand_bool(const double chance_true);

    // Fast forwards the RNG by cycles: 1 cycle is 1 byte of cipher stream.
    void fast_forward(const uint64_t cycles);

	// Returns a random number of size and type T.
    template <typename T>
    T rand()
    {
        static_assert(std::is_integral<T>::value || std::is_floating_point<T>::value,
            "DragonRNG :: rand() :: Type T must be an integral or floating point type");

        // Ensure there are enough bytes left in the block to read 64 bits
        if ( BLOCK_SIZE - offset_in_block <= sizeof(T) )
        {
            update_cipher_stream_block(); // Load new block
        }
        
        T _rand;
        std::memcpy( &_rand, &current_block[ offset_in_block ], sizeof( _rand ) );
        offset_in_block += sizeof( _rand );

        return _rand;
    }

    // Returns a random number in range start .. end (inclusive) of size and type T.
    template <typename T>
    T rand_range(const T end, T start = 0)
    {
        static_assert(std::is_unsigned<T>::value, "T must be an unsigned integer type");

        if ( start > end )
        {
            throw _EXCEPTION("DragonRNG :: rand_range() :: start > end");
        }

        // --

        if ( start == end || end == 0 )
        {
            return end;
        }

        T range = end - start;

        if ( end != std::numeric_limits<T>::max() )
        {
            range += 1; // Won't cause overflow
        }

        const T bias_limit = (( std::numeric_limits<T>::max() - range ) + 1 ) % range;

        T rnd = rand<T>();

        while ( rnd < bias_limit )
        {
            rnd = rand<T>();
        }

        return start + (rnd % range);
    }

    // Shuffles a container in place using Fisher-Yates shuffle.
    template <typename T>
    void shuffle(T& container)
    {
        for (uint64_t i = container.size() - 1; i >= 1; --i)
        {
            const uint64_t j = rand_range<uint64_t>(i);
            std::swap(container[i], container[j]);
        }
    }

    template< typename T >
    void warp( const T& coords )
    {
        for ( const auto& coord : coords )
        {
            warp( coord );
        }
    }

    // Warps to cipher stream universe at coord:
    //
    // - Fast forwards WARP_STRIDE * coord bits
    // - Creates a WARP SEED by XORing seed with the next SEED_SIZE bits from the cipher stream
    // - Replaces this RNG with one seeded with the WARP SEED
    //
    // The RNG eats its own tail and vanishes from this universe, warping to a new one!
    void warp( const uint64_t coord );

    // XOR seed with next 256-bits of the cipher stream and
    // replace self with new RNG seeded with the mutated seed.
    void warp();

    // Returns random RNG Seed.
    RNGSeed rand_seed();

    // Secure erase self.
    void vanish();

private:

    static constexpr uint64_t NONCE_SIZE  = crypto_stream_xchacha20_NONCEBYTES; // 192-bits
    static constexpr uint64_t BLOCK_SIZE  = 64; // 512-bit
    static constexpr uint64_t WARP_STRIDE = SEED_SIZE;

    std::array<uint8_t, SEED_SIZE> seed; // Hash of seed
    std::array<uint8_t, NONCE_SIZE> nonce;
    std::array<uint8_t, NONCE_SIZE> nonce_ff; // For fast forwarding nonce
    std::array<uint8_t, BLOCK_SIZE> current_block;

    uint64_t offset_in_block = BLOCK_SIZE;

    // --

	// Seeds with true random seed.
    void seed_from_true_random();

	// Increments the nonce by one.
    void increment_nonce();

    // Writes new cipher stream block to current_block if offset_in_block >= BLOCK_SIZE.
    void update_cipher_stream_block();

    template <typename T>
    void initialize(const T& init)
    {
        initialize( init.data(), init.size() );
    }

    // Seeds RNG with hash of init.
    template <typename T>
    void initialize(const T* init, const size_t init_size)
    {
        // Hash the init data into seed
        if (crypto_generichash(
            seed.data(),
            seed.size(),
            reinterpret_cast<const unsigned char*>(init),
            init_size,
            nullptr, 0) != 0 )
        {
            throw _EXCEPTION("Generic hash failed. Cannot initialize DragonRNG.");
        }

        nonce.fill(0);
        current_block.fill(0);
        offset_in_block = BLOCK_SIZE; // Trigger block load
    }
};

}; // namespace HIDEAGEM_CORE

