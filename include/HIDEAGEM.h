//
//  888    888 8888888 8888888b.  8888888888        d8888  .d8888b.  8888888888 888b     d888
//  888    888   888   888  "Y88b 888              d88888 d88P  Y88b 888        8888b   d8888
//  888    888   888   888    888 888             d88P888 888    888 888        88888b.d88888
//  8888888888   888   888    888 8888888        d88P 888 888        8888888    888Y88888P888
//  888    888   888   888    888 888           d88P  888 888  88888 888        888 Y888P 888
//  888    888   888   888    888 888          d88P   888 888    888 888        888  Y8P  888
//  888    888   888   888  .d88P 888         d8888888888 Y88b  d88P 888        888   "   888
//  888    888 8888888 8888888P"  8888888888 d88P     888  "Y8888P88 8888888888 888       888
// ▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄
// ▄    ____ ______ ____                                      ▄                              ▄
// █   /    /      \    \   HIDEAGEM STEGANOGRAPHY PLATFORM   █                  .     .     █
// █  /___ /________\ ___\                                    █   .-.   .-.      '.___.'     █
// █  \    \        /    /  ASTRAL SOFTWARE FROM THE FUTURE   █  (_  \ /  _)     .'   `.     █
// █    \   \      /   /                                      █       |         :       :    █
// █      \  \    /  /      COPYRIGHT 2024 WWW.CYBERGEM.NET   █       |         :       :    █
// █        \ \  / /                                          █       |          `.___.'     █
// █           \/           LET'S DO COMPUTER STUFF ALL DAY   █                              █
// █                                                          █                              █
// █ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀ █    ._____.         .--.      █
// █ MMMMMSSSSSSSSSSSSSSSSSSSSSSSSSSddMMMMMSSSSSSMSSSSSSSSSS; █      | |          /   _`.    █
// █ MMMMSSSSSSSSSSSSSSSSSMSSSSS; ;SSdMMMMSSSSSSMMSSSSSSSSSS, █      | |         (_) ( )     █
// █ MMSSSSSSSMSSSSSMSSSSMMMSS."-.-":MMMMMSSSSMMMMSSMSSSMMSS  █     _|_|_       '.    /      █
// █ MSSSSSSSMSSSSMMMSSMMMPTMM;"-/\":MMM^"     MMMSSMMMSSMM   █    '     '        `--'       █
// █ SSSSSSSMMSSMMMMMMMMMP-.MMM :  ;.;P       dMMMMMMMMMP'    █                              █
// █ SSMSSSMMMSMMMMMMMMMP   :M;`:  ;.'+"""t+dMMMMMMMMMMP      █                _             █
// █ MMMSSMMMMMMMMPTMMMM"""":P `.\// '    ""^^MMMMMMMP'       █      .--.     ' `:--.--.     █
// █ MMMMMMPTMMMMP="TMMMsg,      \/   db`c"  dMMMMMP"         █     (    )       |  |  |_    █
// █ MMMMMM  TMMM   d$$$b ^          /T$; ;-/TMMMP'  Let's    █    (_)  /        |  |  | )   █
// █ MMMMM; .^`M; d$P^T$$b          :  $$ ::MMMMP  hide some  █        (_,       |  |  |/    █
// █ MMMMMM   .-+d$$   $$$;         ;. $$ ;;MMMP,    Gems !   █                       (J     █
// █ MMMMMMb   _d$$$   $$$$         :$$$; :MMMMMMp.           █                              █
// █ MMMMMM"  " T$$$._.$$$;          T$P.'MMMSSSSSSb          █                _             █
// █ MMM`TMb   -")T$$$$$$P'       `._ ""  :MMSSSMMP'          █       __      ' `:--.--.     █
// █ MMM / \    '  "T$$P"           /     :MMMMMMP'           █  ___.'  '.___    |  |  |     █
// █ MMSb`. ;                      "      :MMMMMM'            █  ____________    |  |  |     █
// █ MMSSb_lSSSb.             .___.       MMMMMP ,d88b.d88b,  █                  |  |  | .., █
// █ MMMMSSSSSSSSb.                     .MMMMMM. 88888888888  █                        `--': █
// █ MMMMMMMMMMMSSSb                  .dMMMMMMMP `Y8888888Y'  █                              █
// █ MMMMMMMMMMMMMSS;               .dMMMMMMMMMM'  `Y888Y'    █         ...             _    █
// █ MMMMGEMMAMMMMb`;"-.          .dMMMMMMMMMMP'     `Y'      █         .':     \      /_)   █
// █ MMMMMMMMMMMMMMb:   `'--.___.dMMMMMMMMMPP'                █       .'         \    /`.    █
// █ MMMMMMMMMMMMMMMb;           dMMMMMMMMPPR                 █   `..'            \  /   ;   █
// █ ▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄ █   .'`.             \/ __.'   █
// █                                                          █                              █
// █          ░░░░░░░░          ▒▒▒▒▒▒▒▒          ░░░░░░░░    █                              █
// █       ▓▓▓░░ ████████    ███▒▒ ▓▓▓▓▓▓▓▓    ▓▓▓░░ ████████ █                 `-.    .-'   █
// █    ▒▒▒▓▓ ░░ ██ ▒▒▒▒▒▒░░░██ ▒▒ ▓▓ ░░░░░░▒▒▒▓▓ ░░ ██+§¥µ██ █ .-"-._.-"-._.-     :  :      █
// █ ███▒▒ ▓▓ ░░░██ ▒▒ ▓▓▓░░ ██ ▒▒▒▓▓ ░░ ███▒▒ ▓▓ ░░░██$@¢¶██ █ .-"-._.-"-._.-   --:--:--    █
// █ ██ ▒▒ ▓▓▓▓▓▓███▒▒ ▓▓ ░░ ██████▓▓▓░░ ██ ▒▒ ▓▓▓▓▓▓████████ █                    :  :      █
// █ ██ ▒▒▒▒▒▒▒▒    ▒▒▒▓▓ ░░░░░░░░    ░░░██ ▒▒▒▒▒▒▒▒          █                 .-'    `-.   █
// █ ████████          ▓▓▓▓▓▓▓▓          ████████    CYBERGEM █                              █
// ▀                                                          ▀                              ▀
// ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀

#pragma /* <3 */ once // upon a time ...

#include <cstdint>

#include "GEM_FILE.h"
#include "CYCLE_KEY.h"
#include "EXCEPTION.h"
#include "GEM_OCEAN.h"
#include "BIT_STREAM.h"
#include "DRAGON_RNG.h"
#include "TRUE_RANDOM.h"
#include "GEM_PROTOCOL.h"
#include "GHOST_VECTOR.h"
#include "BIT_COLLECTOR.h"
#include "HIDEAGEM_UTILS.h"
#include "HIDEAGEM_ENUMS.h"
#include "OCEAN_BYTE_SET.h"
#include "TERMINAL_UTILS.h"
#include "COMPRESSION_UTILS.h"
#include "HIDEAGEM_CONSTANTS.h"

//
//    HIDEAGEM
//

namespace HIDEAGEM_CORE {


class HideAGem
{
public:

    HideAGem( GemOcean& _ocean );

    ~HideAGem();

    ///
    //    PUBLIC API

    bool b_print_gem_hash = true;
    bool b_print_gem_seal = true;

    // Writes Gem Files in file_paths to OCEAN that is set in constuctor.
    //
    // Gem Files will be read back from the OCEAN and their bytes validated if b_validate is true.
    bool hide_gem_files(
        int gem_protocol,
        const std::vector<std::string>& file_path,
        const std::string& password,
        const int time_trap = static_cast<int>(ETimeTrapLevel::NONE),
        bool b_validate = false
    );

    bool hide_gem_files(
        int gem_protocol,
        std::vector<GemFile>& gem_files,
        const std::string& password,
        const int time_trap = static_cast<int>(ETimeTrapLevel::NONE),
        bool b_validate = false
    );

    // Searches gem_image for Gem Files using password, adding any found to out_gem_files.
    //
    // Output Gem Files will be in unpacked state.
    //
    // Returns number of gem files found.

    uint64_t find_gem_files(
        const std::string& password,
        std::vector<GemFile>& out_gem_files,
        const bool b_time_trap
    );

    ///
    //    INFO

    uint64_t get_remaining_byte_capacity() const;

    ///
    //    GEM HASH AND SEAL

    void print_gem_hash() const;

    void PRINT_GEM_SEAL() const;

    const std::string& GET_GEM_HASH() const { return GEM_HASH; }
    const std::string& GET_GEM_SEAL() const { return GEM_SEAL; }

    ///
    //    DIAGNOSTICS

    EGemErrorCode get_error_code() const { return ERROR_CODE; }

protected:

    bool b_pristine;      // False if instance has been used to hide or find gems
    bool b_validate_read; // If true Gem Files will be read from image after hiding to validate

    bool b_lock_ocean_write = true;
    bool b_keys_initialized = false;
    bool b_gem_header_bytes_reserved = false;

    CycleKey MASTER_KEY;

    GhostVector<uint8_t> GEM_STREAM_ENCRYPT_KEY;

    uint64_t TIME_TRAP_CYCLE_RATE = 0;

    GemProtocol GEM_PROTOCOL;
    EGemProtocolKey GEM_PROTOCOL_KEY = EGemProtocolKey::NONE;

    EGemErrorCode ERROR_CODE = EGemErrorCode::NONE;

    GemOcean& OCEAN; // Cover OCEAN

    uint64_t max_ocean_index = 0; // Max index of OCEAN

    DragonRNG SHARED_RNG;
    DragonRNG DATA_WHITEN_RNG;
    DragonRNG BYTE_COUNT_ENCRYPT_RNG;
    DragonRNG READ_STOP_BYTES_ENCRYPT_RNG;

    BitStream gem_bit_stream;
    std::vector<GemFile> gem_files;

    EBitMode GEM_BIT_MODE = EBitMode::NONE;

    std::string GEM_HASH;
    std::string GEM_SEAL;

    ///
    //    GEM PROTOCOL

    bool init_gem_protocol(const EGemProtocolKey gem_protocol);

    // Auto-reserves Gem Header Ocean bytes
    void write_gem_header(const EGemProtocolKey gem_protocol_key);

    // Auto-reserves Gem Header Ocean bytes
    EGemProtocolKey read_gem_header();

    ///
    //    TIME TRAP

    ETimeTrapLevel TIME_TRAP_LEVEL = ETimeTrapLevel::NONE;

    ///
    //    RANDOM OCEAN BYTES

    OceanIndex get_rand_ocean_byte_index()
    {
        return get_rand_ocean_byte_index( MASTER_KEY );
    }

    template <typename T>
    OceanIndex get_rand_ocean_byte_index(T& rng)
    {
        while ( OCEAN.num_bytes_remaining() > 0 )
        {
            const OceanIndex idx =
                rng.rand_range( static_cast<OceanIndex>( OCEAN.size() - 1 ));

            if ( ! OCEAN.is_reserved( idx ) )
            {
                OCEAN.reserve( idx );

                return idx;
            }
        }

        throw _EXCEPTION("\nRan out of Ocean bytes !\n");

        return ERROR_INDEX;
    }

    ///
    //    MASTER KEY AND SALT

    // Generates salt of salt_size
    void gen_salt(
        uint8_t* salt,
        const uint64_t salt_size,
        const std::string& password
    );

    // Initializes the Master Key
    void init_master_key(const std::string& password);

    // Erases keys and other sensitive data
    void erase_sensitive_data(const bool b_erase_hash = true);

    ///
    //    ENCRYPTION

    // Uses a shared RNG: Decrypt order must exactly match encrypt order.
    GemSize encrypt_gem_stream_byte_count(
        const GemSize byte_count,
        const GemSize byte_capacity
    );

    // Uses a shared RNG: Decrypt order must exactly match encrypt order.
    GemSize decrypt_gem_stream_byte_count(
        const GemSize encrypted_padded_byte_count,
        const GemSize byte_capacity
    );

    ///
    //    COMPRESSION

    // Gem compression and uncompression with zlib
    static GemFile compress_gem(const GemByte* gem_bytes, const uint64_t gem_byte_count);
    static GemFile uncompress_gem(const GemByte* compressed_gem, const uint64_t byte_count);

    ///
    //    HIDE GEMS

    // Expects Gem Files to be unpacked (they will get packed)
    bool hide_gem_files_internal(
        std::vector<GemFile>& gem_files,
        const std::string& password
    );

    // Writes bit_stream to gem_image
    // Does not reset cycle before writing
    bool GEMMA_RANDOM_write_bit_stream_to_ocean(
        BitStream& bit_stream,
        const EBitMode bit_mode,
        const bool b_print_status = false
    );

    ///
    //    FIND GEMS

    void find_gem_files(const bool b_time_trap = false);

    // Uses prepared MASTER_KEY to extract bits from cover image
    // Extracts up to max_bytes or until a Gem Stream is read
    // Does not reset MASTER_KEY before extracting bits
    BitCollector GEMMA_RANDOM_extract_gem_bits(
        const EBitMode bit_mode,
        const uint64_t max_bytes = 0,
        const bool b_print_status = false
    );

    BitCollector GEMMA_RANDOM_extract_gem_bits_TIME_TRAP(
        const EBitMode bit_mode,
        const uint64_t max_bytes = 0
    );

    void process_extracted_gem_stream(GhostVector<GemByte>& gem_stream);

    //
    //    WRITE GEM DATA TO OCEAN

    GemByte write_bits_to_byte_LSB_MATCHING(
        const GemByte byte, 
        const GemByte data,
        const uint8_t num_LSB
    ) const;

    bool write_bit_stream_to_byte_LSB_MATCHING(
        GemByte& byte,
        GemBitIndex bit_index,
        const BitStream& bit_stream,
        const EBitMode bit_mode
    ) const;

    ///
    //    READ / WRITE OCEAN BYTES

    GemByte read_ocean_byte(const OceanIndex ocean_index) const;

    void write_ocean_byte(const OceanIndex ocean_index, const GemByte& byte);

    ///
    //    BIT TRAP

    void write_bit_trap_to_ocean(const uint64_t trap_val);

    uint64_t read_bit_trap_from_ocean();

    ///
    //    TIME TRAP

    void set_time_trap_level( const int time_trap );

    void init_time_trap_cycle_rate(const uint64_t num_gem_bytes);

    ///
    //    RANDOM

    void process_final_RNG_state(DragonRNG& rng);

    ///
    //    GEM HASH

    void gen_gem_hash(const DragonRNG::RNGSeed& seed);

    ///
    //    GEM SEAL

    void READ_GEM_SEAL(const DragonRNG::RNGSeed& seed);

    ///
    //    CONSTANTS

    static constexpr const char* GEM_VALIDATION_OCEAN_BYTE_SET_NAME = "__VALIDATE__";
};

}; // namespace HIDEAGEM_CORE

