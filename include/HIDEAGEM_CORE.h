//
//  888    888 8888888 8888888b.  8888888888        d8888  .d8888b.  8888888888 888b     d888
//  888    888   888   888  "Y88b 888              d88888 d88P  Y88b 888        8888b   d8888
//  888    888   888   888    888 888             d88P888 888    888 888        88888b.d88888
//  8888888888   888   888    888 8888888        d88P 888 888        8888888    888Y88888P888
//  888    888   888   888    888 888           d88P  888 888  88888 888        888 Y888P 888
//  888    888   888   888    888 888          d88P   888 888    888 888        888  Y8P  888
//  888    888   888   888  .d88P 888         d8888888888 Y88b  d88P 888        888   "   888
//  888    888 8888888 8888888P"  8888888888 d88P     888  "Y8888P88 8888888888 888       888
// ▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄
// ▄    ____ ______ ____                                      ▄                              ▄
// █   /    /      \    \   HIDEAGEM STEGANOGRAPHY PLATFORM   █                  .     .     █
// █  /___ /________\ ___\                                    █   .-.   .-.      '.___.'     █
// █  \    \        /    /  ASTRAL SOFTWARE FROM THE FUTURE   █  (_  \ /  _)     .'   `.     █
// █    \   \      /   /                                      █       |         :       :    █
// █      \  \    /  /      COPYRIGHT 2024 WWW.CYBERGEM.NET   █       |         :       :    █
// █        \ \  / /                                          █       |          `.___.'     █
// █           \/           LET'S DO COMPUTER STUFF ALL DAY   █                              █
// █                                                          █                              █
// █ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀ █    ._____.         .--.      █
// █ MMMMMSSSSSSSSSSSSSSSSSSSSSSSSSSddMMMMMSSSSSSMSSSSSSSSSS; █      | |          /   _`.    █
// █ MMMMSSSSSSSSSSSSSSSSSMSSSSS; ;SSdMMMMSSSSSSMMSSSSSSSSSS, █      | |         (_) ( )     █
// █ MMSSSSSSSMSSSSSMSSSSMMMSS."-.-":MMMMMSSSSMMMMSSMSSSMMSS  █     _|_|_       '.    /      █
// █ MSSSSSSSMSSSSMMMSSMMMPTMM;"-/\":MMM^"     MMMSSMMMSSMM   █    '     '        `--'       █
// █ SSSSSSSMMSSMMMMMMMMMP-.MMM :  ;.;P       dMMMMMMMMMP'    █                              █
// █ SSMSSSMMMSMMMMMMMMMP   :M;`:  ;.'+"""t+dMMMMMMMMMMP      █                _             █
// █ MMMSSMMMMMMMMPTMMMM"""":P `.\// '    ""^^MMMMMMMP'       █      .--.     ' `:--.--.     █
// █ MMMMMMPTMMMMP="TMMMsg,      \/   db`c"  dMMMMMP"         █     (    )       |  |  |_    █
// █ MMMMMM  TMMM   d$$$b ^          /T$; ;-/TMMMP'  Let's    █    (_)  /        |  |  | )   █
// █ MMMMM; .^`M; d$P^T$$b          :  $$ ::MMMMP  hide some  █        (_,       |  |  |/    █
// █ MMMMMM   .-+d$$   $$$;         ;. $$ ;;MMMP,    Gems !   █                       (J     █
// █ MMMMMMb   _d$$$   $$$$         :$$$; :MMMMMMp.           █                              █
// █ MMMMMM"  " T$$$._.$$$;          T$P.'MMMSSSSSSb          █                _             █
// █ MMM`TMb   -")T$$$$$$P'       `._ ""  :MMSSSMMP'          █       __      ' `:--.--.     █
// █ MMM / \    '  "T$$P"           /     :MMMMMMP'           █  ___.'  '.___    |  |  |     █
// █ MMSb`. ;                      "      :MMMMMM'            █  ____________    |  |  |     █
// █ MMSSb_lSSSb.             .___.       MMMMMP ,d88b.d88b,  █                  |  |  | .., █
// █ MMMMSSSSSSSSb.                     .MMMMMM. 88888888888  █                        `--': █
// █ MMMMMMMMMMMSSSb                  .dMMMMMMMP `Y8888888Y'  █                              █
// █ MMMMMMMMMMMMMSS;               .dMMMMMMMMMM'  `Y888Y'    █         ...             _    █
// █ MMMMGEMMAMMMMb`;"-.          .dMMMMMMMMMMP'     `Y'      █         .':     \      /_)   █
// █ MMMMMMMMMMMMMMb:   `'--.___.dMMMMMMMMMPP'                █       .'         \    /`.    █
// █ MMMMMMMMMMMMMMMb;           dMMMMMMMMPPR                 █   `..'            \  /   ;   █
// █ ▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄ █   .'`.             \/ __.'   █
// █                                                          █                              █
// █          ░░░░░░░░          ▒▒▒▒▒▒▒▒          ░░░░░░░░    █                              █
// █       ▓▓▓░░ ████████    ███▒▒ ▓▓▓▓▓▓▓▓    ▓▓▓░░ ████████ █                 `-.    .-'   █
// █    ▒▒▒▓▓ ░░ ██ ▒▒▒▒▒▒░░░██ ▒▒ ▓▓ ░░░░░░▒▒▒▓▓ ░░ ██+§¥µ██ █ .-"-._.-"-._.-     :  :      █
// █ ███▒▒ ▓▓ ░░░██ ▒▒ ▓▓▓░░ ██ ▒▒▒▓▓ ░░ ███▒▒ ▓▓ ░░░██$@¢¶██ █ .-"-._.-"-._.-   --:--:--    █
// █ ██ ▒▒ ▓▓▓▓▓▓███▒▒ ▓▓ ░░ ██████▓▓▓░░ ██ ▒▒ ▓▓▓▓▓▓████████ █                    :  :      █
// █ ██ ▒▒▒▒▒▒▒▒    ▒▒▒▓▓ ░░░░░░░░    ░░░██ ▒▒▒▒▒▒▒▒          █                 .-'    `-.   █
// █ ████████          ▓▓▓▓▓▓▓▓          ████████    CYBERGEM █                              █
// ▀                                                          ▀                              ▀
// ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀

#pragma /* <3 */ once // upon a time ...

#include <map>
#include <array>
#include <cmath>
#include <atomic>
#include <limits>
#include <string>
#include <vector>
#include <cstdint>
#include <cstring>
#include <fstream>
#include <numeric>
#include <iostream>
#include <execution>
#include <stdexcept>
#include <filesystem>

#define SODIUM_STATIC = 1
#include <sodium.h>

//
//    HIDEAGEM CORE
//

namespace HideAGemCore {

constexpr uint16_t    HIDEAGEM_VERSION_MAJOR = 1;
constexpr uint16_t    HIDEAGEM_VERSION_MINOR = 2;
constexpr const char* HIDEAGEM_VERSION_NAME  = "LOVEMAGNET";

constexpr uint8_t REQUIRED_SODIUM_VERSION_MAJOR = 26;
constexpr uint8_t REQUIRED_SODIUM_VERSION_MINOR = 1;

//
//    *** START PERMANENT CONSTANTS ***
//
//    CHANGING THESE BREAKS BACKWARDS COMPATIBILITY !!!

///
//    TYPES

using GemByte     = uint8_t;
using GemSize     = uint64_t;
using GemHeader   = uint32_t;
using OceanIndex  = uint64_t;
using GemBitIndex = uint64_t;

template <std::size_t N>
using RNGWarp = std::array<uint64_t, N>;

///
//    CONSTANTS

constexpr uint8_t NUM_SALT_BYTES = 16; // 128 bits

constexpr uint8_t GEM_HEADER_BIT_MODE = 1; // 1 bit
constexpr uint8_t GEM_HEADER_SIZE     = 8; // 64 bits

constexpr uint8_t GEM_PROTOCOL_BIT_SIZE = 16; // Bits

constexpr uint8_t MINIZ_TAIL_SIZE = sizeof( uint64_t ); // 64-bit byte count

constexpr uint8_t GEM_FILE_HEAD_SIZE = sizeof( GemSize );

constexpr uint64_t DEFAULT_MASTER_KEY_AUTO_CYCLE_RATE = 64; // 512 bits per cycle

constexpr uint8_t GEM_STREAM_HEAD_SIZE  = sizeof( GemSize );
constexpr uint8_t GEM_STREAM_TAIL_SIZE  = crypto_aead_xchacha20poly1305_ietf_ABYTES;    // 128-bit AEAD tag
constexpr uint8_t GEM_STREAM_NONCE_SIZE = crypto_aead_xchacha20poly1305_ietf_NPUBBYTES; // 192-bit nonce

constexpr uint8_t READ_STOP_BYTE_VALUE = 0;
constexpr uint8_t READ_STOP_BYTE_COUNT = 8; // Bytes (64 bits)

constexpr size_t ERROR_INDEX = std::numeric_limits<size_t>::max();

///
//    GEM PROTOCOL PARAMETERS SIZES

constexpr uint8_t GEMMA_RANDOM_PARAMS_SIZE = 1; // Byte

///
//    TIME TRAPS
//
//    Ocean bytes per Cycle Key regeneration (lower = slower)

constexpr uint64_t RUBY_TIME_TRAP_MAX_CYCLE_RATE = 2048;

//
//    *** END PERMANENT CONSTANTS ***
//

///
//    TRANSIENT CONSTANTS

constexpr uint64_t TEMPORARY_MAX_GEM_SIZE = 1ull * (1ull << 32);   // 4 GB (temporary limit for current testing phase)
constexpr uint64_t BOMB_PATROL_THRESHOLD  = 100ull * (1ull << 20); // 100 MB

constexpr double STATUS_PRINT_COOLDOWN_TIME = 0.03333f; // 30 Hz (in seconds)

constexpr uint8_t GEM_FILES_PRINT_ASK_THRESHOLD = 128; // Ask to print more than n Gem Files

//
//    TRUE RANDOM
//

namespace TRUE_RANDOM {

    template<typename T>
    inline void rand_bytes(T* rand, size_t size)
    {
        if (sodium_init() < 0)
        {
            return;
        }

        randombytes_buf(rand, size);
    }

    template<typename T>
    T rand()
    {
        T rand;
        rand_bytes( &rand, sizeof(T) );

        return rand;
    }

    inline uint8_t rand_byte()
    {
        uint8_t rand;
        rand_bytes(&rand, sizeof(rand));

        return rand;
    }

    inline bool rand_bool()
    {
        return (rand_byte() & 1) == 1;
    }

}; // namespace TRUE_RANDOM

//
//    ERROR CODES
//

enum class EGemErrorCode
{
    NONE,
    UNKNOWN,
    DEAD_END,
    EXIT_SIGNAL,
    BAD_ARGUMENT,
    NOT_PRISTINE,
    INVALID_OCEAN,
    NOT_ENOUGH_SPACE,
    GEM_VALIDATION_FAILED,
    INVALID_TIME_TRAP_LEVEL,
    GEM_STREAM_DECOMPRESSION_ABORTED,
};

//
//    DEBUG
//

class _E : public std::exception
{
public:

    _E(const std::string& msg) : message(msg) {}
    
    virtual const char* what() const noexcept override
    {
        return message.c_str();
    }

private:

    std::string message;
};

//
//    BIT MODE
//

enum EBitMode
{
    NONE = 0,

    _1_BIT  = 1,
    _2_BIT  = 2,
    _3_BIT  = 3,
    _4_BIT  = 4,
    _5_BIT  = 5,
    _6_BIT  = 6,
    _7_BIT  = 7,
    _8_BIT  = 8,

    MAX = 8,
};

//
//    GHOST VECTOR
//
//    Securely erases trivially destructible types, such as int, float, bool etc.
//    when erasing and popping elements elements, and upon destruction.

template <typename T>
class GhostVector
{
public:

    using iterator       = typename std::vector<T>::iterator;
    using const_iterator = typename std::vector<T>::const_iterator;

    GhostVector() {}
    GhostVector(size_t size) : vec(size) {}
    GhostVector(size_t size, T init) : vec(size, init) {}

    GhostVector(std::initializer_list<T> initList) : vec(initList) {}

    template <class InputIterator>
    GhostVector(InputIterator first, InputIterator last) : vec(first, last) {}

    ~GhostVector()
    {
        secure_erase();
    }

    void push_back(const T& t) { vec.push_back(t); }

    void pop_back()
    {
        if constexpr (std::is_trivially_destructible<T>::value)
        {
            if (sodium_init() < 0)
            {
                throw _E("Failed to pop_back() GhostVector: libsodium could not be initialized.");
            }

            sodium_memzero(&back(), sizeof(T));
        }

        vec.pop_back();
    }

    T& front() { return vec.front(); }
    T& back()  { return vec.back();  }

    const T& front() const { return vec.front(); }
    const T& back()  const { return vec.back();  }

    T* data() { return vec.data(); }
    const T* data() const { return vec.data(); }

    void reserve(size_t size)
    {
        vec.reserve(size);
    }

    size_t size() const { return vec.size(); }

    void resize(size_t count)
    {
        if (count < vec.size())
        {
            secure_erase_from(count);
        }

        vec.resize(count);
    }

    void resize(size_t count, const T& value)
    {
        if (count < vec.size())
        {
            secure_erase_from(count);
        }

        vec.resize(count, value);
    }

    bool empty() const { return vec.empty(); }

    iterator erase(iterator pos)
    {
        if constexpr (std::is_trivially_destructible<T>::value)
        {
            if (sodium_init() < 0)
            {
                throw _E("Failed to erase() GhostVector: libsodium could not be initialized.");
            }

            sodium_memzero(&*pos, sizeof(T));
        }

        return vec.erase(pos);
    }

    void clear()
    {
        secure_erase();
        vec.clear();
    }

    void vanish()
    {
        clear();
        std::vector<T>().swap( vec );
    }

    std::vector<T>& vector() { return vec; }

    ///
    //    Read / write bytes from vector

    template<typename U>
    void append_bytes(U value)
    {
        for (int i = 0; i < sizeof(U); ++i)
        {
            uint8_t byte = static_cast<uint8_t>(value & 0xFF);
            push_back(byte);
            value >>= 8;
        }
    }

    template<typename U>
    void write_bytes_at(U value, size_t index)
    {
        if ( index + sizeof(U) >= size() )
        {
            throw _E("ERROR: GhostVector::write_bytes_at() :: Write operation exceeds vector size.");
        }

        for (int i = 0; i < sizeof(U); ++i)
        {
            (*this)[ index + i ] = static_cast<uint8_t>(value & 0xFF);
            value >>= 8;
        }
    }

    template<typename U>
    void read_bytes(U& out, size_t start) const
    {
        out = 0;
        for (int i = 0; i < sizeof(U); ++i)
        {
            uint64_t byte = (*this)[start + i];
            out |= (byte << (i * 8));
        }
    }

    iterator begin()
    {
        return vec.begin();
    }

    const_iterator begin() const
    {
        return vec.begin();
    }

    iterator end()
    {
        return vec.end();
    }

    const_iterator end() const
    {
        return vec.end();
    }

    T& operator[](size_t index)
    {
        return vec[index];
    }

    const T& operator[](size_t index) const
    {
        return vec[index];
    }

    GhostVector& operator=(std::initializer_list<T> init_list)
    {
        secure_erase();
        vec = init_list;

        return *this;
    }

private:

    std::vector<T> vec;

    void secure_erase()
    {
        if (sodium_init() < 0)
        {
            throw _E("Failed to secure erase GhostVector: libsodium could not be initialized.");
        }

        // Secure erase trivially destructible element types
        if constexpr (std::is_trivially_destructible<T>::value)
        {
            sodium_memzero(vec.data(), vec.size() * sizeof(T));
        }

        // TODO warn when not trivially destructible

        vec.resize(0); // This will call destructors
    }

    void secure_erase_from(size_t start_index)
    {
        if (sodium_init() < 0)
        {
            throw _E("Failed to secure erase GhostVector: libsodium could not be initialized.");
        }

        if ( start_index < vec.size() )
        {
            size_t bytes_to_erase = (vec.size() - start_index) * sizeof(T);
            sodium_memzero(vec.data() + start_index, bytes_to_erase);
        }
    }
};

///
//    GEM OCEAN

enum EOceanType
{
    BYTES           = 0,
    IMAGE_GRAYSCALE = 1,
    IMAGE_RGB       = 3,
    IMAGE_RGBA      = 4,
};


class OceanByteSet
{
public:

    OceanByteSet() {}

    OceanByteSet(const uint64_t __size, const EOceanType __type)
    : _size(__size)
    , bits((__size + 7) / 8, 0)
    , _ocean_type(__type)
    {}

    ~OceanByteSet()
    {
        vanish(); // Secure erase
    }

    uint64_t num_set() const { return _num_set; }

    uint64_t remaining() const { return _size - _num_set; }

    uint64_t size() const { return _size; }

    EOceanType ocean_type() const { return _ocean_type; }

    void set(uint64_t idx)
    {
        if ( idx >= _size )
        {
            throw _E("OceanByteSet :: set() :: Index out of range.");
        }

        set_internal( idx );
    }

    bool is_set(uint64_t idx) const
    {
        if ( idx >= _size )
        {
            throw _E("OceanByteSet :: is_set() :: Index out of range.");
        }

        return is_set_internal( idx );
    }

    void reset(uint64_t idx)
    {
        if ( idx >= _size )
        {
            throw _E("OceanByteSet :: reset() :: Index out of range.");
        }

        reset_internal( idx );
    }

    void vanish()
    {
        _size = 0;
        _num_set = 0;
        bits.vanish();
    }

private:

    uint64_t _size = 0;
    uint64_t _num_set = 0;
    GhostVector<uint8_t> bits;
    EOceanType _ocean_type = EOceanType::BYTES;

    void set_internal(uint64_t idx)
    {
        _num_set = is_set_internal(idx) ? _num_set : _num_set + 1;

        bits[idx / 8] |= (1 << (idx % 8));
    }

    bool is_set_internal(uint64_t idx) const
    {
        return bits[idx / 8] & (1 << (idx % 8));
    }

    void reset_internal(uint64_t idx)
    {
        _num_set = is_set_internal(idx) ? _num_set - 1: _num_set;

        bits[idx / 8] &= ~(1 << (idx % 8));
    }
};


class GemOcean
{
public:

    GemOcean(const EGemErrorCode e) : error_code(e) {} // Invalid Gem Ocean

    // Returns OCEAN of size out_ocean_size bytes and out_ocean_type type if successful.
    GemOcean(const void* source_ocean, const uint64_t source_ocean_size);
    
    // Move constructor
    GemOcean(GemOcean&& other) noexcept
    : ocean(other.ocean)
    , _size(other._size)
    , _type(other._type)
    , _width(other._width)
    , _height(other._height)
    , _channels(other._channels)
    , error_code(other.error_code)
    {
        other.ocean = nullptr;
        other.vanish();
    }

    ~GemOcean();

    bool is_valid() const;

    // Caller becomes responsible for freeing ocean memory!
    uint8_t* take();

    uint64_t size() const;

    uint64_t num_bytes_remaining() const
    {
        return byte_set->remaining();
    }

    uint64_t num_bytes_reserved() const
    {
        return byte_set->num_set();
    }

    uint64_t remaining_byte_capacity(const EBitMode bit_mode) const
    {
        return ( bit_mode * ( num_bytes_remaining() ) ) / 8;
    }

    bool is_reserved( size_t idx ) const
    {
        return byte_set->is_set(idx);
    }

    void reserve( size_t idx )
    {
        byte_set->set( idx );
    }

    // Switches to byte set with set_key, creating it if it does not exist,
    void switch_byte_set(const char* set_key)
    {
        if ( byte_set_map.find( set_key ) == byte_set_map.end() )
        {
            // Pass size() rather than _size as the Byte Set may be simulating
            // an OCEAN smaller than the total OCEAN size
            byte_set_map[ set_key ] = OceanByteSet( size(), _type );
        }

        byte_set = &byte_set_map[ set_key ];
        byte_set_key = set_key;
    }

    void delete_byte_set(const char* delete_key)
    {
        byte_set_map.erase( delete_key );

        // Switch to default byte set if deleted current byte set
        if ( delete_key == byte_set_key )
        {
            switch_byte_set( DEFAULT_BYTE_SET_KEY );
        }
    }

    EOceanType type() const { return _type; }
    
    int width() const { return _width; }
    int height() const { return _height; }
    int channels() const { return _channels; }

    EGemErrorCode get_error() const { return error_code; }

    void finalize();

    void vanish();


    uint8_t& operator[](size_t idx) 
    {
        switch ( _type )
        {
            case EOceanType::IMAGE_RGBA :

                return ocean[ RGB_to_RGBA_index( idx ) ];

            default :

                return ocean[ idx ];
        }
    }

    const uint8_t& operator[](size_t idx) const 
    {
        switch ( _type )
        {
            case EOceanType::IMAGE_RGBA :

                return ocean[ RGB_to_RGBA_index( idx ) ];

            default :

                return ocean[ idx ];
        }
    }

protected:

    static constexpr const char* DEFAULT_BYTE_SET_KEY = "___BYTE_SET_KEY_ZERO___";

    // DELETE COPY CONSTRUCTOR
    GemOcean(const GemOcean& other) = delete;

    bool b_finalized = false;

    uint8_t* ocean = nullptr;

    // Reserved OCEAN bytes sets
    const char* byte_set_key = DEFAULT_BYTE_SET_KEY;
    OceanByteSet* byte_set = nullptr;

    std::map<const char*, OceanByteSet> byte_set_map;

    uint64_t _size = 0;
    EOceanType _type = EOceanType::BYTES;

    int _width = 0;
    int _height = 0;
    int _channels = 0;

    EGemErrorCode error_code = EGemErrorCode::NONE;

    size_t RGB_to_RGBA_index(size_t idx) const
    {
        return (idx / 3) * 4 + (idx % 3);
    }
};

//
//    GEM PROTOCOL
//

struct GemProtocol
{
    std::string NAME = "NONE";
};

///
//    16-BIT GEM PROTOCOL KEY

enum class EGemProtocolKey : int16_t
{
    //
    //    ***  PERMANENT CONSTANTS ***
    //

    AUTO           = 0,
    GEMMA_RANDOM   = 1,
    RUBY_TIME_TRAP = 2,

    NONE = std::numeric_limits<int16_t>::min(),
};


inline const std::map<EGemProtocolKey, GemProtocol> GEM_PROTOCOLS
{
    { EGemProtocolKey::GEMMA_RANDOM,   { "GEMMA RANDOM"} },
    { EGemProtocolKey::RUBY_TIME_TRAP, { "RUBY TIME TRAP"} },
};


bool get_gem_protocol(const EGemProtocolKey gem_protocol, GemProtocol& out_protocol);

///
//    TIME TRAP LEVEL

enum class ETimeTrapLevel : int8_t
{
    NONE  = -1,
    ZERO  = 0,
    ONE   = 1,
    TWO   = 2,
    THREE = 3,
    FOUR  = 4,
    FIVE  = 5,
    SIX   = 6,
    SEVEN = 7,

    MIN = 0,
    MAX = 7,
};

///
//    GEM FILE

class GemFile
{
public:

    static constexpr uint8_t MAX_NAME_LEN = 255;

    GemFile(const uint64_t& _size)
    {
        init_data(_size);
    }

    GemFile(const uint8_t* copy_data, const uint64_t& copy_size, const char* copy_name = "", bool b_pack = false)
    {
        init_data(copy_size);
        std::memcpy(_data, copy_data, copy_size); // Copy  data
        _name = copy_name;

        if (b_pack)
        {
            pack();
        }
    }

    GemFile(const std::string& file_path, bool b_pack = false)
    {
        read_binary_file( file_path );

        if (b_pack)
        {
            pack();
        }
    }

    // Move constructor
    GemFile(GemFile&& other) noexcept
    : _data(other.data())
    , pack_state(other.pack_state)
    , b_locked(other.b_locked)
    , b_data_init(other.b_data_init)
    , _name(other._name)
    , data_size(other.data_size)
    {
        other._data = nullptr;
        other.b_locked = false;
        other.b_data_init = false;
        sodium_memzero(reinterpret_cast<void*>(other._name.data()), other._name.size());
        other._name.clear();
        sodium_memzero(reinterpret_cast<void*>(&other.data_size), sizeof(other.data_size));
    }

    virtual ~GemFile()
    {
        vanish();
    }

    const std::string& name() const { return _name; }

    uint8_t* data() { return _data; }

    const uint8_t* data() const { return _data; }

    uint64_t size() const { return data_size; }

    void set_name(const std::string& __name)
    {
        _name = __name;
    }

    void init_data(const uint64_t& _size)
    {
        if (is_valid()) // Do not modify valid file
        {
            printf("ERROR: Tried to init data of already valid Gem File.\n\n");

            return;
        }
        else if (sodium_init() < 0)
        {
            throw _E("ERROR: GemFile::init_data() :: libsodium could not be initialized.\n\n");
        }
        else if (_size == 0)
        {
            throw _E("ERROR: GemFile::init_data() :: Init size is zero.");
        }

        _data = (uint8_t*)sodium_malloc(_size); // Secure malloc
        if (_data != nullptr)
        {
            data_size = _size;
            b_data_init = true;
        }
    }

    void resize(const size_t& new_size)
    {
        if (!b_data_init)
        {
            init_data(new_size); // Initialize

            return;
        }
        else if (new_size < 1)
        {
            printf("ERROR: Tried to resize Gem File to size 0.\n\n");

            return;
        }
        else if (new_size == data_size)
        {
            return;
        }
        else if (sodium_init() < 0)
        {
            throw _E("ERROR: GemFile::resize() :: libsodium could not be initialized.\n\n");
        }

        uint8_t* new_data = (uint8_t*)sodium_malloc(new_size); // Secure malloc

        // Copy existing data
        memcpy(new_data, _data, std::min(data_size, new_size));

        // Locked data
        if (b_locked)
        {
            sodium_mprotect_readwrite(_data);   // Read-write
            sodium_mprotect_readonly(new_data); // Read-only
        }

        // Erase old data
        sodium_free(_data); // Secure erase

        _data = new_data;
        data_size = new_size;
    }

    // Locks data read-only
    bool lock()
    {
        if (b_locked)
        {
            printf("WARNING: Tried to lock already valid Gem File.\n\n");
        }
        else if (!b_data_init)
        {
            printf("ERROR: Tried to lock Gem File before data initialized.\n\n");
        }
        else if (data_size == 0)
        {
            printf("ERROR: Tried to lock Gem File with 0 size.\n\n");
        }
        else
        {
            sodium_mprotect_readonly(_data); // Read-only
            b_locked = true;

            return true;
        }

        return false;
    }

    // Packs filename size and filename in place.
    //
    // Returns true if data gets packed or is already packed.
    bool pack();

    // Unpacks filename from data in place;
    //
    // If b_force is true will unpack even if pack_state != PACKED.
    //
    // Returns true if data gets unpacked or is already unpacked,
    // and if pack_state == NONE and b_force is false;
    bool unpack(const bool b_force = false);

    bool is_valid() const { return _data != nullptr && data_size > 0; }

    void vanish()
    {
        if (sodium_init() < 0)
        {
            _name.clear();

            return;
        }

        free_data(_data);

        sodium_memzero(reinterpret_cast<void*>(&data_size), sizeof(data_size));
        sodium_memzero(reinterpret_cast<void*>(_name.data()), _name.size());

        _name.clear();
    }

private:

    enum class PackState : uint8_t
    {
        NONE     = 0,
        PACKED   = 1,
        UNPACKED = 2,
    };

    // ---

    std::string _name;

    uint8_t* _data = nullptr;

    PackState pack_state = PackState::NONE;

    bool b_locked    = false; // True if data has been locked
    bool b_data_init = false; // True if data has been initialized

    size_t data_size = 0; // File size in bytes

    // Delete copy constructor and assignment operator
    GemFile(const GemFile&) = delete;
    GemFile& operator=(const GemFile&) = delete;

    // ---

    void read_binary_file(const std::string& file_path)
    {
        // Normalize file path
        const std::filesystem::path __file_path(file_path);
        const std::string _file_path = __file_path.lexically_normal().string();

        // Try to open file
        std::ifstream file(_file_path, std::ios::binary | std::ios::ate);

        if ( !file.is_open() )
        {
            return;
        }

        /// 
        //    FILE SIZE AND DATA

        data_size = file.tellg();
        if (data_size == 0)
        {
            return;
        }

        init_data(data_size); // Init memory

        if (!b_data_init)
        {
            return;
        }

        file.seekg(0, std::ios::beg);
        file.read(reinterpret_cast<char*>(_data), data_size);
        file.close();

        sodium_mprotect_readonly(_data); // Read-only
        b_locked = true;

        ///
        //   FILE NAME

        _name = std::filesystem::path( _file_path ).filename().string();
    }

    static void free_data(uint8_t*& fdata)
    {
        if (fdata == nullptr) return;

        sodium_mprotect_readwrite(fdata); // Read-write
        sodium_free(fdata);               // Secure erase
        fdata = nullptr;
    }
};

//
//    DRAGON RNG [ OUROBOROS CLASS CSPRNG ]
//
//    Cryptographically secure pseudo random number generator implemented with XChaCha20.
//
//    Fast forwards in O(1) time. Can warp universes by eating its own tail.
//
//    Seed is hashed before storing in memory and is securely erased upon destruction.

class DragonRNG
{
public:

    static constexpr uint64_t SEED_SIZE   = crypto_stream_xchacha20_KEYBYTES;   // 256-bit
    
    using RNGSeed = std::array<uint8_t, SEED_SIZE>;

    // --

    // Constructor that initializes with true random seed
    DragonRNG()
    {
        seed_from_true_random();
    }

    // Constructor that initializes with seed of arbitrary size in bytes
    template <typename T>
    DragonRNG(const T* seed, const size_t seed_size)
    {
        initialize( seed, seed_size );
    }

    // Constructor that initializes thet state with a 256-bit seed and warps to universe at coords
    template<typename T, std::size_t N>
    DragonRNG(const T* seed, const size_t seed_size, const RNGWarp<N>& coords)
    : DragonRNG( seed, seed_size )
    {
        warp( coords );
    }

    // Constructor that initializes thet state with a 256-bit seed and warps to universe at coords
    template<typename T>
    DragonRNG(const T* seed, const size_t seed_size, const GhostVector<uint64_t>& coords)
    : DragonRNG( seed, seed_size )
    {
        warp( coords );
    }

    // Constructor that initializes thet state with a 256-bit seed and warps to universe at (coords, terminal_coord)
    template<typename T, std::size_t N>
    DragonRNG(const T* seed, const size_t seed_size, const RNGWarp<N>& coords, const uint64_t terminal_coord)
    : DragonRNG( seed, seed_size )
    {
        std::vector<uint64_t> final_coords;

        for ( const auto& coord : coords )
        {
            final_coords.push_back( coord );
        }

        final_coords.push_back( terminal_coord );

        warp( final_coords );
    }

    // Constructor that initializes with a XOR Key as seed
    DragonRNG(const RNGSeed& seed)
    {
        initialize(seed.data(), seed.size());
    }

    // Constructor that initializes with a XOR Key as seed
    template<std::size_t N>
    DragonRNG(const RNGSeed& seed, const RNGWarp<N>& coords)
    : DragonRNG(seed)
    {
        warp(coords);
    }

    // Constructor that seeds from a string
    DragonRNG(const std::string& str)
    {
        initialize(str.data(), str.size());
    }

    // Constructor that seeds from a string and warps to universe at coords
    template<std::size_t N>
    DragonRNG(const std::string& str, const RNGWarp<N>& coords)
    {
        warp(coords);
    }

    ~DragonRNG()
    {
        vanish(); // Secure erase
    }

    // --

    uint64_t rand()
    {
        return rand<uint64_t>();
    }

    uint8_t rand_byte()
    {
        return rand<uint8_t>();
    }

    // Returns random number in 0 .. 1 range (inclusive)
    double rand_percent()
    {
        return static_cast<double>( rand() ) / std::numeric_limits<double>::max();
    }

    bool rand_bool()
    {
        return (rand() & 1) == 1;
    }

    // Returns a random bool that is true chance_true percent of the time
    // chance_true should be float in range 0 .. 1 inclusive
    bool rand_bool(const double chance_true)
    {
        return rand_percent() < chance_true;
    }

    template <typename T>
    T rand()
    {
        static_assert(std::is_integral<T>::value || std::is_floating_point<T>::value,
            "DragonRNG :: rand() :: Type T must be an integral or floating point type");

        // Ensure there are enough bytes left in the block to read 64 bits
        if ( BLOCK_SIZE - offset_in_block <= sizeof(T) )
        {
            update_cipher_stream_block(); // Load new block
        }
        
        T _rand;
        std::memcpy( &_rand, &current_block[ offset_in_block ], sizeof( _rand ) );
        offset_in_block += sizeof( _rand );

        return _rand;
    }

    // Generates a random number in range start .. end (inclusive)
    template <typename T>
    T rand_range(const T end, T start = 0)
    {
        static_assert(std::is_unsigned<T>::value, "T must be an unsigned integer type");

        if ( start > end )
        {
            throw _E("DragonRNG :: rand_range() :: start > end");
        }

        // --

        if ( start == end || end == 0 )
        {
            return end;
        }

        T range = end - start;

        if ( end != std::numeric_limits<T>::max() )
        {
            range += 1; // Won't cause overflow
        }

        const T bias_limit =
            (( std::numeric_limits<T>::max() - range ) + 1 ) % range;

        T rnd = rand<T>();

        while ( rnd < bias_limit )
        {
            rnd = rand<T>();
        }

        return start + (rnd % range);
    }

    // Shuffles a container in place using Fisher-Yates shuffle
    template <typename T>
    void shuffle(T& container)
    {
        for (uint64_t i = container.size() - 1; i >= 1; --i)
        {
            const uint64_t j = rand_range<uint64_t>(i);
            std::swap(container[i], container[j]);
        }
    }

    // Fast forwards the RNG by cycles: 1 cycle is 1 byte / 8-bits of cipher stream
    void fast_forward(const uint64_t cycles)
    {
        // Fast forward nonce
        if ( cycles > 0 )
        {
            nonce_ff.fill(0); // Init nonce_ff to zero

            // Write bytes_to_skip to nonce_ff
            for ( uint8_t i = 0; i < sizeof( cycles ); ++i )
            {
                // NOTE: Little-endian byte order
                nonce_ff[i] = ( cycles >> (i * 8)) & 0xFF;
            }

            // Add nonce_ff to nonce
            sodium_add( nonce.data(), nonce_ff.data(), NONCE_SIZE );
        }
    }

    template< typename T >
    void warp( const T& coords )
    {
        for ( const auto& coord : coords )
        {
            warp( coord );
        }
    }

    // Warps to cipher stream universe at coord:
    //
    // - Fast forwards WARP_STRIDE * coord bits
    // - Creates a WARP SEED by XORing seed with the next SEED_SIZE bits from the cipher stream
    // - Replaces this RNG with one seeded with the WARP SEED
    //
    // The RNG eats its own tail and vanishes from this universe, warping to a new one!
    void warp( const uint64_t coord )
    {
        fast_forward( coord * WARP_STRIDE );
        warp(); // Warp to new universe!
    }

    // XOR seed with next 256-bits of the cipher stream and
    // replace self with new RNG seeded with the mutated seed.
    void warp()
    {
        // Create WARP SEED by XORing seed with next 256 bits of cipher stream
        auto warp_seed = seed;

        for (auto& byte : warp_seed)
        {
            byte ^= rand_byte();
        }

        // Replace this RNG with a new RNG seeded with WARP SEED
        initialize( warp_seed );

        // Secure erase WARP SEED
        sodium_memzero( warp_seed.data(), warp_seed.size() );
    }

    // Returns random RNG Seed
    RNGSeed rand_seed()
    {
        RNGSeed rand_seed;

        for (int i = 0; i < rand_seed.size(); ++i)
        {
            rand_seed[i] = rand_byte();
        }

        return rand_seed;
    }

    // Secure erase self
    void vanish()
    {
        if (sodium_init() < 0)
        {
            return;
        }

        sodium_memzero(seed.data(), seed.size());
        sodium_memzero(nonce.data(), nonce.size());
        sodium_memzero(nonce_ff.data(), nonce_ff.size());
        sodium_memzero(current_block.data(), current_block.size());
        sodium_memzero(&offset_in_block, sizeof offset_in_block);
    }

private:

    static constexpr uint64_t NONCE_SIZE  = crypto_stream_xchacha20_NONCEBYTES; // 192-bits
    static constexpr uint64_t BLOCK_SIZE  = 64; // 512-bit
    static constexpr uint64_t WARP_STRIDE = SEED_SIZE;

    std::array<uint8_t, SEED_SIZE> seed; // Hash of seed
    std::array<uint8_t, NONCE_SIZE> nonce;
    std::array<uint8_t, NONCE_SIZE> nonce_ff; // For fast forwarding nonce
    std::array<uint8_t, BLOCK_SIZE> current_block;

    uint64_t offset_in_block = BLOCK_SIZE;

    // --

    template <typename T>
    void initialize(const T& init)
    {
        initialize( init.data(), init.size() );
    }

    // Seeds RNG with hash of init
    template <typename T>
    void initialize(const T* init, const size_t init_size)
    {
        // Hash the init data into seed
        if (crypto_generichash(
            seed.data(),
            seed.size(),
            reinterpret_cast<const unsigned char*>(init),
            init_size,
            nullptr, 0) != 0 )
        {
            throw _E("Generic hash failed. Cannot initialize DragonRNG.");
        }

        nonce.fill(0);
        current_block.fill(0);
        offset_in_block = BLOCK_SIZE; // Trigger block load
    }

    void seed_from_true_random()
    {
        uint8_t seed[ SEED_SIZE ];
        TRUE_RANDOM::rand_bytes( &seed, sizeof(seed) );
        initialize( seed, sizeof(seed) );
    }

    void increment_nonce()
    {
        // NOTE: Little-endian byte increment order
        sodium_increment(nonce.data(), nonce.size());
    }

    // Writes new cipher stream block to current_block if offset_in_block >= BLOCK_SIZE
    void update_cipher_stream_block()
    {
        crypto_stream_xchacha20(
            current_block.data(),
            BLOCK_SIZE,
            nonce.data(),
            seed.data()
        );

        offset_in_block = 0;
        increment_nonce();
    }
};

//
//    THE CYCLE KEY
//
//    Ravenous shapeshifting sword made of fire and light that turns every way,
//    wrapped with a water breathing serpent that eats its own tail.

class CycleKey
{
public:

    CycleKey() {}

    ~CycleKey()
    {
        vanish();
    }

    const uint8_t* salt() const { return _salt; }

    size_t salt_size() const { return SALT_SIZE; }

    uint8_t* salt_write()
    {
        mem_init();

        return _salt;
    }

    void init(const std::string& password)
    {
        if (b_locked)
        {
            throw _E("Tried to initialize CycleKey that is locked.");
        }

        mem_init();
        gen_key( password );
    }

    // Regenerates the Cycle Key using the next 640 bits
    // of output from the RNG as the password and salt.
    void regenerate()
    {
        if ( !b_mem_init )
        {
            throw _E("CycleKey memory must be initialized before generating key.");
        }

        GhostVector<uint8_t> rand_password( KEY_SIZE );
        GhostVector<uint8_t> rand_salt( SALT_SIZE );

        for ( int i = 0; i < KEY_SIZE; ++i )
        {
            rand_password[i] = rand<uint8_t>();
        }

        for ( int i = 0; i < SALT_SIZE; ++i )
        {
            rand_salt[i] = rand<uint8_t>();
        }
        
        vanish(); // WITHOUT A TRACE !!!

        mem_init(); // Re-init memory

        // Set random 128-bit salt
        std::memcpy( _salt, rand_salt.data(), SALT_SIZE );

        gen_key( rand_password ); // ( the sword turns upon itself )
    }

    size_t key_size() const
    {
        return KEY_SLICE_SIZE;
    }

    const uint8_t* key()  const
    {
        // It will be revealed with fire ...
        return _fire_key;
    }

    // Cycles the key after copying if b_cycle is true
    GhostVector<uint8_t> copy_key(const bool b_cycle = true)
    {
        if ( ! b_mem_init )
        {
            throw _E("Cycle Key :: Tried to copy key before memory was initialized.");
        }

        GhostVector<uint8_t> key_copy( KEY_SLICE_SIZE );

        for (int i = 0; i < KEY_SLICE_SIZE; ++i)
        {
            key_copy[i] = _fire_key[i];
        }

        if ( b_cycle )
        {
            cycle(); // Generates new Fire Key
        }

        return key_copy;
    }

    // Returns a copy of current RNG
    // Cycles the key after copying the RNG if b_cycle is true
    DragonRNG copy_RNG(const bool b_cycle = true)
    {
        if ( b_cycle )
        {
            DragonRNG copy_rng = fire_rng;

            cycle(); // Initializes new RNG

            return copy_rng;
        }

        return fire_rng;
    }

    // If auto_cycle > 0 then the Fire Key will automatically cycle
    // each time auto_cycle num bytes are consumed.
    void auto_cycle(const uint64_t _auto_cycle_bytes)
    {
        auto_cycle_bytes = _auto_cycle_bytes;
    }

    // Cycles to next Fire Key slice, consuming all Key Food, and re-seeds Fire RNG
    void cycle()
    {
        // Gusting to the south, turning to the north,
        // turning, turning, goes the wind,
        // and the wind returns in its cycles.

        cycle_index += 1;

        if ( cycle_index >= NUM_KEY_SLICES )
        {
            cycle_index = 0;
            fire_rng.shuffle( key_slice_order );
        }

        fire_key_index = key_slice_order[ cycle_index ];

        update_keys(); // Init new Fire Key

        // Re-seed Fire RNG with new Fire Key
        fire_rng = DragonRNG( _fire_key, KEY_SLICE_SIZE );
    }

    void reset_cycle()
    {
        cycle_index      = 0;
        fire_key_index   = 0;
        auto_cycle_bytes = 0;

        food_pile.vanish();
        sodium_memzero(_key_food, KEY_SLICE_SIZE);

        // Bootstrap RNG with first raw key slice
        fire_rng = DragonRNG( _key, KEY_SLICE_SIZE );

        // Re-init Fire Key slice order
        for (uint64_t i = 0; i < NUM_KEY_SLICES; ++i)
        {
            key_slice_order[i] = static_cast<KeySliceIndex>(i);
        }

        fire_rng.shuffle( key_slice_order ); // Randomize key slice order

        update_keys(); // Init keys
    }

    template<typename F>
    void consume(const F& key_food)
    {
        consume_internal(key_food);
    }

    template<typename F, std::size_t N>
    void consume(const std::array<F, N>& key_food)
    {
        for (const auto& food : key_food)
        {
            consume_internal(food);
        }
    }

    template<template<typename> class T, typename F>
    void consume(const T<F>& key_food)
    {
        for (const auto& food : key_food)
        {
            consume_internal(food);
        }
    }

    template <typename T>
    T rand()
    {
        T _rand = fire_rng.rand<T>();
        consume( _rand ); // Consume random output

        return _rand;
    }

    bool rand_bool()
    {
        bool _rand = fire_rng.rand_bool();
        consume( _rand ); // Consume random output

        return _rand;
    }

    template <typename T>
    T rand_range(const T end, T start = 0)
    {
        T _rand = fire_rng.rand_range<T>(end, start);
        consume( _rand ); // Consume random output

        return _rand;
    }


    template<typename T, std::size_t N>
    std::array<T, N> rand_sequence(const size_t len, T start = 0)
    {
        std::array<T, N> seq;

        for (T i = start; i < start + len; ++i)
        {
            seq[ i - start ] = i;
        }

        // Shuffle sequence in place using Fisher-Yates shuffle
        for (size_t i = seq.size() - 1; i >= 1; --i)
        {
            size_t j = rand_range<size_t>(i); // Consumes rand
            std::swap(seq[i], seq[j]);
        }

        return seq;
    }

    bool is_valid() const
    {
        return b_locked && b_mem_init && _key != nullptr && _salt != nullptr;
    }

    void vanish()
    {
        cycle_index      = 0;
        fire_key_index   = 0;
        auto_cycle_bytes = 0;

        fire_rng.vanish();
        food_pile.vanish();

        if (!b_mem_init)
        {
            return;
        }
        else if (sodium_init() < 0)
        {
            return;
        }

        if (b_locked)
        {
            sodium_mprotect_readwrite(_key);
            sodium_mprotect_readwrite(_salt);

            sodium_munlock(_key, KEY_SIZE);
            sodium_munlock(_salt, SALT_SIZE);
            sodium_munlock(_fire_key, KEY_SLICE_SIZE);
            sodium_munlock(_key_food, KEY_SLICE_SIZE);
        }

        sodium_free(_key);
        sodium_free(_salt);
        sodium_free(_fire_key);
        sodium_free(_key_food);

        _key      = nullptr;
        _salt     = nullptr;
        _fire_key = nullptr;
        _key_food = nullptr;

        sodium_memzero(key_slice_order.data(), key_slice_order.size());

        b_locked   = false;
        b_mem_init = false;
    }

private:

    using KeySliceIndex = uint8_t;
    using KeyFoodIndex  = uint8_t;

    static constexpr uint64_t KEY_SIZE       = 64;                                 // 512-bit key
    static constexpr uint64_t KEY_SLICE_SIZE = 32;                                 // 256-bit key slices
    static constexpr uint64_t NUM_KEY_SLICES = KEY_SIZE / KEY_SLICE_SIZE;          // 2 key slices
    static constexpr uint32_t KEY_ALGO       = crypto_pwhash_ALG_ARGON2ID13;       // Argon2id
    static constexpr uint64_t KEY_OPSLIMIT   = crypto_pwhash_OPSLIMIT_INTERACTIVE; // 2 opslimit
    static constexpr uint64_t KEY_MEMLIMIT   = crypto_pwhash_MEMLIMIT_INTERACTIVE; // 64 MB
    static constexpr uint32_t SALT_SIZE      = crypto_pwhash_SALTBYTES;            // 128-bit salt

    bool b_locked   = false;
    bool b_mem_init = false;

    uint8_t* _key      = nullptr;
    uint8_t* _salt     = nullptr;
    uint8_t* _fire_key = nullptr;
    uint8_t* _key_food = nullptr;

    uint64_t cycle_index      = 0;
    uint64_t fire_key_index   = 0;
    uint64_t auto_cycle_bytes = 0;

    DragonRNG fire_rng;

    std::array<KeySliceIndex, NUM_KEY_SLICES> key_slice_order;

    GhostVector<uint8_t> food_pile; // Bytes to be hashed into _key_food

    // --

    // DELETE COPY CONSTRUCTOR AND ASSIGNMENT OPERATOR
    CycleKey(const CycleKey& other)      = delete;
    CycleKey& operator=(const CycleKey&) = delete;

    // --

    template <typename F>
    void consume_internal(const F& key_food)
    {
        const uint8_t* food_bytes = reinterpret_cast<const uint8_t*>( &key_food );

        if ( auto_cycle_bytes > 0 )
        {
            // Add key food bytes to Food Pile
            for (size_t i = 0; i < sizeof(F); ++i)
            {
                food_pile.push_back( food_bytes[i] );

                if ( food_pile.size() >= auto_cycle_bytes )
                {
                    cycle(); // Auto cycle !
                }
            }
        }
        else
        {
            // Add key food bytes to Food Pile
            for (size_t i = 0; i < sizeof(F); ++i)
            {
                food_pile.push_back( food_bytes[i] );
            }
        }
    }

    // Update Key Food array and regenerate Fire Key
    void update_keys()
    {
        update_key_food();
        update_fire_key();
    }

    // Hash Food Pile into Key Food Array
    void update_key_food()
    {
        // Append curent Key Food to end of Food Pile
        // in order to incorporate previous state into hash
        food_pile.resize( food_pile.size() + KEY_SLICE_SIZE );

        std::memcpy(
            food_pile.data() + food_pile.size() - KEY_SLICE_SIZE,
            _key_food,
            KEY_SLICE_SIZE
        );

        // BLAKE2b hash food_pile into _key_food
        if (crypto_generichash(
            _key_food,
            KEY_SLICE_SIZE,
            reinterpret_cast<const unsigned char*>( food_pile.data() ),
            food_pile.size(),
            nullptr, 0) != 0 )
        {
            throw _E("Generic hashing failed while updating Cycle Key food array.");
        }

        food_pile.clear(); // Food Pile is now gone !
    }

    void update_fire_key()
    {
        const uint8_t* fire_cycle = &_key[ KEY_SLICE_SIZE * fire_key_index ];

        // Copy current key slice into Fire Key
        std::memcpy( _fire_key, fire_cycle, KEY_SLICE_SIZE );

        // XOR Fire Key with Key Food
        for ( int i = 0; i < KEY_SLICE_SIZE; ++i )
        {
            _fire_key[i] ^= _key_food[i]; // Feed the fire
        }
    }

    void mem_init()
    {
        if (b_mem_init)
        {
            return;
        }
        else if (sodium_init() < 0)
        {
            throw _E("Cannot initialize CycleKey memory: libsodium could not be initialized.");
        }

        // All bytes get initialized to 0xdb (219) by sodium_malloc
        _key      = (uint8_t*)sodium_malloc(KEY_SIZE);
        _salt     = (uint8_t*)sodium_malloc(SALT_SIZE);
        _fire_key = (uint8_t*)sodium_malloc(KEY_SLICE_SIZE);
        _key_food = (uint8_t*)sodium_malloc(KEY_SLICE_SIZE);

        // Zero bytes
        sodium_memzero(_key, KEY_SIZE);
        sodium_memzero(_salt, SALT_SIZE);
        sodium_memzero(_fire_key, KEY_SLICE_SIZE);
        sodium_memzero(_key_food, KEY_SLICE_SIZE);

        b_mem_init = true;
    }

    void lock()
    {
        if (!b_mem_init)
        {
            throw _E("Tried to lock CycleKey before initializing memory.");
        }
        else if (b_locked)
        {
            return; // Already locked
        }

        // Prevent from being swapped to disk
        sodium_mlock(_key, KEY_SIZE);
        sodium_mlock(_salt, SALT_SIZE);
        sodium_mlock(_fire_key, KEY_SLICE_SIZE);
        sodium_mlock(_key_food, KEY_SLICE_SIZE);

        // Lock read-only
        sodium_mprotect_readonly(_key);
        sodium_mprotect_readonly(_salt);

        // NOTE: Fire Key and Key Food can be mutated

        b_locked = true;
    }

    void gen_key(const std::string& password)
    {
        gen_key( password.data(), password.size() );
    }

    void gen_key(const GhostVector<uint8_t>& password)
    {
        gen_key( reinterpret_cast<const char*>( password.data() ), password.size() );
    }

    void gen_key(const char* password, size_t password_size)
    {
        if (!b_mem_init)
        {
            throw _E("CycleKey memory must be initialized before generating key.");
        }
        else if (sodium_init() < 0)
        {
            throw _E("libsodium could not be initialized.");
        }

        if ( crypto_pwhash(
            static_cast<unsigned char* const>(_key),
            KEY_SIZE,
            static_cast<const char* const>(password),
            password_size,
            static_cast<const unsigned char*>(_salt),
            KEY_OPSLIMIT,
            KEY_MEMLIMIT,
            KEY_ALGO ) != 0 )
        {
            throw _E("Password hashing failed. Cannot generate Cycle Key.");
        }

        ///
        //    DONE

        lock(); // Lock data read-only and prevent swapping to disk

        reset_cycle(); // Init keys and RNG
    }
};

//
//    BIT STREAM
//
//    Reads bits from bytes in input_bytes array in order of LSB to MSB
//
//    Will not modify Ghost Vector.

class BitStream
{
public:

    BitStream() {}
    BitStream(const GhostVector<uint8_t>& input_bytes) : bytes(&input_bytes) {}

    bool get_bits(uint8_t& out_bit, const uint8_t num_bits, uint64_t start_bit) const
    {
        return get_bits_from(num_bits, out_bit, start_bit);
    }

    // Returns the byte in bytes that contains bit at bit_index
    uint8_t get_byte_at_bit_index(const uint64_t bit_index) const
    {  
        if (bytes == nullptr)
        {
            printf("ERROR: Attempted to get byt at index from BitStream with nullptr bytes array.\n");
            
            return 0;
        }

        const size_t index = bit_index / 8;
        if (index < bytes->size())
        {
            return (*bytes)[ index ];
        }

        return 0;
    }

    uint64_t get_num_bytes() const
    {
        if (bytes == nullptr)
        {
            printf("ERROR: Attempted to get num bytes from BitStream with nullptr bytes array.\n");
            
            return 0;
        }

        return bytes->size();
    }

    uint64_t get_num_bits() const
    {
        return get_num_bytes() * 8;
    }

    const GhostVector<uint8_t>& get_bytes() const
    {
        if ( bytes != nullptr )
        {
            return *bytes;
        }

        static GhostVector<uint8_t> NULL_BYTES;

        return NULL_BYTES; // Empty vector on error
    }

    bool is_valid_index(const uint64_t start_bit) const
    {
        return start_bit < get_num_bits();
    }

    void vanish()
    {
        bytes = nullptr;
    }

private:

    // Pointer to bytes vector to stream bits from
    const GhostVector<uint8_t>* bytes = nullptr;

    BitStream(const uint8_t& byte) = delete;

    bool get_bits_from(uint8_t num_bits, uint8_t& out_value, uint64_t start_bit) const
    {
        if (bytes == nullptr)
        {
            printf("ERROR: Attempted to get bits from BitStream with nullptr bytes array.\n");
            
            return false;
        }

        size_t start_byte = start_bit / 8;
        uint8_t bit_index = start_bit % 8;

        // Validate last read index
        if (!is_valid_index(start_bit + num_bits - 1))
        {
            return false;
        }

        out_value = 0;

        for (uint8_t i = 0; i < num_bits; ++i)
        {
            // Read from LSB to MSB
            uint8_t bit = ((*bytes)[start_byte] >> bit_index) & 0x01;

            // Shift the out_value to the left by 1 and add the new bit to the LSB
            out_value |= (bit << i);

            bit_index++;

            if (bit_index == 8)
            {
                bit_index = 0;
                start_byte++;
            }
        }

        return true;
    }
};

//
//    BIT COLLECTOR
//
//    Reads bits from bytes in input_bytes array in order of LSB to MSB

class BitCollector
{
public:

    BitCollector() {}

    // Returns true if a new byte was pushed to the vector
    bool add_bits(uint8_t in_bits, uint8_t num_bits)
    {
        bool b_pushed = false;

        for (uint8_t i = 0; i < num_bits; ++i)
        {
            // Extract the relevant bit from in_bits (from LSB to MSB)
            uint8_t bit = (in_bits >> i) & 0x01;

            b_last_bit_was_zero = bit == 0;

            // Shift the current_byte to the left by 1 and add the new bit to the LSB
            current_byte |= (bit << write_bit_index);

            ++write_bit_index;

            // If we've filled up a byte, push it to the vector
            if (write_bit_index == 8)
            {
                b_pushed = true;
                new_bytes.push_back(current_byte);
                current_byte = 0;
                write_bit_index = 0;
            }
        }

        return b_pushed;
    }

    uint8_t get_current_byte() const
    {
        return current_byte;
    }

    GhostVector<uint8_t>& get_bytes()
    {
        return collected_bytes;
    }

    const GhostVector<uint8_t>& get_bytes() const
    {
        return collected_bytes;
    }

    uint64_t get_num_bytes() const
    {
        return collected_bytes.size();
    }

    uint64_t get_num_bits() const
    {
        return collected_bytes.size() * 8;
    }

    uint64_t get_num_new_bytes() const
    {
        return new_bytes.size();
    }

    // Adds first new byte to collected bytes
    // Returns true if byte collected
    bool collect_new_byte()
    {
        if (new_bytes.empty())
        {
            return false;
        }

        collected_bytes.push_back(new_bytes.front());
        new_bytes.erase(new_bytes.begin());

        return true;
    }

    uint8_t back() const
    {
        return collected_bytes.back();
    }

    void clear_collected_bytes()
    {
        collected_bytes.clear();
    }

    bool last_bit_was_zero() const
    {
        return b_last_bit_was_zero;
    }

    bool last_bit_was_one() const
    {
        return ! b_last_bit_was_zero;
    }

private:

    GhostVector<uint8_t> collected_bytes;
    GhostVector<uint8_t> new_bytes;
    uint8_t current_byte = 0;
    uint8_t write_bit_index = 0;
    bool b_last_bit_was_zero = true;
};

//
//    HIDEAGEM
//

class HideAGem
{
public:

    HideAGem( GemOcean& _ocean );

    ~HideAGem();

    ///
    //    PUBLIC API

    bool b_print_gem_hash = true;
    bool b_print_gem_seal = true;

    // Writes Gem Files in file_paths to OCEAN that is set in constuctor.
    //
    // Gem Files will be read back from the OCEAN and their bytes validated if b_validate is true.
    bool hide_gem_files(
        int gem_protocol,
        const std::vector<std::string>& file_path,
        const std::string& password,
        const int time_trap = static_cast<int>(ETimeTrapLevel::NONE),
        bool b_validate = false
    );

    bool hide_gem_files(
        int gem_protocol,
        std::vector<GemFile>& gem_files,
        const std::string& password,
        const int time_trap = static_cast<int>(ETimeTrapLevel::NONE),
        bool b_validate = false
    );

    // Searches gem_image for Gem Files using password, adding any found to out_gem_files.
    //
    // Output Gem Files will be in unpacked state.
    //
    // Returns number of gem files found.

    uint64_t find_gem_files(
        const std::string& password,
        std::vector<GemFile>& out_gem_files,
        const bool b_time_trap
    );

    ///
    //    INFO

    uint64_t get_remaining_byte_capacity() const;

    ///
    //    GEM HASH AND SEAL

    void print_gem_hash() const;

    void PRINT_GEM_SEAL() const;

    const std::string& GET_GEM_HASH() const { return GEM_HASH; }
    const std::string& GET_GEM_SEAL() const { return GEM_SEAL; }

    ///
    //    DIAGNOSTICS

    EGemErrorCode get_error_code() const { return ERROR_CODE; }

protected:

    bool b_pristine;      // False if instance has been used to hide or find gems
    bool b_validate_read; // If true Gem Files will be read from image after hiding to validate

    bool b_lock_ocean_write = true;
    bool b_keys_initialized = false;
    bool b_gem_header_bytes_reserved = false;

    CycleKey MASTER_KEY;

    GhostVector<uint8_t> GEM_STREAM_ENCRYPT_KEY;

    uint64_t TIME_TRAP_CYCLE_RATE = 0;

    GemProtocol GEM_PROTOCOL;
    EGemProtocolKey GEM_PROTOCOL_KEY = EGemProtocolKey::NONE;

    EGemErrorCode ERROR_CODE = EGemErrorCode::NONE;

    GemOcean& OCEAN; // Cover OCEAN

    uint64_t max_ocean_index = 0; // Max index of OCEAN

    DragonRNG SHARED_RNG;
    DragonRNG DATA_WHITEN_RNG;
    DragonRNG BYTE_COUNT_ENCRYPT_RNG;
    DragonRNG READ_STOP_BYTES_ENCRYPT_RNG;

    BitStream gem_bit_stream;
    std::vector<GemFile> gem_files;

    EBitMode GEM_BIT_MODE = EBitMode::NONE;

    std::string GEM_HASH;
    std::string GEM_SEAL;

    ///
    //    GEM PROTOCOL

    bool init_gem_protocol(const EGemProtocolKey gem_protocol);

    // Auto-reserves Gem Header Ocean bytes
    void write_gem_header(const EGemProtocolKey gem_protocol_key);

    // Auto-reserves Gem Header Ocean bytes
    EGemProtocolKey read_gem_header();

    ///
    //    TIME TRAP

    ETimeTrapLevel TIME_TRAP_LEVEL = ETimeTrapLevel::NONE;

    ///
    //    RANDOM OCEAN BYTES

    OceanIndex get_rand_ocean_byte_index()
    {
        return get_rand_ocean_byte_index( MASTER_KEY );
    }

    template <typename T>
    OceanIndex get_rand_ocean_byte_index(T& rng)
    {
        while ( OCEAN.num_bytes_remaining() > 0 )
        {
            const OceanIndex idx =
                rng.rand_range( static_cast<OceanIndex>( OCEAN.size() - 1 ));

            if ( ! OCEAN.is_reserved( idx ) )
            {
                OCEAN.reserve( idx );

                return idx;
            }
        }

        throw _E("\nRan out of Ocean bytes !\n");

        return ERROR_INDEX;
    }

    ///
    //    MASTER KEY AND SALT

    // Generates salt of salt_size
    void gen_salt(
        uint8_t* salt,
        const uint64_t salt_size,
        const std::string& password
    );

    // Initializes the Master Key
    void init_master_key(const std::string& password);

    // Erases keys and other sensitive data
    void erase_sensitive_data(const bool b_erase_hash = true);

    ///
    //    ENCRYPTION

    // Uses a shared RNG: Decrypt order must exactly match encrypt order.
    GemSize encrypt_gem_stream_byte_count(
        const GemSize byte_count,
        const GemSize byte_capacity
    );

    // Uses a shared RNG: Decrypt order must exactly match encrypt order.
    GemSize decrypt_gem_stream_byte_count(
        const GemSize encrypted_padded_byte_count,
        const GemSize byte_capacity
    );

    ///
    //    COMPRESSION

    // Gem compression and uncompression with zlib
    static GemFile compress_gem(const GemByte* gem_bytes, const uint64_t gem_byte_count);
    static GemFile uncompress_gem(const GemByte* compressed_gem, const uint64_t byte_count);

    ///
    //    HIDE GEMS

    // Expects Gem Files to be unpacked (they will get packed)
    bool hide_gem_files_internal(
        std::vector<GemFile>& gem_files,
        const std::string& password
    );

    // Writes bit_stream to gem_image
    // Does not reset cycle before writing
    bool GEMMA_RANDOM_write_bit_stream_to_ocean(
        BitStream& bit_stream,
        const EBitMode bit_mode,
        const bool b_print_status = false
    );

    ///
    //    FIND GEMS

    void find_gem_files(const bool b_time_trap = false);

    // Uses prepared MASTER_KEY to extract bits from cover image
    // Extracts up to max_bytes or until a Gem Stream is read
    // Does not reset MASTER_KEY before extracting bits
    BitCollector GEMMA_RANDOM_extract_gem_bits(
        const EBitMode bit_mode,
        const uint64_t max_bytes = 0,
        const bool b_print_status = false
    );

    BitCollector GEMMA_RANDOM_extract_gem_bits_TIME_TRAP(
        const EBitMode bit_mode,
        const uint64_t max_bytes = 0
    );

    void process_extracted_gem_stream(GhostVector<GemByte>& gem_stream);

    //
    //    WRITE GEM DATA TO OCEAN

    GemByte write_bits_to_byte_LSB_MATCHING(
        const GemByte byte, 
        const GemByte data,
        const uint8_t num_LSB
    ) const;

    bool write_bit_stream_to_byte_LSB_MATCHING(
        GemByte& byte,
        GemBitIndex bit_index,
        const BitStream& bit_stream,
        const EBitMode bit_mode
    ) const;

    ///
    //    READ / WRITE OCEAN BYTES

    GemByte read_ocean_byte(const OceanIndex ocean_index) const;

    void write_ocean_byte(const OceanIndex ocean_index, const GemByte& byte);

    ///
    //    BIT TRAP

    void write_bit_trap_to_ocean(const uint64_t trap_val);

    uint64_t read_bit_trap_from_ocean();

    ///
    //    TIME TRAP

    void set_time_trap_level( const int time_trap );

    void init_time_trap_cycle_rate(const uint64_t num_gem_bytes);

    ///
    //    RANDOM

    void process_final_RNG_state(DragonRNG& rng);

    ///
    //    GEM HASH

    void gen_gem_hash(const DragonRNG::RNGSeed& seed);

    ///
    //    GEM SEAL

    void READ_GEM_SEAL(const DragonRNG::RNGSeed& seed);

    ///
    //    CONSTANTS

    static constexpr const char* GEM_VALIDATION_OCEAN_BYTE_SET_NAME = "__VALIDATE__";
};

//
//    HIDEAGEM CORE API
//

// Returns Gem Ocean (ocean with Gem Files embedded in it)
// with valid data upon success and nullptr upon failure.
//
// Creates a copy of ocean of size ocean_size bytes.
GemOcean hide_gems(
    int gem_protocol,
    const void* ocean,
    uint64_t ocean_size,
    std::vector<GemFile>& gem_files,
    const std::string& password,
    int time_trap = static_cast<int>(ETimeTrapLevel::NONE),
    bool b_validate = false
);

GemOcean hide_gems(
    int gem_protocol,
    const void* ocean,
    uint64_t ocean_size,
    const std::vector<std::vector<std::string>>& file_paths,
    const std::vector<std::string>& passwords,
    const std::vector<int> time_traps,
    bool b_validate = false
);

std::vector<GemFile> find_gems(
    const void* ocean,
    uint64_t _ocean_size,
    const std::vector<std::string>& passwords,
    const std::string* output_dir = nullptr,
    const std::vector<bool> time_traps = std::vector<bool>()
);

//
//    MINIZ COMPRESSION / DECOMPRESSION
//

bool miniz_compress
(
    uint8_t*  input, 
    uint64_t  input_size, 
    uint8_t*  output, 
    uint64_t* output_size
);

bool miniz_decompress
(
    uint8_t*  input, 
    uint64_t  input_size, 
    uint8_t*  output, 
    uint64_t* output_size
);

//
//    UTILITIES
//

std::string bytes_to_size_string(const uint64_t size, const int max_unit_index = 4, const bool b_decimal = true);

// Convert integer to base 26 (A .. Z) representation
std::string int_to_base_26(uint64_t n);

// Normalize unicode string
std::string normalize_unicode(const std::string& input);

//
//    DEBUG ZONE
//

bool RUN_UNIT_TESTS(bool b_loop = false, bool b_demo_mode = false);


// Print bits of val as string
template<typename T>
void _PBITS(T val)
{
    std::cout << " __ BITS __ :: ";
    for (int i = 0; i < 8 * sizeof(T); ++i)
    {
        std::cout << ((val >> i) & 1);
    }
    std::cout << "\n\n";
}


// Print bytes as integers
template<typename T>
void _PBYTES(const T* bytes, const uint64_t size, const std::string& label = "BYTES")
{
    std::cout << " __ " << label << " __ ::\n\n";

    for (uint64_t i = 0; i < size; ++i)
    {
        std::cout << (int)bytes[i] << " :: ";
    }

    std::cout << "\n\n";
}


// Print hash of data block
void _PHASH(const void* data, std::size_t size)
{
    unsigned char hash[crypto_generichash_BYTES];

    if (crypto_generichash(hash, sizeof(hash), (const unsigned char*)data, size, NULL, 0) != 0)
    {
        std::cerr << "Hashing failed." << std::endl;
        return;
    }

    std::cout << " __ HASH __ :: ";

    // Print the hash as hexadecimal
    for (size_t i = 0; i < sizeof(hash); ++i)
    {
        std::cout << std::hex << std::setw(2) << std::setfill('0') << (int)hash[i];
    }

    std::cout << std::endl << std::endl;
}

//
//    TERMINAL
//

std::map<const char*, const char*> TERM_COLORS = {

    {"BLACK", "\033[30m"},
    {"RED", "\033[31m"},
    {"GREEN", "\033[32m"},
    {"YELLOW", "\033[33m"},
    {"BLUE", "\033[34m"},
    {"MAGENTA", "\033[35m"},
    {"CYAN", "\033[36m"},
    {"WHITE", "\033[37m"},
    {"BLACK_BRIGHT", "\033[90m"},
    {"RED_BRIGHT", "\033[91m"},
    {"GREEN_BRIGHT", "\033[92m"},
    {"YELLOW_BRIGHT", "\033[93m"},
    {"BLUE_BRIGHT", "\033[94m"},
    {"MAGENTA_BRIGHT", "\033[95m"},
    {"CYAN_BRIGHT", "\033[96m"},
    {"WHITE_BRIGHT", "\033[97m"}
};

void WRITE_STD_OUT(const char* str, va_list args);
void PRINT(const char* str, va_list args);
void PRINT(const char* str, ...);
void PRINT_COLOR(const char* color, const char* str, ...);
void PRINT_COLOR(const char* color, const char* str, va_list args);
void PRINT_SUCCESS(const char* str, ...);
void PRINT_WARNING(const char* str, ...);
void PRINT_ERROR(const char* str, ...);
void PRINT_NO_NEWLINE(const char* str, ...);
void PRINT_SAME_LINE(const char* str, ...);
void PRINT_SAME_LINE_COLOR(const char* color, const char* str, ...);
void HIDE_TERM_CURSOR();
void SHOW_TERM_CURSOR();
void RESET_TERM_CURSOR();
bool STDIN_YES_OR_NO();
void PRINT_SPLASH_SCREEN();

///
//    SIGNALS INTELLIGENCE

bool EXIT_SIGNAL = false;

auto EXIT_SIGNAL_WATCHER( int signal ) { EXIT_SIGNAL = true; };

#define INIT_SIGNAL_WATCHERS() std::signal(SIGINT, EXIT_SIGNAL_WATCHER);

#define EXIT_WARDEN() if ( EXIT_SIGNAL ) { \
    ERROR_CODE = EGemErrorCode::EXIT_SIGNAL;\
    throw _E( "\n\n \033[93m>>> E X I T  S I G N A L <<<\033[0m" ); }

}; // namespace HideAGemCore

//
//    HIDEAGEM C WRAPPER FOR PYTHON
//

#if defined(_WIN32) || defined(_WIN64) // Windows (32-bit and 64-bit)
#define HIDEAGEM_DLL_EXPORT __declspec(dllexport)
#else // Linux and OS X
#define HIDEAGEM_DLL_EXPORT __attribute__((visibility("default")))
#endif

#ifdef __cplusplus
extern "C" {
#endif

#include <stdint.h>
#include <stdbool.h>

///
//    HIDE GEMS

// Returns a pointer to Gem Ocean data.
// WARNING !!! Caller is responsible for freeing Gem Ocean memory !
HIDEAGEM_DLL_EXPORT uint8_t* HIDEAGEM_HIDE_GEMS_C(
    int gem_protocol,
    void* ocean,
    uint64_t ocean_size,
    const char** file_paths,
    int file_paths_length,
    const char* password,
    int time_trap,
    uint64_t* out_ocean_size,
    bool b_validate
);

// Returns a pointer to Gem Ocean data.
// WARNING !!! Caller is responsible for freeing Gem Ocean memory !
HIDEAGEM_DLL_EXPORT uint8_t* HIDEAGEM_HIDE_GEMS_32_BIT_C(
    int gem_protocol,
    void* ocean,
    uint32_t ocean_size,
    const char** file_paths,
    int file_paths_length,
    const char* password,
    int time_trap,
    uint32_t* out_ocean_size,
    bool b_validate
);

// Returns a pointer to Gem Ocean data.
// WARNING !!! Caller is responsible for freeing Gem Ocean memory !
HIDEAGEM_DLL_EXPORT uint8_t* HIDEAGEM_HIDE_GEM_FILES_C(
    int gem_protocol,
    void* ocean,
    uint64_t ocean_size,
    const uint8_t** gem_files,
    const uint64_t* gem_file_sizes,
    const char** gem_file_names,
    const uint64_t num_gem_files,
    const char* password,
    int time_trap,
    uint64_t* out_ocean_size,
    bool b_validate
);

// Returns a pointer to Gem Ocean data.
// WARNING !!! Caller is responsible for freeing Gem Ocean memory !
HIDEAGEM_DLL_EXPORT uint8_t* HIDEAGEM_HIDE_GEM_FILES_32_BIT_C(
    int gem_protocol,
    void* ocean,
    uint32_t ocean_size,
    const uint8_t** gem_files,
    const uint32_t* gem_file_sizes,
    const char** gem_file_names,
    const uint32_t num_gem_files,
    const char* password,
    int time_trap,
    uint32_t* out_ocean_size,
    bool b_validate
);

///
//    FIND GEMS

// Found Gem Files (local to each thread)
thread_local std::vector<HideAGemCore::GemFile> FOUND_GEM_FILES_C;

HIDEAGEM_DLL_EXPORT void HIDEAGEM_FIND_GEMS_C(
    void* ocean,
    uint64_t ocean_size,
    const char* password,
    const char* output_dir,
    bool b_time_trap
);

HIDEAGEM_DLL_EXPORT void HIDEAGEM_FIND_GEMS_32_BIT_C(
    void* ocean,
    uint32_t ocean_size,
    const char* password,
    const char* output_dir,
    bool b_time_trap
);

HIDEAGEM_DLL_EXPORT uint8_t* HIDEAGEM_GET_GEM_FILE_DATA_C(size_t index)
{
    if (index < FOUND_GEM_FILES_C.size())
    {
        return FOUND_GEM_FILES_C[index].data();
    }

    return nullptr;
}

HIDEAGEM_DLL_EXPORT uint32_t HIDEAGEM_GET_GEM_FILE_SIZE_C(size_t index)
{
    if (index < FOUND_GEM_FILES_C.size())
    {
        return FOUND_GEM_FILES_C[index].size();
    }

    return 0;
}

HIDEAGEM_DLL_EXPORT const char* HIDEAGEM_GET_GEM_FILE_NAME_C(size_t index)
{
    if (index < FOUND_GEM_FILES_C.size())
    {
        return (const char*)FOUND_GEM_FILES_C[index].name().c_str();
    }

    return nullptr;
}

HIDEAGEM_DLL_EXPORT uint32_t HIDEAGEM_GET_NUM_GEM_FILES_C()
{
    return FOUND_GEM_FILES_C.size();
}

HIDEAGEM_DLL_EXPORT void HIDEAGEM_EMPTY_GEM_FILES_C()
{
    FOUND_GEM_FILES_C.clear();
}

HIDEAGEM_DLL_EXPORT void HIDEAGEM_PRINT_SPLASH_SCREEN_C()
{
    HideAGemCore::PRINT_SPLASH_SCREEN();
}

///
//    UTILITIES

HIDEAGEM_DLL_EXPORT void HIDEAGEM_ACTIVATE_DEMO_MODE_C();

HIDEAGEM_DLL_EXPORT bool HIDEAGEM_RUN_UNIT_TESTS_C(
    bool b_loop,
    bool b_demo_mode
);

HIDEAGEM_DLL_EXPORT void HIDEAGEM_FREE_OCEAN_C(void* ocean);

#ifdef __cplusplus
}
#endif

