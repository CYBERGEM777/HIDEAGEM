//
//  888    888 8888888 8888888b.  8888888888        d8888  .d8888b.  8888888888 888b     d888
//  888    888   888   888  "Y88b 888              d88888 d88P  Y88b 888        8888b   d8888
//  888    888   888   888    888 888             d88P888 888    888 888        88888b.d88888
//  8888888888   888   888    888 8888888        d88P 888 888        8888888    888Y88888P888
//  888    888   888   888    888 888           d88P  888 888  88888 888        888 Y888P 888
//  888    888   888   888    888 888          d88P   888 888    888 888        888  Y8P  888
//  888    888   888   888  .d88P 888         d8888888888 Y88b  d88P 888        888   "   888
//  888    888 8888888 8888888P"  8888888888 d88P     888  "Y8888P88 8888888888 888       888
// ▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄
// ▄    ____ ______ ____                                      ▄                              ▄
// █   /    /      \    \   HIDEAGEM STEGANOGRAPHY PLATFORM   █                  .     .     █
// █  /___ /________\ ___\                                    █   .-.   .-.      '.___.'     █
// █  \    \        /    /  ASTRAL SOFTWARE FROM THE FUTURE   █  (_  \ /  _)     .'   `.     █
// █    \   \      /   /                                      █       |         :       :    █
// █      \  \    /  /      COPYRIGHT 2024 WWW.CYBERGEM.NET   █       |         :       :    █
// █        \ \  / /                                          █       |          `.___.'     █
// █           \/           LET'S DO COMPUTER STUFF ALL DAY   █                              █
// █                                                          █                              █
// █ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀ █    ._____.         .--.      █
// █ MMMMMSSSSSSSSSSSSSSSSSSSSSSSSSSddMMMMMSSSSSSMSSSSSSSSSS; █      | |          /   _`.    █
// █ MMMMSSSSSSSSSSSSSSSSSMSSSSS; ;SSdMMMMSSSSSSMMSSSSSSSSSS, █      | |         (_) ( )     █
// █ MMSSSSSSSMSSSSSMSSSSMMMSS."-.-":MMMMMSSSSMMMMSSMSSSMMSS  █     _|_|_       '.    /      █
// █ MSSSSSSSMSSSSMMMSSMMMPTMM;"-/\":MMM^"     MMMSSMMMSSMM   █    '     '        `--'       █
// █ SSSSSSSMMSSMMMMMMMMMP-.MMM :  ;.;P       dMMMMMMMMMP'    █                              █
// █ SSMSSSMMMSMMMMMMMMMP   :M;`:  ;.'+"""t+dMMMMMMMMMMP      █                _             █
// █ MMMSSMMMMMMMMPTMMMM"""":P `.\// '    ""^^MMMMMMMP'       █      .--.     ' `:--.--.     █
// █ MMMMMMPTMMMMP="TMMMsg,      \/   db`c"  dMMMMMP"         █     (    )       |  |  |_    █
// █ MMMMMM  TMMM   d$$$b ^          /T$; ;-/TMMMP'  Let's    █    (_)  /        |  |  | )   █
// █ MMMMM; .^`M; d$P^T$$b          :  $$ ::MMMMP  hide some  █        (_,       |  |  |/    █
// █ MMMMMM   .-+d$$   $$$;         ;. $$ ;;MMMP,    Gems !   █                       (J     █
// █ MMMMMMb   _d$$$   $$$$         :$$$; :MMMMMMp.           █                              █
// █ MMMMMM"  " T$$$._.$$$;          T$P.'MMMSSSSSSb          █                _             █
// █ MMM`TMb   -")T$$$$$$P'       `._ ""  :MMSSSMMP'          █       __      ' `:--.--.     █
// █ MMM / \    '  "T$$P"           /     :MMMMMMP'           █  ___.'  '.___    |  |  |     █
// █ MMSb`. ;                      "      :MMMMMM'            █  ____________    |  |  |     █
// █ MMSSb_lSSSb.             .___.       MMMMMP ,d88b.d88b,  █                  |  |  | .., █
// █ MMMMSSSSSSSSb.                     .MMMMMM. 88888888888  █                        `--': █
// █ MMMMMMMMMMMSSSb                  .dMMMMMMMP `Y8888888Y'  █                              █
// █ MMMMMMMMMMMMMSS;               .dMMMMMMMMMM'  `Y888Y'    █         ...             _    █
// █ MMMMGEMMAMMMMb`;"-.          .dMMMMMMMMMMP'     `Y'      █         .':     \      /_)   █
// █ MMMMMMMMMMMMMMb:   `'--.___.dMMMMMMMMMPP'                █       .'         \    /`.    █
// █ MMMMMMMMMMMMMMMb;           dMMMMMMMMPPR                 █   `..'            \  /   ;   █
// █ ▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄ █   .'`.             \/ __.'   █
// █                                                          █                              █
// █          ░░░░░░░░          ▒▒▒▒▒▒▒▒          ░░░░░░░░    █                              █
// █       ▓▓▓░░ ████████    ███▒▒ ▓▓▓▓▓▓▓▓    ▓▓▓░░ ████████ █                 `-.    .-'   █
// █    ▒▒▒▓▓ ░░ ██ ▒▒▒▒▒▒░░░██ ▒▒ ▓▓ ░░░░░░▒▒▒▓▓ ░░ ██+§¥µ██ █ .-"-._.-"-._.-     :  :      █
// █ ███▒▒ ▓▓ ░░░██ ▒▒ ▓▓▓░░ ██ ▒▒▒▓▓ ░░ ███▒▒ ▓▓ ░░░██$@¢¶██ █ .-"-._.-"-._.-   --:--:--    █
// █ ██ ▒▒ ▓▓▓▓▓▓███▒▒ ▓▓ ░░ ██████▓▓▓░░ ██ ▒▒ ▓▓▓▓▓▓████████ █                    :  :      █
// █ ██ ▒▒▒▒▒▒▒▒    ▒▒▒▓▓ ░░░░░░░░    ░░░██ ▒▒▒▒▒▒▒▒          █                 .-'    `-.   █
// █ ████████          ▓▓▓▓▓▓▓▓          ████████    CYBERGEM █                              █
// ▀                                                          ▀                              ▀
// ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀

#pragma /* <3 */ once // upon a time ...

#include <array>
#include <string>

#define SODIUM_STATIC = 1
#include <sodium.h>

#include "EXCEPTION.h"
#include "HIDEAGEM_CONSTANTS.h"
#include "TRUE_RANDOM.h"
#include "DRAGON_RNG.h"

namespace HIDEAGEM_CORE {

//
//    THE CYCLE KEY
//
//    Ravenous shapeshifting sword made of fire and light that turns every way,
//    wrapped with a water breathing serpent that eats its own tail.

class CycleKey
{
public:

    CycleKey() {}

	~CycleKey();

	const uint8_t* salt() const;

	size_t salt_size() const;

	uint8_t* salt_write();

	void init(const std::string& password);

	void regenerate();

	size_t key_size() const;

	const uint8_t* key()  const;

	GhostVector<uint8_t> copy_key(const bool b_cycle = true);

	DragonRNG copy_RNG(const bool b_cycle = true);

	void auto_cycle(const uint64_t _auto_cycle_bytes);

	void cycle();

	void reset_cycle();

	void vanish();

	bool is_valid() const;

    template<typename F>
    void consume(const F& key_food)
    {
        consume_internal(key_food);
    }

    template<typename F, std::size_t N>
    void consume(const std::array<F, N>& key_food)
    {
        for (const auto& food : key_food)
        {
            consume_internal(food);
        }
    }

    template<template<typename> class T, typename F>
    void consume(const T<F>& key_food)
    {
        for (const auto& food : key_food)
        {
            consume_internal(food);
        }
    }

    template <typename T>
    T rand()
    {
        T _rand = fire_rng.rand<T>();
        consume( _rand ); // Consume random output

        return _rand;
    }

    bool rand_bool()
    {
        bool _rand = fire_rng.rand_bool();
        consume( _rand ); // Consume random output

        return _rand;
    }

    template <typename T>
    T rand_range(const T end, T start = 0)
    {
        T _rand = fire_rng.rand_range<T>(end, start);
        consume( _rand ); // Consume random output

        return _rand;
    }


    template<typename T, std::size_t N>
    std::array<T, N> rand_sequence(const size_t len, T start = 0)
    {
        std::array<T, N> seq;

        for (T i = start; i < start + len; ++i)
        {
            seq[ i - start ] = i;
        }

        // Shuffle sequence in place using Fisher-Yates shuffle
        for (size_t i = seq.size() - 1; i >= 1; --i)
        {
            size_t j = rand_range<size_t>(i); // Consumes rand
            std::swap(seq[i], seq[j]);
        }

        return seq;
    }

private:

    using KeySliceIndex = uint8_t;
    using KeyFoodIndex  = uint8_t;

    static constexpr uint64_t KEY_SIZE       = 64;                                 // 512-bit key
    static constexpr uint64_t KEY_SLICE_SIZE = 32;                                 // 256-bit key slices
    static constexpr uint64_t NUM_KEY_SLICES = KEY_SIZE / KEY_SLICE_SIZE;          // 2 key slices
    static constexpr uint32_t KEY_ALGO       = crypto_pwhash_ALG_ARGON2ID13;       // Argon2id
    static constexpr uint64_t KEY_OPSLIMIT   = crypto_pwhash_OPSLIMIT_INTERACTIVE; // 2 opslimit
    static constexpr uint64_t KEY_MEMLIMIT   = crypto_pwhash_MEMLIMIT_INTERACTIVE; // 64 MB
    static constexpr uint32_t SALT_SIZE      = crypto_pwhash_SALTBYTES;            // 128-bit salt

    bool b_locked   = false;
    bool b_mem_init = false;

    uint8_t* _key      = nullptr;
    uint8_t* _salt     = nullptr;
    uint8_t* _fire_key = nullptr;
    uint8_t* _key_food = nullptr;

    uint64_t cycle_index      = 0;
    uint64_t fire_key_index   = 0;
    uint64_t auto_cycle_bytes = 0;

    DragonRNG fire_rng;

    std::array<KeySliceIndex, NUM_KEY_SLICES> key_slice_order;

    GhostVector<uint8_t> food_pile; // Bytes to be hashed into _key_food

    // --

    // DELETE COPY CONSTRUCTOR AND ASSIGNMENT OPERATOR
    CycleKey(const CycleKey& other)      = delete;
    CycleKey& operator=(const CycleKey&) = delete;

    // --

	void update_keys();

	void update_key_food();

	void update_fire_key();

	void mem_init();

	void lock();

	void gen_key(const std::string& password);

	void gen_key(const GhostVector<uint8_t>& password);

	void gen_key(const char* password, size_t password_size);

    template <typename F>
    void consume_internal(const F& key_food)
    {
        const uint8_t* food_bytes = reinterpret_cast<const uint8_t*>( &key_food );

        if ( auto_cycle_bytes > 0 )
        {
            // Add key food bytes to Food Pile
            for (size_t i = 0; i < sizeof(F); ++i)
            {
                food_pile.push_back( food_bytes[i] );

                if ( food_pile.size() >= auto_cycle_bytes )
                {
                    cycle(); // Auto cycle !
                }
            }
        }
        else
        {
            // Add key food bytes to Food Pile
            for (size_t i = 0; i < sizeof(F); ++i)
            {
                food_pile.push_back( food_bytes[i] );
            }
        }
    }
};

}; // namespace HIDEAGEM_CORE

